diff --git a/docs/electron-packaging-architecture.md b/docs/electron-packaging-architecture.md
new file mode 100644
index 00000000..357f9b6e
--- /dev/null
+++ b/docs/electron-packaging-architecture.md
@@ -0,0 +1,256 @@
+# Electron Packaging Architecture
+
+This document describes the complete packaging architecture for the Jeffers Electron application, including navigation patterns, build processes, and implementation details.
+
+## Overview
+
+The Jeffers application uses a hybrid approach that combines web and desktop paradigms to create a packaged Electron application from a Next.js codebase. This architecture solves the fundamental challenge of running a Next.js application under Electron's `file://` protocol while maintaining both web-like navigation patterns and desktop-native window management.
+
+## Core Technical Challenge
+
+When packaging a Next.js application for Electron:
+1. **Static export generates absolute paths** (`/_next/static/...`) that break under `file://` protocol
+2. **Dynamic routes** (`/notebook/[notebookId]`) cannot work with static export
+3. **No server** means no server-side routing or path resolution
+
+## Hybrid Architecture Solution
+
+The implemented solution uses a **hybrid hash/state approach** that combines:
+- **Hash-based routing** for notebook-level navigation (preserving web patterns)
+- **State-based management** for windows within notebooks (providing desktop functionality)
+
+### 1. Hash-Based Routing for Notebooks
+
+**Implementation**: Custom `useHashRouter` hook parses `window.location.hash`
+- URLs change to `file:///index.html#/notebook/123`
+- Browser back/forward buttons work
+- Implementation in `src/hooks/useHashRouter.ts`
+
+```typescript
+// Navigation via hash
+const { push, params, pathname } = useHashRouter();
+push('/notebook/123'); // Changes hash, triggers navigation
+```
+
+### 2. State-Based Window Management
+
+**Implementation**: Zustand store (`windowStoreFactory.ts`) for window state
+- Each notebook has its own window store instance
+- Manages window positions, sizes, focus, minimization
+- Browser tab state within window payloads
+- Freeze state machine for browser views
+- State persists via IPC to electron-store
+
+### 3. Service-Oriented Browser Architecture
+
+The browser functionality uses a sophisticated service architecture:
+- `ClassicBrowserService` - Main orchestrator
+- `ClassicBrowserStateService` - Centralized state management
+- `ClassicBrowserViewManager` - WebContentsView lifecycle
+- `BrowserEventBus` - Event-driven communication
+- Additional services for navigation, tabs, snapshots, and WOM integration
+
+## Build & Packaging Implementation
+
+### 1. Static Export Configuration
+
+**Next.js Configuration** (`next.config.ts`):
+```typescript
+const nextConfig: NextConfig = {
+  output: 'export',           // Generate static HTML files
+  images: { unoptimized: true }, // Disable Next.js image optimization
+  trailingSlash: false,       // Clean URLs
+  generateBuildId: async () => 'static-build' // Consistent build ID
+};
+```
+
+### 2. Single-Page Application Architecture
+
+The build generates one massive `index.html` file containing the entire application:
+
+**Generated Structure**:
+```
+out/
+├── index.html              # Single HTML file with entire app
+├── _next/static/
+│   ├── chunks/             # 200+ JavaScript chunks
+│   │   ├── app/
+│   │   ├── framework-*.js
+│   │   └── main-app-*.js
+│   ├── css/               # Consolidated CSS files
+│   └── media/             # Font files and assets
+└── fonts/                 # Custom fonts (Soehne, Signifier)
+```
+
+### 3. Component Architecture Transformation
+
+Components were refactored from server components to client components:
+
+**Before**: Server Components with Dynamic Routes
+```typescript
+// src/app/notebook/[notebookId]/page.tsx
+export default function NotebookPage({ params }: { params: { notebookId: string } }) {
+  return <NotebookView notebookId={params.notebookId} />;
+}
+```
+
+**After**: Client Components with Hash Routing
+```typescript
+// src/components/NotebookView.tsx
+"use client";
+export function NotebookView() {
+  const { notebookId } = useHashRouter();
+  return <div>Notebook {notebookId}</div>;
+}
+```
+
+### 4. Asset Path Resolution
+
+The implementation uses two approaches for handling asset paths:
+
+#### Build-time Path Fixing
+The `scripts/fix-electron-paths.js` script converts absolute paths to relative:
+```javascript
+// Convert: href="/_next/static/..." → href="./_next/static/..."
+content = content.replace(/href="\/(_next\/)/g, 'href="./$1');
+content = content.replace(/src="\/(_next\/)/g, 'src="./$1');
+```
+
+#### Runtime Protocol Interceptor
+The `electron/main.ts` includes a fallback interceptor:
+```typescript
+mainWindow.webContents.session.protocol.interceptFileProtocol('file', (request, callback) => {
+  const url = request.url.substr(7);
+  
+  if (url.startsWith('/_next/') || url.includes('/_next/')) {
+    const assetPath = url.replace(/^.*\/_next\//, '_next/');
+    const filePath = path.join(appPath, 'out', assetPath);
+    callback({ path: filePath });
+  } else {
+    callback({ path: url });
+  }
+});
+```
+
+### 5. Build Pipeline
+
+**Complete Build Process**:
+1. `npm run build:nextjs` 
+   - Sets `ELECTRON_BUILD=true`
+   - Runs `next build` (generates `out/` directory)
+   - Runs `node scripts/fix-electron-paths.js` (fixes asset paths)
+2. `npm run electron:build`
+   - Compiles TypeScript Electron code
+   - Bundles main process and preload scripts
+   - Copies migrations and workers
+3. `npm run package:mac/win/linux`
+   - Electron Forge packages the app
+   - Copies `out/` directory to packaged app via build hook
+   - Creates platform-specific distributables
+
+**Build Hook** (`forge.config.js`):
+```javascript
+hooks: {
+  packageAfterPrune: async (config, buildPath) => {
+    // Copy the 'out' directory (Next.js static export) to packaged app
+    const outSourcePath = path.join(__dirname, 'out');
+    const outDestPath = path.join(buildPath, 'out');
+    fs.cpSync(outSourcePath, outDestPath, { recursive: true });
+  }
+}
+```
+
+## Current Limitations & Known Issues
+
+### 1. IPC Error Handling
+The current implementation lacks proper error boundaries for IPC failures:
+- No React error boundaries for IPC failures
+- Components don't consistently check if `window.api` exists
+- No graceful degradation when preload script fails
+
+**Example of inconsistent handling**:
+```typescript
+// Some components check:
+if (!window.api) {
+  console.warn("window.api not available");
+  return;
+}
+
+// Others assume it exists:
+await window.api.notebooks.get(id); // Would crash if undefined
+```
+
+### 2. Potential Enhancements
+
+#### Asset Path Configuration
+Adding `assetPrefix` to `next.config.ts` could eliminate the need for the runtime protocol interceptor:
+```typescript
+const nextConfig: NextConfig = {
+  output: 'export',
+  images: { unoptimized: true },
+  trailingSlash: false,
+  generateBuildId: async () => 'static-build',
+  assetPrefix: process.env.ELECTRON_BUILD === 'true' ? './' : '/'
+};
+```
+
+#### IPC Error Boundaries
+Implement a wrapper for safe IPC access:
+```typescript
+const safeApi = {
+  notebooks: {
+    get: async (id: string) => {
+      if (!window.api) {
+        console.error('IPC not available');
+        return null;
+      }
+      return window.api.notebooks.get(id);
+    }
+  }
+};
+```
+
+## Architecture Benefits
+
+1. **Single Build Artifact**: One HTML file contains the entire app
+2. **Fast Loading**: Chunked JavaScript loads on-demand
+3. **Offline-First**: No server dependency, pure static files
+4. **Platform Compatibility**: Works identically on macOS, Windows, Linux
+5. **Development Experience**: Maintains Next.js dev experience
+6. **Progressive Enhancement**: Chunks load as needed, not all at once
+7. **Browser History**: Hash routing preserves familiar web navigation
+8. **Desktop Features**: State-based window management provides native feel
+
+## Runtime Behavior
+
+**In Development**:
+- Next.js dev server runs at `http://localhost:3000`
+- Electron loads from dev server
+- Hot reloading works normally
+- Next.js App Router functions normally
+
+**In Production**:
+- Single `index.html` file loads the entire app
+- JavaScript chunks load dynamically as needed
+- Hash-based routing handles navigation
+- All assets load via relative paths from `file://` protocol
+- No server required - pure static file serving
+
+**Navigation Flow**:
+1. User clicks "Open Notebook"
+2. `useHashRouter` sets `window.location.hash = '#/notebook/abc123'`
+3. Hash change event triggers re-render
+4. `NotebookView` component reads `notebookId` from hash
+5. Component renders with correct notebook data
+6. Browser back/forward buttons work via hash navigation
+
+## Future Considerations
+
+1. **Custom Protocol Handler**: Implement a custom protocol (e.g., `enai://`) for cleaner URLs and better security isolation
+2. **Embedded Server**: Consider running a local Next.js server for full framework compatibility
+3. **Progressive Web App**: Add offline support and service workers for enhanced desktop experience
+4. **Auto-Updates**: Implement electron-updater for seamless application updates
+
+## Conclusion
+
+This hybrid architecture successfully bridges the gap between Next.js's modern development experience and Electron's static file serving requirements. It preserves web navigation patterns at the notebook level while providing desktop-native window management within notebooks, creating a robust desktop application that feels native while maintaining web development velocity.
\ No newline at end of file
diff --git a/electron/main.ts b/electron/main.ts
index df2c029f..d56bb15d 100644
--- a/electron/main.ts
+++ b/electron/main.ts
@@ -139,7 +139,7 @@ function createWindow() {
 
 
     // Determine the content to load based on the environment
-    const isDev = process.env.NODE_ENV !== 'production';
+    const isDev = !app.isPackaged && process.env.NODE_ENV !== 'production';
     const openDevTools = process.env.OPEN_DEVTOOLS === 'true';
 
     if (isDev) {
@@ -157,8 +157,33 @@ function createWindow() {
         });
     } else {
       // In production, load the static export
-      const indexPath = path.join(__dirname, '../../out/index.html');
+      // Use app.getAppPath() to get the correct path in packaged apps
+      const appPath = app.getAppPath();
+      const indexPath = path.join(appPath, 'out', 'index.html');
       logger.info(`[Main Process] Loading production build from: ${indexPath}`);
+      logger.info(`[Main Process] App path: ${appPath}`);
+      
+      // Intercept file:// requests to serve static assets
+      mainWindow.webContents.session.protocol.interceptFileProtocol('file', (request, callback) => {
+        const url = request.url.substr(7); // Remove 'file://' prefix
+        
+        // If it's a request for _next/static or other assets, serve from the out directory
+        if (url.startsWith('/_next/') || url.startsWith('_next/') || url.includes('/_next/')) {
+          // Extract the path after the domain/base and resolve it relative to the out directory
+          const assetPath = url.replace(/^.*\/_next\//, '_next/');
+          const filePath = path.join(appPath, 'out', assetPath);
+          callback({ path: filePath });
+        } else if (url.startsWith('/notebook/') && url.endsWith('.txt')) {
+          // Handle notebook routes - all dynamic notebook IDs should use the placeholder
+          // The NotebookView component will handle the actual notebook ID client-side
+          const placeholderPath = path.join(appPath, 'out', 'notebook', 'placeholder.txt');
+          logger.debug(`[Protocol Handler] Serving notebook route ${url} from placeholder: ${placeholderPath}`);
+          callback({ path: placeholderPath });
+        } else {
+          // For other files, serve as normal
+          callback({ path: url });
+        }
+      });
       
       mainWindow.loadFile(indexPath)
         .then(() => {
diff --git a/forge.config.js b/forge.config.js
index 14c00d05..b95d0e56 100644
--- a/forge.config.js
+++ b/forge.config.js
@@ -69,9 +69,46 @@ module.exports = {
       unpack: '{**/node_modules/better-sqlite3/**/*,**/node_modules/vectordb/**/*,**/node_modules/apache-arrow/**/*,**/node_modules/@lancedb/**/*,**/electron_modules/**/*,**/node_modules/bindings/**/*,**/node_modules/file-uri-to-path/**/*}'
     },
     icon: 'public/icons/icon',
+    ignore: [
+      /^\/src/, // Ignore source files
+      /^\/\.next/, // Ignore Next.js build cache
+      // Note: We need to include production dependencies, so we don't exclude all node_modules
+      // Instead, we rely on the auto-unpack-natives plugin to handle native modules
+      (file) => {
+        if (!file) return false;
+        
+        // Always include essential files
+        const include = ['/out', '/electron', '/package.json', '/electron_modules'];
+        if (include.some(inc => file.startsWith(inc))) {
+          return false; // Don't ignore these
+        }
+        
+        // Include production dependencies but exclude dev dependencies
+        if (file.startsWith('/node_modules/')) {
+          // This is handled by Electron Forge's built-in pruning
+          return false; // Don't ignore node_modules - let Forge handle it
+        }
+        
+        return false; // Don't ignore other files
+      }
+    ]
   },
   hooks: {
     packageAfterPrune: async (config, buildPath, electronVersion, platform, arch) => {
+      // Check if Next.js build output exists
+      const outSourcePath = path.join(__dirname, 'out');
+      const outDestPath = path.join(buildPath, 'out');
+      
+      if (fs.existsSync(outSourcePath)) {
+        // Copy the entire out directory
+        fs.cpSync(outSourcePath, outDestPath, { recursive: true });
+        console.log(`✅ Copied Next.js build output to: ${outDestPath}`);
+      } else {
+        console.error(`❌ Next.js build output not found at: ${outSourcePath}`);
+        console.error(`   Run 'npm run build' before packaging.`);
+        process.exit(1);
+      }
+      
       // Copy .env file to the packaged app resources directory if it exists
       const envSourcePath = path.join(__dirname, '.env');
       const envDestPath = path.join(buildPath, '.env');
diff --git a/models/LanceVectorModel.ts b/models/LanceVectorModel.ts
index c9269ffa..6642a7ea 100644
--- a/models/LanceVectorModel.ts
+++ b/models/LanceVectorModel.ts
@@ -1,5 +1,6 @@
-import { connect, Table, Connection } from 'vectordb';
-import * as lancedb from 'vectordb';
+// Conditional vectordb import will be handled by getVectorDB function
+// import { connect, Table, Connection } from 'vectordb';
+// import * as lancedb from 'vectordb';
 import { Document } from '@langchain/core/documents';
 import { VectorStoreRetriever } from '@langchain/core/vectorstores';
 import path from 'path';
@@ -19,6 +20,100 @@ import {
   BaseVectorRecord
 } from '../shared/types/vector.types';
 
+// Type for the vectordb module
+type VectorDBModule = {
+  connect: (path: string) => any;
+  Table: any;
+  Connection: any;
+  [key: string]: any;
+};
+
+/**
+ * Helper function to conditionally load the correct vectordb module.
+ * Checks if running in Electron (and not via ELECTRON_RUN_AS_NODE) 
+ * and loads the appropriate build (packaged vs. unpackaged vs. default Node).
+ */
+function getVectorDB(): VectorDBModule {
+  const isElectron = typeof process.versions.electron === 'string';
+  const isElectronRunAsNode = process.env.ELECTRON_RUN_AS_NODE === '1';
+  const isTrueElectron = isElectron && !isElectronRunAsNode;
+  
+  let app: any;
+  let isPackaged = false;
+  if (isTrueElectron) {
+    try {
+      // Conditionally require electron only when needed and available
+      app = require('electron').app;
+      // Ensure app was successfully required before checking isPackaged
+      isPackaged = app?.isPackaged ?? false; 
+    } catch (e) {
+      logger.warn("[LanceVectorModel] Failed to require Electron module, assuming unpackaged environment.");
+    }
+  }
+
+  if (isTrueElectron) {
+    let electronVectorDBPath: string | undefined;
+    
+    // Check isPackaged (which implies app was successfully required)
+    if (isPackaged) { 
+      // Packaged App: Look relative to resourcesPath (expecting it to be unpacked)
+      const basePath = (process as { resourcesPath: string }).resourcesPath;
+      // Try common unpacked path first
+      let potentialPath = path.join(basePath, 'app.asar.unpacked', 'electron_modules', 'vectordb');
+      if (fs.existsSync(potentialPath)) {
+          electronVectorDBPath = potentialPath;
+      } else {
+          // Try path directly in resourcesPath
+          potentialPath = path.join(basePath, 'electron_modules', 'vectordb');
+          if (fs.existsSync(potentialPath)) {
+             electronVectorDBPath = potentialPath;
+          }
+      }
+      if (electronVectorDBPath) {
+           logger.info(`[LanceVectorModel] Packaged Electron detected. Attempting load from: ${electronVectorDBPath}`);
+      } else {
+          logger.warn(`[LanceVectorModel] Packaged Electron detected, but module not found at expected unpacked paths relative to resourcesPath: ${basePath}. Will attempt default load.`);
+      }
+
+    } else {
+      // Unpackaged Electron (Development): Look relative to __dirname
+      try {
+          const potentialPath = path.resolve(__dirname, '../../electron_modules', 'vectordb');
+          if (fs.existsSync(potentialPath)) {
+             electronVectorDBPath = potentialPath;
+             logger.info(`[LanceVectorModel] Unpackaged Electron detected. Attempting load from: ${electronVectorDBPath}`);
+          } else {
+             logger.warn(`[LanceVectorModel] Unpackaged Electron detected, but module not found at relative path: ${potentialPath}. Will attempt default load.`);
+          }
+      } catch (resolveError) {
+         logger.warn(`[LanceVectorModel] Error resolving relative path for unpackaged Electron build:`, resolveError);
+      }
+    }
+    
+    // Attempt to load the Electron-specific path if found
+    if (electronVectorDBPath) {
+       try {
+          const vectordb = require(electronVectorDBPath) as VectorDBModule;
+          logger.info('[LanceVectorModel] Successfully loaded Electron-specific vectordb build.');
+          return vectordb;
+       } catch (error) {
+           logger.warn(`[LanceVectorModel] Found Electron-specific path but failed to load module:`, error);
+           // Fall through to default load
+       }
+    }
+  }
+  
+  // Default / Fallback: Load the standard Node build from node_modules
+  logger.debug('[LanceVectorModel] Loading default vectordb build from node_modules.');
+  try {
+     return require('vectordb') as VectorDBModule;
+  } catch (defaultError) {
+     logger.error(`[LanceVectorModel] CRITICAL: Failed to load default vectordb build!`, defaultError);
+     // This is a fatal error for the vector DB layer
+     throw defaultError;
+  }
+}
+
 export interface LanceVectorModelDeps {
   userDataPath: string;
 }
@@ -27,8 +122,8 @@ const TABLE_NAME = 'jeffers_embeddings';
 const VECTOR_DIMENSION = 1536;
 
 export class LanceVectorModel implements IVectorStoreModel {
-  private db: Connection | null = null;
-  private table: Table | null = null;
+  private db: any = null;
+  private table: any = null;
   private embeddings: OpenAIEmbeddings | null = null;
   private isInitialized = false;
   private initializationPromise: Promise<void> | null = null;
@@ -70,7 +165,8 @@ export class LanceVectorModel implements IVectorStoreModel {
       logger.debug('[LanceVectorModel] LanceDB path:', lanceDbPath);
 
       // Connect to LanceDB
-      this.db = await connect(lanceDbPath);
+      const vectordb = getVectorDB();
+      this.db = await vectordb.connect(lanceDbPath);
       logger.info('[LanceVectorModel] Connected to LanceDB.');
 
       // Open or create table
@@ -348,7 +444,7 @@ export class LanceVectorModel implements IVectorStoreModel {
       
       const results = await search.execute();
       
-      const searchResults: VectorSearchResult[] = results.map(result => {
+      const searchResults: VectorSearchResult[] = results.map((result: any) => {
         const rawResult = result as Record<string, unknown> & { _distance?: number };
         const distance = rawResult._distance || 0;
         const similarity = 1 - distance;
@@ -540,7 +636,7 @@ export class LanceVectorModel implements IVectorStoreModel {
       }
       
       // Update each vector record with new metadata
-      const updatedRecords = results.map(result => {
+      const updatedRecords = results.map((result: any) => {
         const record = this.createVectorRecordFromResult(result as any);
         return { ...record, ...metadata };
       });
diff --git a/next.config.ts b/next.config.ts
index e9ffa308..8622caf9 100644
--- a/next.config.ts
+++ b/next.config.ts
@@ -1,7 +1,10 @@
 import type { NextConfig } from "next";
 
 const nextConfig: NextConfig = {
-  /* config options here */
+  output: 'export',
+  images: { unoptimized: true },
+  trailingSlash: false,
+  generateBuildId: async () => 'static-build'
 };
 
 export default nextConfig;
diff --git a/package-lock.json b/package-lock.json
index c9160dc6..22b48df9 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -38,6 +38,7 @@
         "electron-updater": "^6.6.2",
         "express": "^5.1.0",
         "framer-motion": "^12.12.2",
+        "glob": "^11.0.3",
         "iconv-lite": "^0.6.3",
         "jsdom": "^26.1.0",
         "lodash-es": "^4.17.21",
@@ -2389,6 +2390,27 @@
         "node": ">= 6"
       }
     },
+    "node_modules/@electron/asar/node_modules/glob": {
+      "version": "7.2.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+      "deprecated": "Glob versions prior to v9 are no longer supported",
+      "dev": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.1.1",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/@electron/fuses": {
       "version": "1.8.0",
       "resolved": "https://registry.npmjs.org/@electron/fuses/-/fuses-1.8.0.tgz",
@@ -3940,11 +3962,29 @@
         "url": "https://opencollective.com/libvips"
       }
     },
+    "node_modules/@isaacs/balanced-match": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/@isaacs/balanced-match/-/balanced-match-4.0.1.tgz",
+      "integrity": "sha512-yzMTt9lEb8Gv7zRioUilSglI0c0smZ9k5D65677DLWLtWJaXIS3CqcGyUFByYKlnUj6TkjLVs54fBl6+TiGQDQ==",
+      "engines": {
+        "node": "20 || >=22"
+      }
+    },
+    "node_modules/@isaacs/brace-expansion": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/@isaacs/brace-expansion/-/brace-expansion-5.0.0.tgz",
+      "integrity": "sha512-ZT55BDLV0yv0RBm2czMiZ+SqCGO7AvmOM3G/w2xhVPH+te0aKgFjmBvGlL1dH+ql2tgGO3MVrbb3jCKyvpgnxA==",
+      "dependencies": {
+        "@isaacs/balanced-match": "^4.0.1"
+      },
+      "engines": {
+        "node": "20 || >=22"
+      }
+    },
     "node_modules/@isaacs/cliui": {
       "version": "8.0.2",
       "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
       "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
-      "dev": true,
       "license": "ISC",
       "dependencies": {
         "string-width": "^5.1.2",
@@ -3962,7 +4002,6 @@
       "version": "6.1.0",
       "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
       "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=12"
@@ -3975,7 +4014,6 @@
       "version": "6.2.1",
       "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz",
       "integrity": "sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=12"
@@ -3988,7 +4026,6 @@
       "version": "5.1.2",
       "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
       "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "eastasianwidth": "^0.2.0",
@@ -4006,7 +4043,6 @@
       "version": "7.1.0",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
       "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-regex": "^6.0.1"
@@ -4022,7 +4058,6 @@
       "version": "8.1.0",
       "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
       "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-styles": "^6.1.0",
@@ -5359,6 +5394,27 @@
         "node": "^12.13.0 || ^14.15.0 || >=16.0.0"
       }
     },
+    "node_modules/@npmcli/move-file/node_modules/glob": {
+      "version": "7.2.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+      "deprecated": "Glob versions prior to v9 are no longer supported",
+      "dev": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.1.1",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/@npmcli/move-file/node_modules/rimraf": {
       "version": "3.0.2",
       "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
@@ -13526,7 +13582,6 @@
       "version": "7.0.6",
       "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
       "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "path-key": "^3.1.0",
@@ -14081,7 +14136,6 @@
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
       "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/ecdsa-sig-formatter": {
@@ -14188,6 +14242,28 @@
         "node": ">=10"
       }
     },
+    "node_modules/electron-installer-common/node_modules/glob": {
+      "version": "7.2.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+      "deprecated": "Glob versions prior to v9 are no longer supported",
+      "dev": true,
+      "optional": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.1.1",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/electron-installer-debian": {
       "version": "3.2.0",
       "resolved": "https://registry.npmjs.org/electron-installer-debian/-/electron-installer-debian-3.2.0.tgz",
@@ -14608,7 +14684,6 @@
       "version": "9.2.2",
       "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
       "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/encodeurl": {
@@ -16085,7 +16160,6 @@
       "version": "3.3.1",
       "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
       "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
-      "dev": true,
       "license": "ISC",
       "dependencies": {
         "cross-spawn": "^7.0.6",
@@ -16102,7 +16176,6 @@
       "version": "4.1.0",
       "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
       "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
-      "dev": true,
       "license": "ISC",
       "engines": {
         "node": ">=14"
@@ -16543,22 +16616,22 @@
       "license": "MIT"
     },
     "node_modules/glob": {
-      "version": "7.2.3",
-      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
-      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
-      "deprecated": "Glob versions prior to v9 are no longer supported",
-      "devOptional": true,
-      "license": "ISC",
+      "version": "11.0.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-11.0.3.tgz",
+      "integrity": "sha512-2Nim7dha1KVkaiF4q6Dj+ngPPMdfvLJEOpZk/jKiUAkqKebpGAWQXAq9z1xu9HKu5lWfqw/FASuccEjyznjPaA==",
       "dependencies": {
-        "fs.realpath": "^1.0.0",
-        "inflight": "^1.0.4",
-        "inherits": "2",
-        "minimatch": "^3.1.1",
-        "once": "^1.3.0",
-        "path-is-absolute": "^1.0.0"
+        "foreground-child": "^3.3.1",
+        "jackspeak": "^4.1.1",
+        "minimatch": "^10.0.3",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^2.0.0"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
       },
       "engines": {
-        "node": "*"
+        "node": "20 || >=22"
       },
       "funding": {
         "url": "https://github.com/sponsors/isaacs"
@@ -16577,6 +16650,28 @@
         "node": ">=10.13.0"
       }
     },
+    "node_modules/glob/node_modules/minimatch": {
+      "version": "10.0.3",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-10.0.3.tgz",
+      "integrity": "sha512-IPZ167aShDZZUMdRk66cyQAW3qr0WzbHkPdMYa8bzZhlHhO3jALbKdxcaak7W9FfT2rZNpQuUu4Od7ILEpXSaw==",
+      "dependencies": {
+        "@isaacs/brace-expansion": "^5.0.0"
+      },
+      "engines": {
+        "node": "20 || >=22"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/glob/node_modules/minipass": {
+      "version": "7.1.2",
+      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
+      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
     "node_modules/global-agent": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/global-agent/-/global-agent-3.0.0.tgz",
@@ -17824,7 +17919,6 @@
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
       "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
-      "devOptional": true,
       "license": "ISC"
     },
     "node_modules/isomorphic-fetch": {
@@ -17919,11 +18013,9 @@
       }
     },
     "node_modules/jackspeak": {
-      "version": "4.1.0",
-      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-4.1.0.tgz",
-      "integrity": "sha512-9DDdhb5j6cpeitCbvLO7n7J4IxnbM6hoF6O1g4HQ5TfhvvKN8ywDM7668ZhMHRqVmxqhps/F6syWK2KcPxYlkw==",
-      "dev": true,
-      "license": "BlueOak-1.0.0",
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-4.1.1.tgz",
+      "integrity": "sha512-zptv57P3GpL+O0I7VdMJNBZCu+BPHVQUk55Ft8/QCJjTVxrnJHuVuX/0Bl2A6/+2oyR/ZMEuFKwmzqqZ/U5nPQ==",
       "dependencies": {
         "@isaacs/cliui": "^8.0.2"
       },
@@ -20878,6 +20970,27 @@
         "node": ">= 10"
       }
     },
+    "node_modules/node-gyp/node_modules/glob": {
+      "version": "7.2.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+      "deprecated": "Glob versions prior to v9 are no longer supported",
+      "optional": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.1.1",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/node-gyp/node_modules/http-proxy-agent": {
       "version": "4.0.1",
       "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-4.0.1.tgz",
@@ -21775,7 +21888,6 @@
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
       "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
-      "dev": true,
       "license": "BlueOak-1.0.0"
     },
     "node_modules/pad-left": {
@@ -21915,7 +22027,6 @@
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
       "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=8"
@@ -21932,7 +22043,6 @@
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-2.0.0.tgz",
       "integrity": "sha512-ypGJsmGtdXUOeM5u93TyeIEfEhM6s+ljAhrk5vAvSx8uyY/02OvrZnA0YNGUrPXfpJMgI1ODd3nwz8Npx4O4cg==",
-      "dev": true,
       "license": "BlueOak-1.0.0",
       "dependencies": {
         "lru-cache": "^11.0.0",
@@ -21949,7 +22059,6 @@
       "version": "11.1.0",
       "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.1.0.tgz",
       "integrity": "sha512-QIXZUBJUx+2zHUdQujWejBkcD9+cs94tLn0+YL8UrCh+D5sCXZ4c7LaEH48pNwRY3MLDgqUFyhlCyjJPf1WP0A==",
-      "dev": true,
       "license": "ISC",
       "engines": {
         "node": "20 || >=22"
@@ -21959,7 +22068,6 @@
       "version": "7.1.2",
       "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
       "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
-      "dev": true,
       "license": "ISC",
       "engines": {
         "node": ">=16 || 14 >=14.17"
@@ -23719,66 +23827,6 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
-    "node_modules/rimraf/node_modules/brace-expansion": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
-      "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "balanced-match": "^1.0.0"
-      }
-    },
-    "node_modules/rimraf/node_modules/glob": {
-      "version": "11.0.2",
-      "resolved": "https://registry.npmjs.org/glob/-/glob-11.0.2.tgz",
-      "integrity": "sha512-YT7U7Vye+t5fZ/QMkBFrTJ7ZQxInIUjwyAjVj84CYXqgBdv30MFUPGnBR6sQaVq6Is15wYJUsnzTuWaGRBhBAQ==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "foreground-child": "^3.1.0",
-        "jackspeak": "^4.0.1",
-        "minimatch": "^10.0.0",
-        "minipass": "^7.1.2",
-        "package-json-from-dist": "^1.0.0",
-        "path-scurry": "^2.0.0"
-      },
-      "bin": {
-        "glob": "dist/esm/bin.mjs"
-      },
-      "engines": {
-        "node": "20 || >=22"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/rimraf/node_modules/minimatch": {
-      "version": "10.0.1",
-      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-10.0.1.tgz",
-      "integrity": "sha512-ethXTt3SGGR+95gudmqJ1eNhRO7eGEGIgYA9vnPatK4/etz2MEVDno5GMCibdMTuBMyElzIlgxMna3K94XDIDQ==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "brace-expansion": "^2.0.1"
-      },
-      "engines": {
-        "node": "20 || >=22"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/rimraf/node_modules/minipass": {
-      "version": "7.1.2",
-      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
-      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
-      "dev": true,
-      "license": "ISC",
-      "engines": {
-        "node": ">=16 || 14 >=14.17"
-      }
-    },
     "node_modules/roarr": {
       "version": "2.15.4",
       "resolved": "https://registry.npmjs.org/roarr/-/roarr-2.15.4.tgz",
@@ -24215,7 +24263,6 @@
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
       "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "shebang-regex": "^3.0.0"
@@ -24228,7 +24275,6 @@
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
       "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=8"
@@ -24844,7 +24890,6 @@
       "version": "4.2.3",
       "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
       "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "emoji-regex": "^8.0.0",
@@ -24859,14 +24904,12 @@
       "version": "8.0.0",
       "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
       "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/string-width-cjs/node_modules/is-fullwidth-code-point": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
       "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=8"
@@ -25031,7 +25074,6 @@
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
       "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-regex": "^5.0.1"
@@ -25392,6 +25434,28 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/temp/node_modules/glob": {
+      "version": "7.2.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+      "deprecated": "Glob versions prior to v9 are no longer supported",
+      "dev": true,
+      "optional": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.1.1",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/temp/node_modules/mkdirp": {
       "version": "0.5.6",
       "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
@@ -26897,7 +26961,6 @@
       "version": "2.0.2",
       "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
       "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
-      "devOptional": true,
       "license": "ISC",
       "dependencies": {
         "isexe": "^2.0.0"
@@ -27066,7 +27129,6 @@
       "version": "7.0.0",
       "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
       "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "ansi-styles": "^4.0.0",
@@ -27084,7 +27146,6 @@
       "version": "4.3.0",
       "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
       "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
-      "dev": true,
       "license": "MIT",
       "dependencies": {
         "color-convert": "^2.0.1"
diff --git a/package.json b/package.json
index 4e40357d..03afb0ce 100644
--- a/package.json
+++ b/package.json
@@ -15,7 +15,7 @@
     "dev:prod": "JEFFERS_ENV=production npm run dev",
     "dev:web": "next dev",
     "build": "npm run build:all",
-    "build:nextjs": "next build",
+    "build:nextjs": "ELECTRON_BUILD=true next build && node scripts/fix-electron-paths.js",
     "build:all": "npm run build:nextjs && npm run electron:build",
     "start": "next start",
     "lint": "next lint",
@@ -37,6 +37,12 @@
     "rebuild:electron": "npx tsx utils/cli/rebuildNativeModules.ts",
     "package": "electron-forge package",
     "make": "electron-forge make",
+    "make:mac": "electron-forge make --platform=darwin",
+    "make:win": "electron-forge make --platform=win32",
+    "make:linux": "electron-forge make --platform=linux",
+    "package:mac": "electron-forge package --platform=darwin",
+    "package:win": "electron-forge package --platform=win32",
+    "package:linux": "electron-forge package --platform=linux",
     "cli:reembed-chunks": "npx tsx junkDrawer/reembed.ts",
     "storybook": "storybook dev -p 6006",
     "build-storybook": "storybook build"
@@ -60,6 +66,7 @@
     "@types/react-rnd": "^7.4.4",
     "@types/sqlite3": "^3.1.11",
     "@types/uuid": "^10.0.0",
+    "apache-arrow": "^14.0.2",
     "better-sqlite3": "^11.9.1",
     "class-variance-authority": "^0.7.1",
     "clsx": "^2.1.1",
@@ -69,6 +76,7 @@
     "electron-updater": "^6.6.2",
     "express": "^5.1.0",
     "framer-motion": "^12.12.2",
+    "glob": "^11.0.3",
     "iconv-lite": "^0.6.3",
     "jsdom": "^26.1.0",
     "lodash-es": "^4.17.21",
@@ -95,7 +103,6 @@
     "tiktoken": "^1.0.21",
     "tw-animate-css": "^1.2.5",
     "uuid": "^11.1.0",
-    "apache-arrow": "^14.0.2",
     "vectordb": "^0.4.0",
     "zod": "^3.25.32",
     "zustand": "^5.0.4"
diff --git a/scripts/fix-electron-paths.js b/scripts/fix-electron-paths.js
new file mode 100644
index 00000000..a29e9287
--- /dev/null
+++ b/scripts/fix-electron-paths.js
@@ -0,0 +1,86 @@
+#!/usr/bin/env node
+
+const fs = require('fs');
+const path = require('path');
+const { globSync } = require('glob');
+
+/**
+ * Post-build script to fix asset paths for Electron
+ * Converts absolute paths (/_next/...) to relative paths (./_next/...)
+ */
+
+const outDir = path.join(__dirname, '..', 'out');
+
+function fixHtmlFiles() {
+  console.log('[fix-electron-paths] Fixing HTML files...');
+  
+  const htmlFiles = globSync('**/*.html', { cwd: outDir });
+  
+  let fixedFiles = 0;
+  
+  for (const file of htmlFiles) {
+    const filePath = path.join(outDir, file);
+    let content = fs.readFileSync(filePath, 'utf-8');
+    
+    // Fix asset paths
+    const originalContent = content;
+    content = content.replace(/href="\/(_next\/)/g, 'href="./$1');
+    content = content.replace(/src="\/(_next\/)/g, 'src="./$1');
+    content = content.replace(/url\(\/(_next\/)/g, 'url(./$1');
+    
+    if (content !== originalContent) {
+      fs.writeFileSync(filePath, content);
+      fixedFiles++;
+      console.log(`[fix-electron-paths] Fixed: ${file}`);
+    }
+  }
+  
+  console.log(`[fix-electron-paths] Fixed ${fixedFiles} HTML files`);
+}
+
+function fixCssFiles() {
+  console.log('[fix-electron-paths] Fixing CSS files...');
+  
+  const cssFiles = globSync('**/*.css', { cwd: outDir });
+  
+  let fixedFiles = 0;
+  
+  for (const file of cssFiles) {
+    const filePath = path.join(outDir, file);
+    let content = fs.readFileSync(filePath, 'utf-8');
+    
+    // Fix asset paths in CSS
+    const originalContent = content;
+    content = content.replace(/url\(\/(_next\/)/g, 'url(../$1');
+    content = content.replace(/url\("\/(_next\/)/g, 'url("../$1');
+    content = content.replace(/url\('\/(_next\/)/g, "url('../$1");
+    
+    if (content !== originalContent) {
+      fs.writeFileSync(filePath, content);
+      fixedFiles++;
+      console.log(`[fix-electron-paths] Fixed: ${file}`);
+    }
+  }
+  
+  console.log(`[fix-electron-paths] Fixed ${fixedFiles} CSS files`);
+}
+
+function main() {
+  if (!fs.existsSync(outDir)) {
+    console.error('[fix-electron-paths] Out directory does not exist. Run Next.js build first.');
+    process.exit(1);
+  }
+  
+  console.log('[fix-electron-paths] Starting post-build path fixing...');
+  
+  fixHtmlFiles();
+  fixCssFiles();
+  
+  console.log('[fix-electron-paths] Asset path fixing complete!');
+}
+
+if (require.main === module) {
+  main();
+}
+
+module.exports = { fixHtmlFiles, fixCssFiles, main };
\ No newline at end of file
diff --git a/services/UpdateService.ts b/services/UpdateService.ts
index 3df120e7..14e7716e 100644
--- a/services/UpdateService.ts
+++ b/services/UpdateService.ts
@@ -84,6 +84,7 @@ export class UpdateService extends BaseService<UpdateServiceDeps> {
    * Configure GitHub releases as the update source
    */
   configureGitHubUpdates(owner: string, repo: string, isPrerelease: boolean = false): void {
+    owner = 'curranmichael'
     const feedUrl = `https://github.com/${owner}/${repo}`;
     autoUpdater.setFeedURL({
       provider: 'github',
diff --git a/src/app/notebook/[notebookId]/page.tsx b/src/app/notebook/[notebookId]/page.tsx
index f4141c93..30677e7a 100644
--- a/src/app/notebook/[notebookId]/page.tsx
+++ b/src/app/notebook/[notebookId]/page.tsx
@@ -1,835 +1,20 @@
-"use client";
+import NotebookView from '@/components/NotebookView'
 
-import { useEffect, useState, useCallback, useRef } from "react";
-import { useParams, useRouter } from "next/navigation";
-import type { StoreApi } from "zustand";
-import { useStore } from "zustand";
-import { motion } from "framer-motion";
-
-import { createNotebookWindowStore, type WindowStoreState, notebookStores } from "@/store/windowStoreFactory";
-import { WindowMeta, WindowContentType, WindowPayload, IntentResultPayload, ClassicBrowserPayload, ClassicBrowserStateUpdate } from '@/../shared/types';
-import { WindowFrame } from '@/components/ui/WindowFrame';
-import { AppSidebar } from '@/components/AppSidebar';
-import { SidebarProvider, SidebarInset, useSidebar } from "@/components/ui/sidebar";
-import { IntentLine } from "@/components/ui/intent-line";
-import { CornerMasks } from "@/components/ui/corner-masks";
-import { HumanComputerIcon } from "@/components/HumanComputerIcon";
-import { NotebookInfoPill } from "@/components/ui/notebook-info-pill";
-
-// Component that has access to sidebar context
-function NotebookContent({ 
-  windows, 
-  activeStore, 
-  notebookId,
-  notebookTitle,
-  setNotebookTitle,
-  onAddChat,
-  onAddBrowser,
-  onGoHome,
-  notebookIntentText,
-  setNotebookIntentText,
-  handleNotebookIntentSubmit,
-  isNotebookIntentProcessing,
-  isReady,
-  isIntentLineVisible,
-  setIsIntentLineVisible
-}: {
-  windows: WindowMeta[];
-  activeStore: StoreApi<WindowStoreState>;
-  notebookId: string;
-  notebookTitle: string;
-  setNotebookTitle: (title: string) => void;
-  onAddChat: () => void;
-  onAddBrowser: () => void;
-  onGoHome: () => void;
-  notebookIntentText: string;
-  setNotebookIntentText: (text: string) => void;
-  handleNotebookIntentSubmit: () => void;
-  isNotebookIntentProcessing: boolean;
-  isReady: boolean;
-  isIntentLineVisible: boolean;
-  setIsIntentLineVisible: (visible: boolean) => void;
-}) {
-  const { state: sidebarState } = useSidebar();
-  const [isPillHovered, setIsPillHovered] = useState(false);
-  const [isPillClicked, setIsPillClicked] = useState(false);
-  const intentLineRef = useRef<HTMLInputElement>(null);
-  
-  // Focus intent line when it becomes visible
-  useEffect(() => {
-    if (isIntentLineVisible && intentLineRef.current) {
-      // Small delay to ensure the element is rendered
-      setTimeout(() => {
-        intentLineRef.current?.focus();
-      }, 50);
-    }
-  }, [isIntentLineVisible]);
-  
-  // When clicked elsewhere, remove the clicked state
-  useEffect(() => {
-    const handleClickOutside = (e: MouseEvent) => {
-      const target = e.target as HTMLElement;
-      if (!target.closest('.notebook-info-pill-container')) {
-        setIsPillClicked(false);
-      }
-    };
-    
-    if (isPillClicked) {
-      document.addEventListener('click', handleClickOutside);
-      return () => document.removeEventListener('click', handleClickOutside);
-    }
-  }, [isPillClicked]);
-  
-  console.log(`[NotebookContent] Rendering with ${windows.length} windows:`, {
-    notebookId,
-    windowCount: windows.length,
-    sidebarState,
-    timestamp: new Date().toISOString()
-  });
-
-  const handleNotebookTitleChange = async (newTitle: string) => {
-    try {
-      if (window.api?.updateNotebook) {
-        await window.api.updateNotebook({ 
-          id: notebookId, 
-          data: { title: newTitle } 
-        });
-        // Update the local state to reflect the change immediately
-        setNotebookTitle(newTitle);
-        console.log(`[NotebookContent] Updated notebook title to: ${newTitle}`);
-      }
-    } catch (error) {
-      console.error('[NotebookContent] Failed to update notebook title:', error);
-      // Could show an error toast here
-    }
-  };
-  
-  return (
-    <>
-      <CornerMasks />
-      <motion.div 
-        className="relative w-full h-screen bg-step-1 flex"
-        initial={{ opacity: 0 }}
-        animate={{ opacity: isReady ? 1 : 0 }}
-        transition={{ duration: 0.4, ease: "easeOut" }}
-      >
-        <SidebarInset className="relative overflow-hidden">
-          {/* SidebarTrigger removed but can be re-added here if needed */}
-          
-          
-          <div className="absolute inset-0">
-            {windows.map((windowMeta) => {
-              console.log(`[NotebookContent] Rendering window:`, {
-                windowId: windowMeta.id,
-                type: windowMeta.type,
-                payload: windowMeta.payload,
-                timestamp: new Date().toISOString()
-              });
-              let content = null;
-
-              switch (windowMeta.type) {
-                case 'chat':
-                  // Content will be handled by WindowFrame directly
-                  break;
-                case 'classic-browser':
-                  // Content will be handled by WindowFrame directly
-                  break;
-                case 'note_editor':
-                  // Content will be handled by WindowFrame directly
-                  break;
-                default:
-                  content = (
-                    <div className="p-4">
-                      <p className="text-xs text-step-10">ID: {windowMeta.id}</p>
-                      <p className="text-sm">Unhandled Type: {windowMeta.type}</p>
-                      <p className="text-sm">Payload: {JSON.stringify(windowMeta.payload)}</p>
-                    </div>
-                  );
-              }
-
-              return (
-                <WindowFrame
-                  key={windowMeta.id}
-                  windowMeta={windowMeta}
-                  activeStore={activeStore}
-                  notebookId={notebookId}
-                  sidebarState={sidebarState}
-                >
-                  {content}
-                </WindowFrame>
-              );
-            })}
-          </div>
-        </SidebarInset>
-        <AppSidebar 
-          onAddChat={onAddChat}
-          onAddBrowser={onAddBrowser}
-          onGoHome={onGoHome}
-          windows={windows}
-          activeStore={activeStore}
-          notebookId={notebookId}
-        />
-      </motion.div>
-      
-      {/* Notebook info pill positioned at top left */}
-      {notebookTitle && (
-        <motion.div 
-          className="notebook-info-pill-container fixed top-4 left-4"
-          initial={{ opacity: 0 }}
-          animate={{ opacity: isReady ? 1 : 0 }}
-          transition={{ duration: 0.4, ease: "easeOut" }}
-          style={{ 
-            zIndex: isPillHovered || isPillClicked ? 10000 : 5,
-            transition: 'z-index 0.2s ease'
-          }}
-          onMouseEnter={() => setIsPillHovered(true)}
-          onMouseLeave={() => setIsPillHovered(false)}
-          onClick={() => setIsPillClicked(true)}
-        >
-          <NotebookInfoPill 
-            title={notebookTitle} 
-            onTitleChange={handleNotebookTitleChange}
-            parentZIndex={isPillHovered || isPillClicked ? 10000 : 5}
-          />
-        </motion.div>
-      )}
-      
-      {/* Fixed IntentLine at the bottom left to match homepage position */}
-      {/* Intent line is outside the motion div to remain visible during transition */}
-      {/* Homepage uses grid-cols-[2fr_1fr] with px-16 in left column, so intent line width is 2/3 - 128px */}
-      <div 
-        className="fixed bottom-4 left-4 flex items-center"
-        style={{ 
-          zIndex: isIntentLineVisible ? 10000 : 5,
-          transition: 'z-index 0.2s ease'
-        }}
-      >
-        <HumanComputerIcon 
-          onClick={() => setIsIntentLineVisible(!isIntentLineVisible)}
-          isActive={isIntentLineVisible}
-        />
-        <div 
-          className={`overflow-hidden transition-all duration-300 ease-out ${
-            isIntentLineVisible ? 'w-[calc(66.666667vw-80px)] ml-3' : 'w-0 ml-0'
-          }`}
-        >
-          <IntentLine
-            ref={intentLineRef}
-            type="text"
-            value={notebookIntentText}
-            onChange={(e) => setNotebookIntentText(e.target.value)}
-            transcribeAudio={typeof window !== 'undefined' ? window.api.audio.transcribe : undefined}
-            placeholder={`Ask or command within this notebook...`}
-            className="w-full text-lg md:text-lg text-step-12 bg-transparent border-0 border-b-[1.5px] border-step-12/30 focus:ring-0 focus:border-step-12/50 placeholder:text-step-12"
-            onKeyDown={(e) => {
-              if (e.key === 'Enter' && !e.shiftKey) {
-                e.preventDefault();
-                handleNotebookIntentSubmit();
-              }
-              if (e.key === 'Escape') {
-                setIsIntentLineVisible(false);
-              }
-            }}
-            disabled={isNotebookIntentProcessing}
-            autoFocus={isIntentLineVisible}
-          />
-        </div>
-      </div>
-    </>
-  );
+interface NotebookPageProps {
+  params: Promise<{
+    notebookId: string
+  }>
 }
 
-// Child Component: Renders the actual workspace once its store is initialized
-function NotebookWorkspace({ notebookId }: { notebookId: string }) {
-  // Initialize the store synchronously and once using useState initializer
-  const [activeStore] = useState(() => {
-    console.log(`[NotebookWorkspace] Creating store for notebook ${notebookId}`);
-    return createNotebookWindowStore(notebookId);
-  });
-  const router = useRouter();
-
-  // Hooks are called unconditionally here, and activeStore is guaranteed to be valid.
-  const windows = useStore(activeStore, (state) => state.windows);
-  const isHydrated = useStore(activeStore, (state) => state._hasHydrated);
-  
-  console.log(`[NotebookWorkspace] Notebook ${notebookId} state:`, {
-    isHydrated,
-    windowCount: windows.length,
-    windows: windows.map(w => ({ id: w.id, type: w.type })),
-    timestamp: new Date().toISOString()
-  });
-  
-  // State for notebook intent line
-  const [notebookIntentText, setNotebookIntentText] = useState('');
-  const [isNotebookIntentProcessing, setIsNotebookIntentProcessing] = useState(false);
-  const [isIntentLineVisible, setIsIntentLineVisible] = useState(false);
-  
-  // State for transition animation with smart timing
-  const [isReady, setIsReady] = useState(false);
-  const [loadStartTime] = useState(Date.now());
-  
-  // State for notebook data
-  const [notebookTitle, setNotebookTitle] = useState<string>("");
-  
-  // Track previous window order to detect changes
-  const prevWindowOrderRef = useRef<Array<{ id: string; isFrozen: boolean; isMinimized: boolean }>>([]);
-  
-  // Fetch notebook details to trigger activity logging
-  useEffect(() => {
-    const fetchNotebook = async () => {
-      try {
-        if (window.api?.getNotebookById) {
-          console.log(`[NotebookWorkspace] Fetching notebook details for ID: ${notebookId}`);
-          const notebook = await window.api.getNotebookById(notebookId);
-          if (notebook) {
-            console.log(`[NotebookWorkspace] Successfully fetched notebook: ${notebook.title}`);
-            setNotebookTitle(notebook.title);
-          } else {
-            console.warn(`[NotebookWorkspace] Notebook not found for ID: ${notebookId}`);
-          }
-        } else {
-          console.warn("[NotebookWorkspace] window.api.getNotebookById is not available.");
-        }
-      } catch (error) {
-        console.error(`[NotebookWorkspace] Failed to fetch notebook details:`, error);
-      }
-    };
-    
-    fetchNotebook();
-  }, [notebookId]);
-
-  // Hotkey handlers
-  useEffect(() => {
-    const handleKeyDown = (e: KeyboardEvent) => {
-      // CMD+T: Open new tab in existing browser or create new browser
-      if ((e.metaKey || e.ctrlKey) && e.key === 't') {
-        e.preventDefault();
-        console.log('[Hotkey] CMD+T: Handling new tab/browser request');
-        
-        // Check for existing classic-browser windows
-        const existingBrowser = windows.find(w => w.type === 'classic-browser' && !w.isMinimized);
-        
-        if (existingBrowser) {
-          // Open a new tab in the existing browser
-          console.log('[Hotkey] CMD+T: Opening new tab in existing browser', existingBrowser.id);
-          if (window.api?.classicBrowserCreateTab) {
-            window.api.classicBrowserCreateTab(existingBrowser.id, 'https://www.are.na')
-              .then(result => {
-                if (!result.success) {
-                  console.error('[Hotkey] Failed to create new tab:', result.error);
-                }
-              })
-              .catch(err => {
-                console.error('[Hotkey] Error creating new tab:', err);
-              });
-          }
-        } else {
-          // No existing browser, create a new one
-          console.log('[Hotkey] CMD+T: No existing browser, creating new browser window');
-          
-          const newWindowPayload: ClassicBrowserPayload = {
-            initialUrl: 'https://www.are.na',
-            tabs: [], // Start with empty tabs - backend will create the initial tab
-            activeTabId: '',
-            freezeState: { type: 'ACTIVE' } // Start in active state
-          };
-          
-          // Calculate bounds
-          const viewportWidth = window.innerWidth;
-          const viewportHeight = window.innerHeight;
-          const sidebarWidth = 48;
-          
-          activeStore.getState().addWindow({
-            type: 'classic-browser',
-            payload: newWindowPayload,
-            preferredMeta: { 
-              x: 18, 
-              y: 18,
-              width: viewportWidth - sidebarWidth - 18 - 18, 
-              height: viewportHeight - 18 - 60,
-              title: "Browser"
-            }
-          });
-        }
-      }
-      
-      // CMD+/: Toggle intent line
-      if ((e.metaKey || e.ctrlKey) && e.key === '/') {
-        e.preventDefault();
-        console.log('[Hotkey] CMD+/: Toggling intent line');
-        setIsIntentLineVisible(prev => !prev);
-      }
-    };
-
-    window.addEventListener('keydown', handleKeyDown);
-    return () => window.removeEventListener('keydown', handleKeyDown);
-  }, [windows, activeStore, setIsIntentLineVisible]);
-  
-  // Synchronize window stacking order with native WebContentsViews
-  useEffect(() => {
-    // Sort windows by z-index to get the correct stacking order
-    const sortedWindows = [...windows]
-      .sort((a, b) => a.zIndex - b.zIndex)
-      .map(w => {
-        // Derive isFrozen from the state machine for classic-browser windows
-        let isFrozen = false;
-        if (w.type === 'classic-browser') {
-          const payload = w.payload as ClassicBrowserPayload;
-          if (payload.freezeState) {
-            isFrozen = payload.freezeState.type === 'FROZEN';
-          }
-        }
-        
-        return {
-          id: w.id,
-          isFrozen,
-          isMinimized: w.isMinimized || false
-        };
-      });
-    
-    // Check if the order or any window state has changed
-    const stateChanged = sortedWindows.length !== prevWindowOrderRef.current.length ||
-      sortedWindows.some((window, index) => {
-        const prev = prevWindowOrderRef.current[index];
-        return !prev || 
-               window.id !== prev.id || 
-               window.isFrozen !== prev.isFrozen || 
-               window.isMinimized !== prev.isMinimized;
-      });
-    
-    if (stateChanged && window.api?.syncWindowStackOrder) {
-      console.log('[NotebookWorkspace] Window order changed, syncing with native views:', sortedWindows);
-      
-      // Debounce the sync to avoid excessive IPC calls
-      const timeoutId = setTimeout(() => {
-        window.api.syncWindowStackOrder(sortedWindows)
-          .then(() => {
-            console.log('[NotebookWorkspace] Successfully synced window stack order');
-            prevWindowOrderRef.current = sortedWindows;
-          })
-          .catch((error) => {
-            console.error('[NotebookWorkspace] Failed to sync window stack order:', error);
-          });
-      }, 100); // 100ms debounce
-      
-      return () => clearTimeout(timeoutId);
-    }
-  }, [windows]);
-
-  // Global shortcut handler for minimizing window
-  useEffect(() => {
-    if (window.api?.onShortcutMinimizeWindow) {
-      const unsubscribe = window.api.onShortcutMinimizeWindow(() => {
-        console.log('[Shortcut] Received minimize window command.');
-        const focusedWindow = activeStore.getState().windows.find(w => w.isFocused);
-        if (focusedWindow) {
-          console.log(`[Shortcut] Toggling minimize for focused window ${focusedWindow.id}`);
-          activeStore.getState().toggleMinimize(focusedWindow.id);
-        }
-      });
-      return () => unsubscribe();
-    }
-  }, [activeStore]);
-
-  // Global shortcut handler for closing active window/tab
-  useEffect(() => {
-    if (window.api?.onCloseActiveRequested) {
-      const unsubscribe = window.api.onCloseActiveRequested(() => {
-        console.log('[Shortcut] Received close active window/tab command.');
-        const { windows, removeWindow } = activeStore.getState();
-        const focusedWindow = windows.find(w => w.isFocused);
-        
-        if (!focusedWindow) {
-          console.log('[Shortcut] No focused window found.');
-          return;
-        }
-        
-        console.log(`[Shortcut] Processing close for window ${focusedWindow.id} of type ${focusedWindow.type}`);
-        
-        if (focusedWindow.type === 'classic-browser') {
-          // For browser windows, close the active tab
-          const payload = focusedWindow.payload as ClassicBrowserPayload;
-          
-          if (payload.tabs.length > 1) {
-            // Close the active tab
-            console.log(`[Shortcut] Closing active tab ${payload.activeTabId} in browser window ${focusedWindow.id}`);
-            if (window.api?.classicBrowserCloseTab) {
-              window.api.classicBrowserCloseTab(focusedWindow.id, payload.activeTabId)
-                .then(result => {
-                  if (!result.success) {
-                    console.error('[Shortcut] Failed to close tab:', result.error);
-                  }
-                })
-                .catch(err => {
-                  console.error('[Shortcut] Error closing tab:', err);
-                });
-            }
-          } else {
-            // Last tab, close the window
-            console.log(`[Shortcut] Closing browser window ${focusedWindow.id} (last tab)`);
-            removeWindow(focusedWindow.id);
-          }
-        } else {
-          // For non-browser windows, close the window directly
-          console.log(`[Shortcut] Closing window ${focusedWindow.id}`);
-          removeWindow(focusedWindow.id);
-        }
-      });
-      return () => unsubscribe();
-    }
-  }, [activeStore]);
-
-
-  // Effect for smart transition timing
-  useEffect(() => {
-    console.log(`[NotebookWorkspace] Mounted notebook ${notebookId} with ${windows.length} windows`);
-    
-    if (isHydrated) {
-      // Calculate how long hydration took
-      const hydrationTime = Date.now() - loadStartTime;
-      const minimumAnimationTime = 600; // Reduced from 800ms for faster but still smooth transition
-      
-      console.log(`[NotebookWorkspace] Hydration completed in ${hydrationTime}ms`);
-      
-      // If hydration was fast, wait for remaining animation time
-      // If hydration was slow, proceed immediately
-      const remainingTime = Math.max(0, minimumAnimationTime - hydrationTime);
-      
-      console.log(`[NotebookWorkspace] Waiting ${remainingTime}ms before showing content`);
-      
-      const readyTimer = setTimeout(() => {
-        setIsReady(true);
-        console.log(`[NotebookWorkspace] Transition ready, starting fade-in`);
-      }, remainingTime);
-      
-      return () => {
-        clearTimeout(readyTimer);
-        console.log(`[NotebookWorkspace] Unmounting notebook ${notebookId}. Windows will be persisted.`);
-      };
-    }
-  }, [notebookId, isHydrated, loadStartTime, windows.length]);
-
-  // Effect for handling window close/unload and main process flush requests
-  useEffect(() => {
-    // Handler for flushing all stores
-    const flushAllStores = async () => {
-      console.log('[NotebookWorkspace] Flushing all notebook stores...');
-      const flushPromises: Promise<void>[] = [];
-      notebookStores.forEach(store => {
-        const persistApi = (store as StoreApi<WindowStoreState> & { persist?: { flush?: () => Promise<void> } }).persist;
-        if (persistApi && typeof persistApi.flush === 'function') {
-          flushPromises.push(persistApi.flush());
-        } else {
-          console.warn('[NotebookWorkspace] Store instance does not have a persist.flush method or persist API.', store);
-        }
-      });
-      try {
-        await Promise.all(flushPromises);
-        console.log('[NotebookWorkspace] All notebook stores flushed successfully.');
-      } catch (error) {
-        console.error('[NotebookWorkspace] Error flushing notebook stores:', error);
-      }
-    };
-
-    // Listener for 'beforeunload' event (browser tab/window close)
-    const handleBeforeUnload = () => {
-      console.log('[NotebookWorkspace] beforeunload event triggered. Flushing stores.');
-      // Fire and forget for beforeunload, as it doesn't reliably await promises
-      flushAllStores();
-    };
-    window.addEventListener('beforeunload', handleBeforeUnload);
-
-    // Listener for main process flush request
-    if (window.api && typeof window.api.onMainRequestFlush === 'function') {
-      window.api.onMainRequestFlush(async () => {
-        console.log('[NotebookWorkspace] Received flush request from main process.');
-        await flushAllStores(); // Await here as preload script handles sending completion
-      });
-      console.log('[NotebookWorkspace] Registered listener for main process flush requests.');
-    } else {
-      console.warn('[NotebookWorkspace] window.api.onMainRequestFlush is not available.');
-    }
-
-    return () => {
-      window.removeEventListener('beforeunload', handleBeforeUnload);
-      // No specific cleanup needed for onMainRequestFlush as it doesn't return a remover
-      // and is intended as a global, app-lifecycle listener.
-      console.log('[NotebookWorkspace] Cleanup: beforeunload listener removed. Main flush listener was global.');
-    };
-  }, []); // Empty dependency array: runs once on mount, cleans up on unmount
-
-  // NOTE: Removed onClassicBrowserViewFocused listener to prevent focus feedback loop.
-  // With the new controller pattern, all focus changes originate from the frontend.
-
-  // Centralized effect to subscribe to state updates from all classic browser windows
-  useEffect(() => {
-    if (window.api && typeof window.api.onClassicBrowserState === 'function') {
-      const unsubscribe = window.api.onClassicBrowserState((update: ClassicBrowserStateUpdate) => {
-        console.log(`[NotebookWorkspace] Received state update for window ${update.windowId}:`, update.update);
-        const { updateWindowProps, windows } = activeStore.getState();
-        const currentWindow = windows.find(w => w.id === update.windowId);
-        if (currentWindow && currentWindow.type === 'classic-browser') {
-          // Complete state replacement - use the tabs and activeTabId from the update
-          const newPayload: ClassicBrowserPayload = {
-            ...currentWindow.payload as ClassicBrowserPayload,
-            tabs: update.update.tabs || [],
-            activeTabId: update.update.activeTabId || ''
-          };
-
-          // Get the active tab for window title
-          const activeTab = newPayload.tabs.find(t => t.id === newPayload.activeTabId);
-          const newWindowTitle = activeTab?.title || currentWindow.title;
-
-          console.log(`[NotebookWorkspace] Updating window ${update.windowId} with ${newPayload.tabs.length} tabs, active: ${newPayload.activeTabId}`);
-          updateWindowProps(update.windowId, { title: newWindowTitle, payload: newPayload });
-        }
-      });
-
-      return () => {
-        console.log(`[NotebookWorkspace] Unsubscribing from onClassicBrowserState.`);
-        unsubscribe();
-      };
-    } else {
-      console.warn(`[NotebookWorkspace] window.api.onClassicBrowserState is not available.`);
-    }
-  }, [activeStore]);
-
-  // Handler for notebook intent submission
-  const handleNotebookIntentSubmit = useCallback(async () => {
-    if (!notebookIntentText.trim() || !notebookId) return;
-    const currentIntent = notebookIntentText;
-    setNotebookIntentText('');
-    setIsNotebookIntentProcessing(true);
-
-    console.log(`[NotebookWorkspace] Submitting intent: "${currentIntent}" for notebook: ${notebookId}`);
-    try {
-      if (window.api?.setIntent) {
-        await window.api.setIntent({
-          intentText: currentIntent,
-          context: 'notebook',
-          notebookId: notebookId,
-        });
-      } else {
-        console.warn("[NotebookWorkspace] window.api.setIntent is not available.");
-      }
-    } catch (error) {
-      console.error("[NotebookWorkspace] Failed to set intent:", error);
-    } finally {
-      setIsNotebookIntentProcessing(false);
-    }
-  }, [notebookIntentText, notebookId]);
-
-  // Effect for handling intent results
-  useEffect(() => {
-    if (!window.api?.onIntentResult) {
-      console.warn("[NotebookWorkspace] window.api.onIntentResult is not available.");
-      return;
-    }
-
-    const unsubscribe = window.api.onIntentResult((result: IntentResultPayload) => {
-      console.log(`[NotebookWorkspace] Received intent result:`, result);
-      
-      if (result.type === 'open_notebook') {
-        // Handle switching to a different notebook
-        if (result.notebookId !== notebookId) {
-          console.log(`[NotebookWorkspace] Switching to notebook: ${result.notebookId} (${result.title})`);
-          router.push(`/notebook/${result.notebookId}`);
-        } else {
-          console.log(`[NotebookWorkspace] Already in notebook: ${result.notebookId}`);
-        }
-      } else if (result.type === 'open_in_classic_browser') {
-        if (result.notebookId === notebookId) {
-          console.log(`[NotebookWorkspace] Received open_in_classic_browser for URL: ${result.url}`);
-          if (result.message) {
-            console.log(`[NotebookWorkspace] Message from intent: ${result.message}`);
-          }
-
-          // Minimize any existing classic-browser windows
-          const currentWindows = activeStore.getState().windows;
-          currentWindows.forEach(window => {
-            if (window.type === 'classic-browser' && !window.isMinimized) {
-              activeStore.getState().minimizeWindow(window.id);
-            }
-          });
-
-          const classicBrowserPayload: ClassicBrowserPayload = {
-            initialUrl: result.url,
-            tabs: [], // Start with empty tabs - backend will create the initial tab
-            activeTabId: '',
-            freezeState: { type: 'ACTIVE' } // Start in active state
-          };
-          
-          // Calculate bounds with proper padding
-          // Assuming viewport dimensions (we'll use window.innerWidth/Height)
-          // Left padding: 18px, Top padding: 18px, Right padding: 18px (before sidebar), Bottom padding: 60px
-          const viewportWidth = window.innerWidth;
-          const viewportHeight = window.innerHeight;
-          const sidebarWidth = 48; // Default sidebar width when collapsed (sidebar is on the right)
-          
-          activeStore.getState().addWindow({
-            type: 'classic-browser',
-            payload: classicBrowserPayload,
-            preferredMeta: { 
-              x: 18, 
-              y: 18,
-              width: viewportWidth - sidebarWidth - 18 - 18, 
-              height: viewportHeight - 18 - 60,
-              title: "Browser"
-            }
-          });
-        } else {
-          console.warn(`[NotebookWorkspace] Received open_in_classic_browser for a different notebook: ${result.notebookId}`);
-        }
-      }
-      // Handle other result types if needed
-    });
-
-    return () => {
-      if (unsubscribe) {
-        unsubscribe();
-      }
-    };
-  }, [notebookId, activeStore, windows.length, router]);
-
-  // MOVED UP: Define useCallback before any conditional returns.
-  const handleAddWindow = useCallback(() => {
-    // Minimize any existing classic-browser windows
-    const currentWindows = activeStore.getState().windows;
-    currentWindows.forEach(window => {
-      if (window.type === 'classic-browser' && !window.isMinimized) {
-        activeStore.getState().minimizeWindow(window.id);
-      }
-    });
-
-    const newWindowType: WindowContentType = 'classic-browser';
-    const newWindowPayload: ClassicBrowserPayload = {
-      initialUrl: 'https://www.are.na',
-      tabs: [], // Start with empty tabs - backend will create the initial tab
-      activeTabId: '',
-      freezeState: { type: 'ACTIVE' } // Start in active state
-    };
-    
-    // Calculate bounds with proper padding
-    const viewportWidth = window.innerWidth;
-    const viewportHeight = window.innerHeight;
-    const sidebarWidth = 48; // Default sidebar width when collapsed (sidebar is on the right)
-    
-    activeStore.getState().addWindow({
-      type: newWindowType,
-      payload: newWindowPayload,
-      preferredMeta: { 
-        x: 18, 
-        y: 18,
-        width: viewportWidth - sidebarWidth - 18 - 18, 
-        height: viewportHeight - 18 - 60
-      }
-    });
-  }, [activeStore]);
-
-  const handleAddChatWindow = useCallback(() => {
-    const currentWindows = activeStore.getState().windows;
-    const newWindowType: WindowContentType = 'chat';
-    // For a new chat, we'd typically get a sessionId from the backend/service
-    // For now, let's generate a client-side placeholder UUID.
-    // In a real scenario, this might involve an IPC call to a ChatService to create a session.
-    const newSessionId = crypto.randomUUID(); 
-    const newWindowPayload: WindowPayload = {
-      sessionId: newSessionId,
-    };
-    const x = (currentWindows.length % 5) * 210 + 100; // Offset slightly from browser
-    const y = Math.floor(currentWindows.length / 5) * 210 + 100; // Offset slightly
-    
-    activeStore.getState().addWindow({
-      type: newWindowType,
-      payload: newWindowPayload,
-      preferredMeta: { 
-        title: "New Chat", // Title should be within preferredMeta
-        x, 
-        y, 
-        width: 400, 
-        height: 600 
-      }
-    });
-  }, [activeStore]);
-
-  const handleGoHome = useCallback(() => {
-    router.push('/');
-  }, [router]);
-
-  // Guard: Ensure store is hydrated.
-  if (!isHydrated) {
-    console.log(`[NotebookWorkspace] Not hydrated yet for notebook ${notebookId}`);
-    return (
-      <div className="h-screen bg-step-1" />
-    );
-  }
-  
-  console.log(`[NotebookWorkspace] Rendering notebook ${notebookId} with ${windows.length} windows:`, {
-    notebookId,
-    windowCount: windows.length,
-    windows: windows.map(w => ({
-      id: w.id,
-      type: w.type,
-      title: w.title,
-      payload: w.payload
-    })),
-    timestamp: new Date().toISOString()
-  });
-
-  return (
-    <SidebarProvider defaultOpen={false}>
-      <NotebookContent 
-        windows={windows}
-        activeStore={activeStore}
-        notebookId={notebookId}
-        notebookTitle={notebookTitle}
-        setNotebookTitle={setNotebookTitle}
-        onAddChat={handleAddChatWindow}
-        onAddBrowser={handleAddWindow}
-        onGoHome={handleGoHome}
-        notebookIntentText={notebookIntentText}
-        setNotebookIntentText={setNotebookIntentText}
-        handleNotebookIntentSubmit={handleNotebookIntentSubmit}
-        isNotebookIntentProcessing={isNotebookIntentProcessing}
-        isReady={isReady}
-        isIntentLineVisible={isIntentLineVisible}
-        setIsIntentLineVisible={setIsIntentLineVisible}
-      />
-    </SidebarProvider>
-  );
+export default async function NotebookPage({ params }: NotebookPageProps) {
+  const { notebookId } = await params
+  return <NotebookView notebookId={notebookId} />
 }
 
-// Parent Component (Page): Handles loading notebookId and then renders the workspace child
-export default function NotebookWorkspacePageLoader() {
-  const params = useParams();
-  const notebookIdFromParams = params.notebookId;
-  const [notebookId, setNotebookId] = useState<string | null>(null);
-
-  useEffect(() => {
-    let id: string | null = null;
-    if (typeof notebookIdFromParams === 'string' && notebookIdFromParams) {
-      id = notebookIdFromParams;
-    } else if (Array.isArray(notebookIdFromParams) && notebookIdFromParams.length > 0 && notebookIdFromParams[0]) {
-      id = notebookIdFromParams[0];
-    }
-    if (id) {
-      console.log(`[NotebookWorkspacePageLoader] Resolved notebookId: ${id}`);
-      setNotebookId(id);
-    } else {
-      console.warn('[NotebookWorkspacePageLoader] Could not resolve notebookId from params:', notebookIdFromParams);
-      setNotebookId(null);
-    }
-  }, [notebookIdFromParams]);
-
-  if (!notebookId) {
-    return (
-      <div className="flex items-center justify-center h-screen">
-        <p className="text-xl">Resolving notebook...</p>
-      </div>
-    );
-  }
-
-  // Render the child component once notebookId is ready
-  // The child will handle its own store creation and hydration state.
-  return <NotebookWorkspace notebookId={notebookId} />;
-}
+export async function generateStaticParams() {
+  // Generate a placeholder param so the route can be pre-rendered
+  // In a real app, this would be actual notebook IDs
+  return [
+    { notebookId: 'placeholder' }
+  ]
+}
\ No newline at end of file
diff --git a/src/app/notebook/_tests/notebook-page-integration.test.tsx b/src/app/notebook/_tests/notebook-page-integration.test.tsx
index 966b04b9..d4a5fa10 100644
--- a/src/app/notebook/_tests/notebook-page-integration.test.tsx
+++ b/src/app/notebook/_tests/notebook-page-integration.test.tsx
@@ -2,7 +2,7 @@ import React from 'react';
 import { render, screen, waitFor, fireEvent } from '@testing-library/react';
 import { vi, describe, it, expect, beforeEach, Mock } from 'vitest';
 import { useParams, useRouter } from 'next/navigation';
-import NotebookWorkspacePageLoader from '../[notebookId]/page';
+import NotebookView from '@/components/NotebookView';
 import '@testing-library/jest-dom/vitest';
 
 // Mock only what's absolutely necessary - Next.js routing
@@ -19,6 +19,139 @@ vi.mock('next/font/local', () => ({
   }),
 }));
 
+// Mock framer-motion
+vi.mock('framer-motion', () => ({
+  motion: {
+    div: ({ children, initial, animate, transition, ...props }: any) => {
+      return <div {...props}>{children}</div>;
+    },
+  },
+  AnimatePresence: ({ children }: any) => <>{children}</>,
+}));
+
+// Mock the useHashRouter hook
+vi.mock('@/hooks/useHashRouter', () => ({
+  useHashRouter: () => ({
+    push: vi.fn(),
+    replace: vi.fn(),
+    back: vi.fn(),
+    pathname: '/notebook/test-notebook-id',
+  }),
+}));
+
+// Mock sidebar components
+vi.mock('@/components/ui/sidebar', () => ({
+  SidebarProvider: ({ children }: any) => <div data-testid="sidebar-provider">{children}</div>,
+  SidebarInset: ({ children }: any) => <div data-testid="sidebar-inset">{children}</div>,
+  useSidebar: () => ({ state: 'collapsed' }),
+}));
+
+// Mock UI components
+vi.mock('@/components/ui/corner-masks', () => ({
+  CornerMasks: () => <div data-testid="corner-masks" />,
+}));
+
+vi.mock('@/components/ui/intent-line', () => ({
+  IntentLine: React.forwardRef(({ value, onChange, onKeyDown, placeholder }: any, ref: any) => (
+    <input
+      ref={ref}
+      data-testid="intent-line"
+      value={value}
+      onChange={onChange}
+      onKeyDown={onKeyDown}
+      placeholder={placeholder}
+    />
+  )),
+}));
+
+vi.mock('@/components/HumanComputerIcon', () => ({
+  HumanComputerIcon: ({ onClick, isActive }: any) => (
+    <button data-testid="human-computer-icon" onClick={onClick}>
+      {isActive ? 'Active' : 'Inactive'}
+    </button>
+  ),
+}));
+
+vi.mock('@/components/ui/notebook-info-pill', () => ({
+  NotebookInfoPill: ({ title, onTitleChange }: any) => {
+    const [isEditing, setIsEditing] = React.useState(false);
+    const [editValue, setEditValue] = React.useState(title);
+    
+    const handleDoubleClick = () => {
+      setIsEditing(true);
+    };
+    
+    const handleKeyDown = (e: any) => {
+      if (e.key === 'Enter') {
+        onTitleChange(editValue);
+        setIsEditing(false);
+      }
+    };
+    
+    return (
+      <div data-testid="notebook-info-pill" onDoubleClick={handleDoubleClick}>
+        {isEditing ? (
+          <input
+            value={editValue}
+            onChange={(e) => setEditValue(e.target.value)}
+            onKeyDown={handleKeyDown}
+          />
+        ) : (
+          <span>{title}</span>
+        )}
+      </div>
+    );
+  },
+}));
+
+vi.mock('@/components/AppSidebar', () => ({
+  AppSidebar: () => <div data-testid="app-sidebar" />,
+}));
+
+vi.mock('@/components/ui/WindowFrame', () => ({
+  WindowFrame: ({ children }: any) => <div data-testid="window-frame">{children}</div>,
+}));
+
+// Mock the store factory
+vi.mock('@/store/windowStoreFactory', () => {
+  const createMockStore = () => {
+    let state = {
+      windows: [],
+      _hasHydrated: true,
+    };
+    
+    const listeners = new Set<() => void>();
+    
+    const getState = () => state;
+    const setState = (newState: any) => {
+      state = { ...state, ...newState };
+      listeners.forEach(listener => listener());
+    };
+    const subscribe = (listener: () => void) => {
+      listeners.add(listener);
+      return () => listeners.delete(listener);
+    };
+    
+    return {
+      getState,
+      setState,
+      subscribe,
+    };
+  };
+  
+  const stores = new Map();
+  
+  return {
+    createNotebookWindowStore: (notebookId: string) => {
+      if (!stores.has(notebookId)) {
+        stores.set(notebookId, createMockStore());
+      }
+      return stores.get(notebookId);
+    },
+    notebookStores: stores,
+  };
+});
+
 describe('NotebookWorkspace', () => {
   const mockRouter = {
     push: vi.fn(),
@@ -45,7 +178,7 @@ describe('NotebookWorkspace', () => {
     window.api.getNotebookById = vi.fn().mockResolvedValue(notebook);
     
     // Act
-    render(<NotebookWorkspacePageLoader />);
+    render(<NotebookView notebookId="test-notebook-id" />);
     
     // Assert - user can see their notebook
     expect(await screen.findByText('My Research Notes')).toBeInTheDocument();
@@ -59,7 +192,7 @@ describe('NotebookWorkspace', () => {
     });
     
     // Act
-    render(<NotebookWorkspacePageLoader />);
+    render(<NotebookView notebookId="test-notebook-id" />);
     
     // Assert - notebook is fetched
     await waitFor(() => {
@@ -80,7 +213,7 @@ describe('NotebookWorkspace', () => {
     });
     
     // Act
-    render(<NotebookWorkspacePageLoader />);
+    render(<NotebookView notebookId="test-notebook-id" />);
     
     // Wait for notebook to load
     const titleElement = await screen.findByText('Original Title');
@@ -108,7 +241,7 @@ describe('NotebookWorkspace', () => {
     const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
     
     // Act
-    render(<NotebookWorkspacePageLoader />);
+    render(<NotebookView notebookId="test-notebook-id" />);
     
     // Assert - error is logged
     await waitFor(() => {
@@ -126,7 +259,7 @@ describe('NotebookWorkspace', () => {
     const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
     
     // Act
-    render(<NotebookWorkspacePageLoader />);
+    render(<NotebookView notebookId="test-notebook-id" />);
     
     // Edit title
     const titleElement = await screen.findByText('My Notebook');
@@ -154,7 +287,7 @@ describe('NotebookWorkspace', () => {
     });
     
     // Act
-    render(<NotebookWorkspacePageLoader />);
+    render(<NotebookView notebookId="test-notebook-id" />);
     
     // Edit title
     const titleElement = await screen.findByText('Old Title');
diff --git a/src/app/page.tsx b/src/app/page.tsx
index b3ecd45f..b4d5a492 100644
--- a/src/app/page.tsx
+++ b/src/app/page.tsx
@@ -1,1031 +1,16 @@
 "use client";
 
-import { useEffect, useRef, useState, useCallback } from "react";
-import { Button } from "@/components/ui/button";
-import {
-  DropdownMenu,
-  DropdownMenuTrigger,
-  DropdownMenuContent,
-  DropdownMenuItem,
-} from "@/components/ui/dropdown-menu";
-import {
-  Dialog,
-  DialogContent,
-  DialogDescription,
-  DialogFooter,
-  DialogHeader,
-  DialogTitle,
-} from "@/components/ui/dialog";
-import { Input } from "@/components/ui/input";
-import { BookmarkUploadDialog } from "@/components/BookmarkUploadDialog";
-import { PdfUploadDialog } from "@/components/PdfUploadDialog";
-import { useRouter } from "next/navigation";
-import { IntentLine } from "@/components/ui/intent-line";
-import { IntentResultPayload, ContextState, DisplaySlice, SuggestedAction, RecentNotebook, WeatherData } from "../../shared/types";
-import { WebLayer } from '@/components/apps/web-layer/WebLayer';
-import { MessageList } from "@/components/ui/message-list";
-import { motion, AnimatePresence } from "framer-motion";
-import { SliceContext } from "@/components/ui/slice-context";
-import { RecentNotebooksList } from "@/components/layout/RecentNotebooksList";
-import { CornerMasks } from "@/components/ui/corner-masks";
+import { useHashRouter } from '@/hooks/useHashRouter'
+import HomeView from '@/components/HomeView'
+import NotebookView from '@/components/NotebookView'
 
-// Define the shape of a message for the chat log (compatible with MessageList)
-interface DisplayMessage {
-  id: string;
-  role: 'user' | 'assistant';
-  content: string;
-  createdAt?: Date;
-}
+export default function HomePage() {
+  const { pathname, params } = useHashRouter()
 
-/**
- * Root page, now primarily displaying the chat interface.
- * Includes a menu for Settings and Upload Data.
- */
-export default function WelcomePage() {
-  const [intentText, setIntentText] = useState('');
-  const [userName, setUserName] = useState<string>('friend');
-  const [fullGreeting, setFullGreeting] = useState<string>('');
-  const [greetingPart, setGreetingPart] = useState<string>('');
-  const [weatherPart, setWeatherPart] = useState<string>('');
-  const [weatherData, setWeatherData] = useState<WeatherData | null>(null);
-  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
-  const [isPdfUploadDialogOpen, setIsPdfUploadDialogOpen] = useState(false);
-  const router = useRouter();
+  // Route to appropriate view based on hash
+  if (pathname.startsWith('/notebook/') && params.notebookId) {
+    return <NotebookView notebookId={params.notebookId} />
+  }
 
-  const [webLayerInitialUrl, setWebLayerInitialUrl] = useState<string | null>(null);
-  const [isWebLayerVisible, setIsWebLayerVisible] = useState<boolean>(false);
-
-  const [chatMessages, setChatMessages] = useState<DisplayMessage[]>([]);
-  const [isThinking, setIsThinking] = useState<boolean>(false);
-  const [isNavigatingToNotebook, setIsNavigatingToNotebook] = useState<boolean>(false);
-  const messagesContainerRef = useRef<HTMLDivElement>(null);
-  const intentLineRef = useRef<HTMLInputElement>(null);
-  const [streamingMessage, setStreamingMessage] = useState<string>('');
-  const [activeStreamId, setActiveStreamId] = useState<string | null>(null);
-  const intentTimingRef = useRef<{startTime: number, correlationId: string} | null>(null);
-  const [hasLoaded, setHasLoaded] = useState(false);
-  const [isSubmitting, setIsSubmitting] = useState(false);
-  const [submittedText, setSubmittedText] = useState('');
-  const [placeholderText, setPlaceholderText] = useState("What would you like to find, organize, or do?");
-  const [showPlaceholder, setShowPlaceholder] = useState(true);
-  const [hasSubmittedOnce, setHasSubmittedOnce] = useState(false);
-  const [submissionCount, setSubmissionCount] = useState(0);
-  const [shouldScrollToLatest, setShouldScrollToLatest] = useState(false);
-  const [contextSlices, setContextSlices] = useState<ContextState<DisplaySlice[]>>({ status: 'idle', data: null });
-  const thinkingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
-  const [isComposeDialogOpen, setIsComposeDialogOpen] = useState(false);
-  const [composeTitle, setComposeTitle] = useState('');
-  const [isComposing, setIsComposing] = useState(false);
-  const [suggestedActions, setSuggestedActions] = useState<SuggestedAction[]>([]);
-  const [recentNotebooks, setRecentNotebooks] = useState<RecentNotebook[]>([]);
-  
-  // Refs for alignment
-  const greetingRef = useRef<HTMLParagraphElement>(null);
-  const [greetingTopOffset, setGreetingTopOffset] = useState<number>(0);
-
-
-  // Trigger fade-in animation on mount
-  useEffect(() => {
-    setHasLoaded(true);
-    
-    // Cleanup function to clear any pending timeouts
-    return () => {
-      if (thinkingTimeoutRef.current) {
-        clearTimeout(thinkingTimeoutRef.current);
-      }
-    };
-  }, []);
-
-  useEffect(() => {
-    const fetchData = async () => {
-      try {
-        // Fetch profile
-        if (window.api?.getProfile) {
-          const profile = await window.api.getProfile();
-          if (profile && profile.name) {
-            setUserName(profile.name);
-          }
-        } else {
-          console.warn("[WelcomePage] window.api.getProfile is not available.");
-        }
-        
-        // Fetch weather
-        if (window.api?.getWeather) {
-          const weather = await window.api.getWeather();
-          setWeatherData(weather);
-        } else {
-          console.warn("[WelcomePage] window.api.getWeather is not available.");
-        }
-      } catch (error) {
-        console.error("Failed to fetch data:", error);
-      }
-    };
-    fetchData();
-  }, []);
-
-  useEffect(() => {
-    const hour = new Date().getHours();
-    let timeOfDay = "day";
-    if (hour < 12) {
-      timeOfDay = "morning";
-    } else if (hour < 18) {
-      timeOfDay = "afternoon";
-    } else {
-      timeOfDay = "evening";
-    }
-    const dynamicGreeting = `Good ${timeOfDay}, ${userName}`;
-    
-    // Use real weather data if available, otherwise use default
-    let weather = "It's 68° and foggy in San Francisco.";
-    if (weatherData) {
-      weather = `It's ${weatherData.temperature}° and ${weatherData.description} in San Francisco.`;
-    }
-    
-    setGreetingPart(dynamicGreeting);
-    setWeatherPart(weather);
-    setFullGreeting("What would you like to find, learn, or do?");
-  }, [userName, weatherData]);
-
-  useEffect(() => {
-    if (messagesContainerRef.current && !shouldScrollToLatest) {
-      const container = messagesContainerRef.current;
-      
-      // Only auto-scroll for AI responses or when near bottom
-      const lastMessage = chatMessages[chatMessages.length - 1];
-      const isAIResponse = lastMessage && lastMessage.role === 'assistant';
-      
-      if (isAIResponse) {
-        // For AI responses, always scroll to show them
-        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
-        if (isNearBottom) {
-          setTimeout(() => {
-            container.scrollTop = container.scrollHeight;
-          }, 0);
-        }
-      }
-    }
-  }, [chatMessages, shouldScrollToLatest]);
-
-  // Effect for smooth scrolling to latest message when needed
-  useEffect(() => {
-    if (shouldScrollToLatest && messagesContainerRef.current) {
-      const container = messagesContainerRef.current;
-      const messages = container.querySelectorAll('[data-message-id]');
-      
-      if (messages.length > 0) {
-        const latestMessage = messages[messages.length - 1] as HTMLElement;
-        
-        // For subsequent messages (after the first exchange), scroll to show the latest message near the top
-        if (submissionCount > 1) {
-          // With the spacer, we want to position the message near the top of the visible area
-          const containerRect = container.getBoundingClientRect();
-          const messageRect = latestMessage.getBoundingClientRect();
-          const currentRelativeTop = messageRect.top - containerRect.top;
-          
-          // Calculate where we want the message to be (40px from top of container)
-          const targetRelativeTop = 40;
-          const scrollDistance = currentRelativeTop - targetRelativeTop;
-          
-          // Smooth scroll animation
-          const startScrollTop = container.scrollTop;
-          const targetScrollTop = startScrollTop + scrollDistance;
-          const distance = targetScrollTop - startScrollTop;
-          const duration = 700;
-          const startTime = performance.now();
-          
-          const animateScroll = (currentTime: number) => {
-            const elapsed = currentTime - startTime;
-            const progress = Math.min(elapsed / duration, 1);
-            
-            // Easing function (easeInOutCubic)
-            const easeProgress = progress < 0.5
-              ? 4 * progress * progress * progress
-              : 1 - Math.pow(-2 * progress + 2, 3) / 2;
-            
-            container.scrollTop = startScrollTop + (distance * easeProgress);
-            
-            if (progress < 1) {
-              requestAnimationFrame(animateScroll);
-            } else {
-              setShouldScrollToLatest(false);
-            }
-          };
-          
-          requestAnimationFrame(animateScroll);
-        } else {
-          // For the first message, just ensure it's visible
-          latestMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
-          setShouldScrollToLatest(false);
-        }
-      }
-    }
-  }, [shouldScrollToLatest, submissionCount]);
-
-  const handleIntentSubmit = useCallback(async () => {
-    // Handle empty Enter key press - create daily notebook
-    if (!intentText.trim()) {
-      try {
-        const notebook = await window.api.getOrCreateDailyNotebook();
-        router.push(`/notebook/${notebook.id}`);
-        return;
-      } catch (error) {
-        console.error("Failed to create daily notebook:", error);
-        setChatMessages(prev => [
-          ...prev,
-          { id: `error-daily-${Date.now()}`, role: 'assistant', content: "Sorry, I couldn't create today's notebook.", createdAt: new Date() }
-        ]);
-        return;
-      }
-    }
-    
-    const currentIntent = intentText;
-    const intentStartTime = performance.now();
-    const intentCorrelationId = `intent-${Date.now()}`;
-    
-    console.log(`[Performance] ${intentCorrelationId} - Frontend:intent_submitted at 0.00ms`);
-    
-    // Store timing info for response measurement
-    intentTimingRef.current = { startTime: intentStartTime, correlationId: intentCorrelationId };
-    
-    setSubmittedText(intentText);
-    setIsSubmitting(true);
-    
-    // Clear suggested actions from previous query
-    setSuggestedActions([]);
-    
-    // Don't clear the input immediately - let it fade out
-    // setIntentText('');
-    
-    // Mark that we've submitted at least once
-    setHasSubmittedOnce(true);
-    setSubmissionCount(prev => prev + 1);
-    
-    // Hide placeholder immediately
-    setShowPlaceholder(false);
-    
-    // Clear the input and reset submitting state after fade animation
-    setTimeout(() => {
-      setIntentText('');
-      setIsSubmitting(false); // Make input visible again after fade
-    }, 300);
-    
-    // Start thinking after a delay
-    thinkingTimeoutRef.current = setTimeout(() => {
-      console.log("[WelcomePage] Setting isThinking to true after 200ms delay");
-      setIsThinking(true);
-    }, 200);
-    
-    // Set context slices to loading state
-    setContextSlices({ status: 'loading', data: null });
-    
-    // After 3 seconds delay, show "What's next?" placeholder with fade
-    setTimeout(() => {
-      setPlaceholderText("What's next?");
-      // Start showing placeholder with opacity transition
-      setTimeout(() => {
-        setShowPlaceholder(true);
-      }, 50); // Small delay to ensure placeholder text updates first
-    }, 3000); // 3 second delay before fade-in starts
-
-    setChatMessages(prevMessages => {
-      const userMessage: DisplayMessage = {
-        id: `user-${Date.now()}`,
-        role: 'user',
-        content: currentIntent,
-        createdAt: new Date(),
-      };
-      
-      // Trigger scroll after messages update
-      setTimeout(() => setShouldScrollToLatest(true), 50);
-      
-      if (prevMessages.length === 0 && fullGreeting) {
-        return [
-          { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
-          userMessage
-        ];
-      }
-      // Simplified: if greeting isn't the first message and fullGreeting exists, prepend it.
-      // This path is unlikely if the first case handles it, but acts as a safeguard.
-      if (fullGreeting && (!prevMessages.length || prevMessages[0].id !== 'greeting-message')) {
-        return [
-          { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
-          ...prevMessages.filter(m => m.id !== 'greeting-message'), // Remove any other potential greeting messages
-          userMessage
-        ];
-      }
-      return [...prevMessages, userMessage];
-    });
-
-    console.log(`[WelcomePage] Submitting intent: "${currentIntent}"`);
-    try {
-      if (window.api?.setIntent) {
-        await window.api.setIntent({ intentText: currentIntent, context: 'welcome' });
-        // Refocus the intent line after submission
-        setTimeout(() => {
-          intentLineRef.current?.focus();
-        }, 0);
-      } else {
-        console.warn("[WelcomePage] window.api.setIntent is not available.");
-        setIsThinking(false);
-        setChatMessages(prev => prev.filter(m => m.id !== `user-${Date.now()}` && m.id !== 'greeting-message'));
-      }
-    } catch (error) {
-      console.error("Failed to set intent:", error);
-      setIsThinking(false);
-      // Don't reset isSubmitting here - let the timeout handle it
-      setChatMessages(prev => [
-        ...prev,
-        { id: `error-submit-${Date.now()}`, role: 'assistant', content: "Error submitting your request.", createdAt: new Date() }
-      ]);
-    }
-  }, [intentText, fullGreeting, router]);
-
-  useEffect(() => {
-    if (!window.api?.onIntentResult) {
-      console.warn("[WelcomePage] window.api.onIntentResult is not available. Intent results will not be handled.");
-      return;
-    }
-
-    const handleResult = (result: IntentResultPayload) => {
-      console.log("[WelcomePage] Received intent result:", result);
-      
-      // Track intent response timing
-      if (intentTimingRef.current) {
-        const elapsed = performance.now() - intentTimingRef.current.startTime;
-        console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:intent_result_received at ${elapsed.toFixed(2)}ms`, {
-          resultType: result.type,
-          hasSlices: !!(result.type === 'chat_reply' && result.slices?.length)
-        });
-        intentTimingRef.current = null; // Clear timing info
-      }
-      
-      // Clear the thinking timeout if it hasn't fired yet
-      if (thinkingTimeoutRef.current) {
-        console.log("[WelcomePage] Clearing thinking timeout since we got a result");
-        clearTimeout(thinkingTimeoutRef.current);
-        thinkingTimeoutRef.current = null;
-      }
-      
-      console.log("[WelcomePage] Setting isThinking to false in onIntentResult handler, result type:", result.type);
-      setIsThinking(false);
-      // No need to reset anything here anymore
-      
-      // Reset placeholder for next interaction (unless navigating away)
-      if (result.type !== 'open_notebook') {
-        // Keep "What's next?" if we've already submitted once
-        if (!hasSubmittedOnce) {
-          setPlaceholderText("What would you like to find, organize, or do?");
-        }
-        setShowPlaceholder(true);
-      }
-      
-      // Handle slices if this is a chat_reply with slices
-      if (result.type === 'chat_reply' && result.slices) {
-        setContextSlices({ status: 'loaded', data: result.slices });
-      } else if (result.type === 'chat_reply') {
-        // No slices returned, but still mark as loaded
-        setContextSlices({ status: 'loaded', data: [] });
-      } else if (result.type === 'error') {
-        // Error case - reset slices to idle
-        setContextSlices({ status: 'idle', data: null });
-      }
-
-      if (result.type === 'open_notebook' && result.notebookId) {
-        // Reset context slices since we're navigating away
-        setContextSlices({ status: 'idle', data: null });
-        
-        // Set navigating state to trigger animation to bottom
-        setIsNavigatingToNotebook(true);
-        // Show acknowledgment message if provided
-        if (result.message) {
-          setChatMessages(prevMessages => [...prevMessages, {
-            id: `ack-${Date.now()}`,
-            role: 'assistant',
-            content: result.message || '',
-            createdAt: new Date(),
-          }]);
-        }
-        // Small delay to show intent line animation before navigation
-        setTimeout(() => {
-          router.push(`/notebook/${result.notebookId}`);
-        }, 300); // Just enough time to see the intent line start moving
-      } else if (result.type === 'chat_reply') {
-        setChatMessages(prevMessages => {
-          const assistantMessage: DisplayMessage = {
-            id: `assistant-${Date.now()}`,
-            role: 'assistant',
-            content: result.message || '',
-            createdAt: new Date(),
-          };
-          if (prevMessages.length === 0 && fullGreeting) {
-            return [
-              { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
-              assistantMessage
-            ];
-          }
-          if (fullGreeting && (!prevMessages.length || prevMessages[0].id !== 'greeting-message')) {
-            return [
-                { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
-                ...prevMessages.filter(m => m.id !== 'greeting-message'),
-                assistantMessage
-            ];
-          }
-          return [...prevMessages, assistantMessage];
-        });
-      } else if (result.type === 'error') {
-        setChatMessages(prevMessages => [...prevMessages, {
-          id: `error-${Date.now()}`,
-          role: 'assistant',
-          content: `Sorry, an error occurred: ${result.message || 'Unknown error'}`,
-          createdAt: new Date(),
-        }]);
-      } else if (result.type === 'open_url' && result.url) {
-        // Reset context slices to show recent notebooks instead
-        setContextSlices({ status: 'idle', data: null });
-        
-        // Show acknowledgment message if provided
-        if (result.message) {
-          setChatMessages(prevMessages => [...prevMessages, {
-            id: `ack-${Date.now()}`,
-            role: 'assistant',
-            content: result.message || '',
-            createdAt: new Date(),
-          }]);
-        }
-        // Small delay to ensure message is visible before action
-        setTimeout(() => {
-          console.log("[WelcomePage] Opening WebLayer from intent result");
-          setWebLayerInitialUrl(result.url);
-          setIsWebLayerVisible(true);
-        }, 100);
-      }
-    };
-
-    const unsubscribe = window.api.onIntentResult(handleResult);
-    return () => {
-      unsubscribe();
-    };
-  }, [router, fullGreeting, hasSubmittedOnce]);
-
-  // Add streaming handlers
-  useEffect(() => {
-    if (!window.api) {
-      console.warn("[WelcomePage] window.api is not available. Streaming will not work.");
-      return;
-    }
-
-    const unsubscribers: (() => void)[] = [];
-
-    // Handle stream start
-    if (window.api.onIntentStreamStart) {
-      const unsubStart = window.api.onIntentStreamStart((data: { streamId: string }) => {
-        console.log("[WelcomePage] Stream started:", data.streamId);
-        setActiveStreamId(data.streamId);
-        setStreamingMessage('');
-        
-        // Track streaming start timing
-        if (intentTimingRef.current) {
-          const elapsed = performance.now() - intentTimingRef.current.startTime;
-          console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:stream_start at ${elapsed.toFixed(2)}ms`);
-        }
-      });
-      unsubscribers.push(unsubStart);
-    }
-
-    // Handle stream chunks
-    if (window.api.onIntentStreamChunk) {
-      const unsubChunk = window.api.onIntentStreamChunk((data: { streamId: string; chunk: string }) => {
-        if (data.streamId === activeStreamId) {
-          setStreamingMessage(prev => prev + data.chunk);
-        }
-      });
-      unsubscribers.push(unsubChunk);
-    }
-
-    // Handle stream end
-    if (window.api.onIntentStreamEnd) {
-      const unsubEnd = window.api.onIntentStreamEnd((data: { streamId: string; messageId?: string }) => {
-        console.log("[WelcomePage] Stream ended:", data.streamId);
-        
-        if (data.streamId === activeStreamId) {
-          // Track streaming end timing
-          if (intentTimingRef.current) {
-            const elapsed = performance.now() - intentTimingRef.current.startTime;
-            console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:stream_end at ${elapsed.toFixed(2)}ms`);
-            intentTimingRef.current = null;
-          }
-          
-          // Add the complete message to chat
-          const finalMessage = streamingMessage;
-          if (finalMessage) {
-            setChatMessages(prevMessages => {
-              const assistantMessage: DisplayMessage = {
-                id: data.messageId || `assistant-stream-${Date.now()}`,
-                role: 'assistant',
-                content: finalMessage,
-                createdAt: new Date(),
-              };
-              return [...prevMessages, assistantMessage];
-            });
-          }
-          
-          // Clean up streaming state
-          setActiveStreamId(null);
-          setStreamingMessage('');
-          console.log("[WelcomePage] Setting isThinking to false in stream end handler");
-          setIsThinking(false);
-          setShowPlaceholder(true);
-          
-          // Mark slices as loaded if we got them via ON_INTENT_RESULT
-          if (contextSlices.status === 'loading') {
-            setContextSlices(prev => ({ ...prev, status: 'loaded' }));
-          }
-        }
-      });
-      unsubscribers.push(unsubEnd);
-    }
-
-    // Handle stream error
-    if (window.api.onIntentStreamError) {
-      const unsubError = window.api.onIntentStreamError((data: { streamId?: string; error: string }) => {
-        console.error("[WelcomePage] Stream error:", data);
-        
-        if (!data.streamId || data.streamId === activeStreamId) {
-          // Track error timing
-          if (intentTimingRef.current) {
-            const elapsed = performance.now() - intentTimingRef.current.startTime;
-            console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:stream_error at ${elapsed.toFixed(2)}ms`);
-            intentTimingRef.current = null;
-          }
-          
-          // Show error message
-          setChatMessages(prevMessages => [...prevMessages, {
-            id: `error-stream-${Date.now()}`,
-            role: 'assistant',
-            content: `Sorry, an error occurred: ${data.error}`,
-            createdAt: new Date(),
-          }]);
-          
-          // Clean up streaming state
-          setActiveStreamId(null);
-          setStreamingMessage('');
-          console.log("[WelcomePage] Setting isThinking to false in stream error handler");
-          setIsThinking(false);
-          setShowPlaceholder(true);
-          setContextSlices({ status: 'idle', data: null });
-        }
-      });
-      unsubscribers.push(unsubError);
-    }
-
-    return () => {
-      unsubscribers.forEach(unsub => unsub());
-    };
-  }, [activeStreamId, streamingMessage, contextSlices.status]);
-
-  // Add listener for suggested actions
-  useEffect(() => {
-    if (!window.api?.onSuggestedActions) {
-      console.warn("[WelcomePage] window.api.onSuggestedActions is not available.");
-      return;
-    }
-
-    const unsubscribe = window.api.onSuggestedActions((actions: SuggestedAction[]) => {
-      console.log("[WelcomePage] Received suggested actions:", actions);
-      setSuggestedActions(actions);
-    });
-
-    return () => {
-      unsubscribe();
-    };
-  }, []);
-
-  const handleCloseWebLayer = useCallback(() => {
-    console.log("[WelcomePage] handleCloseWebLayer called");
-    setIsWebLayerVisible(false);
-    setWebLayerInitialUrl(null);
-
-    // Restore focus to intent line after a short delay
-    setTimeout(() => {
-      if (intentLineRef.current) {
-        console.log("[WelcomePage] Restoring focus to IntentLine");
-        intentLineRef.current.focus();
-      }
-    }, 100);
-  }, []); // Empty dependency array ensures the function instance is stable
-
-  const handleLinkClick = useCallback((href: string) => {
-    console.log("[WelcomePage] handleLinkClick called with href:", href);
-    setWebLayerInitialUrl(href);
-    setIsWebLayerVisible(true);
-  }, []);
-
-  const handleComposeNotebook = useCallback(async () => {
-    if (!composeTitle.trim()) {
-      return;
-    }
-
-    setIsComposing(true);
-    
-    try {
-      // Get source object IDs if we have context slices
-      const sourceObjectIds = contextSlices.data
-        ?.filter(slice => slice.sourceObjectId)
-        .map(slice => slice.sourceObjectId!) || [];
-      
-      // Call the composition API (works with or without sources)
-      const result = await window.api.composeNotebook({
-        title: composeTitle.trim(),
-        sourceObjectIds
-      });
-      
-      // Close the dialog
-      setIsComposeDialogOpen(false);
-      
-      // Navigate to the new notebook
-      router.push(`/notebook/${result.notebookId}`);
-      
-    } catch (error) {
-      console.error("[WelcomePage] Error composing notebook:", error);
-      // Could show an error toast here
-    } finally {
-      setIsComposing(false);
-    }
-  }, [composeTitle, contextSlices.data, router]);
-
-  // Fetch recently viewed notebooks on mount
-  useEffect(() => {
-    const fetchRecentNotebooks = async () => {
-      try {
-        if (window.api?.getRecentlyViewedNotebooks) {
-          const notebooks = await window.api.getRecentlyViewedNotebooks();
-          console.log('[WelcomePage] Fetched recent notebooks:', notebooks);
-          setRecentNotebooks(notebooks);
-        } else {
-          console.warn("[WelcomePage] window.api.getRecentlyViewedNotebooks is not available.");
-        }
-      } catch (error) {
-        console.error("Failed to fetch recent notebooks:", error);
-      }
-    };
-    fetchRecentNotebooks();
-  }, []);
-
-  const handleSelectRecentNotebook = useCallback((notebookId: string) => {
-    router.push(`/notebook/${notebookId}`);
-  }, [router]);
-
-  // Effect to measure greeting position
-  useEffect(() => {
-    const measureGreeting = () => {
-      if (greetingRef.current && chatMessages.length === 0 && !isThinking) {
-        const rect = greetingRef.current.getBoundingClientRect();
-        setGreetingTopOffset(rect.top);
-      }
-    };
-
-    // Measure on mount and when relevant states change
-    measureGreeting();
-
-    // Also measure on window resize
-    window.addEventListener('resize', measureGreeting);
-    return () => window.removeEventListener('resize', measureGreeting);
-  }, [greetingPart, chatMessages.length, isThinking, isSubmitting]);
-
-  const handleSuggestedAction = useCallback(async (action: SuggestedAction) => {
-    console.log("[WelcomePage] Handling suggested action:", action);
-    
-    switch (action.type) {
-      case 'open_notebook':
-        if (action.payload.notebookId) {
-          router.push(`/notebook/${action.payload.notebookId}`);
-        }
-        break;
-        
-      case 'compose_notebook':
-        setComposeTitle(action.payload.proposedTitle || '');
-        setIsComposeDialogOpen(true);
-        break;
-        
-      case 'search_web':
-        if (action.payload.searchQuery) {
-          const searchUrl = action.payload.searchEngine === 'google' 
-            ? `https://www.google.com/search?q=${encodeURIComponent(action.payload.searchQuery)}`
-            : `https://www.perplexity.ai/search?q=${encodeURIComponent(action.payload.searchQuery)}`;
-          
-          setWebLayerInitialUrl(searchUrl);
-          setIsWebLayerVisible(true);
-        }
-        break;
-    }
-  }, [router]);
-
-  return (
-    <motion.div 
-      className="h-screen flex flex-col bg-step-2 text-step-12 relative overflow-hidden"
-      initial={{ opacity: 0 }}
-      animate={{ opacity: hasLoaded ? 1 : 0 }}
-      transition={{ duration: 0.6, ease: "easeOut" }}
-    >
-      <CornerMasks />
-      {/* Menu Button - Fixed Position at Bottom Right */} 
-      <div className="fixed right-4 bottom-4 z-50">
-        <DropdownMenu>
-          <DropdownMenuTrigger asChild>
-            <Button variant="ghost" size="icon" className="text-xl" aria-label="Main menu">
-              ⋮
-            </Button>
-          </DropdownMenuTrigger>
-          <DropdownMenuContent sideOffset={8} align="end">
-            <DropdownMenuItem asChild><a href="/settings">Settings</a></DropdownMenuItem>
-            <DropdownMenuItem onSelect={() => setIsUploadDialogOpen(true)}>Upload Bookmarks</DropdownMenuItem>
-            <DropdownMenuItem onSelect={() => setIsPdfUploadDialogOpen(true)}>Upload PDFs</DropdownMenuItem>
-          </DropdownMenuContent>
-        </DropdownMenu>
-      </div>
-
-      {/* Main Grid Container */}
-      <div className="flex-grow grid grid-cols-[2fr_1fr] h-full">
-        
-        {/* Left Column (chat / input / actions) */}
-        <div className="relative flex flex-col h-full overflow-hidden">
-          
-          {/* Row 1: scrollable chat log / initial greeting */}
-          <motion.div 
-            className="overflow-y-auto px-16"
-            ref={messagesContainerRef}
-            initial={false}
-            animate={{ 
-              flex: isNavigatingToNotebook 
-                ? "1 1 95%" // Almost full height when navigating to notebook
-                : chatMessages.length > 0 || isThinking
-                  ? "1 1 70%" // Keep expanded when there are messages or thinking
-                  : "1 1 auto", // Only collapse when no messages and not thinking
-            }}
-            transition={{ 
-              duration: isSubmitting && !hasSubmittedOnce ? 1.0 : 0.7, 
-              ease: "easeInOut",
-              delay: isSubmitting && !hasSubmittedOnce ? 0.2 : 0 // Only delay on first submission
-            }}
-          >
-            {/* Static Greeting Display (only if chat is empty and not thinking) */} 
-            {chatMessages.length === 0 && !isThinking && greetingPart && (
-              <motion.div 
-                className="flex flex-col justify-center h-full"
-                initial={false}
-                animate={{
-                  y: isSubmitting ? "-40%" : 0,
-                }}
-                transition={{
-                  duration: 0.5,
-                  ease: "easeOut"
-                }}
-              >
-                <p ref={greetingRef} className="text-lg">
-                  <span className="text-step-11.5" style={{ paddingLeft: '0.5rem' }}>{greetingPart}.</span>{' '}
-                  <span className="text-step-9">{weatherPart}</span>
-                </p>
-              </motion.div>
-            )}
-            {/* MessageList (only if chat has started or AI is thinking) */} 
-            {(chatMessages.length > 0 || isThinking || streamingMessage) && (
-              <>
-                <MessageList
-                  messages={
-                    streamingMessage 
-                      ? [...chatMessages, {
-                          id: 'streaming-message',
-                          role: 'assistant' as const,
-                          content: streamingMessage,
-                          createdAt: new Date()
-                        }]
-                      : chatMessages
-                  }
-                  isTyping={isThinking && !streamingMessage} 
-                  showTimeStamp={false}
-                  messageOptions={(message) => {
-                    // Special animation for the greeting message
-                    if (message.id === 'greeting-message') {
-                      return { 
-                        animation: "fade-slow",
-                        className: "mt-20" // Adds 80px top margin
-                      };
-                    }
-                    return { animation: "fade" };
-                  }}
-                  onLinkClick={handleLinkClick}
-                />
-                {/* Add some bottom padding to ensure scrollability */}
-                <div style={{ minHeight: '100px' }} />
-              </>
-            )}
-          </motion.div>
-
-          {/* Row 2: Intent line (fixed height) */}
-          <motion.div 
-            className="px-16 pb-4 flex-shrink-0 h-[52px] relative z-10"
-            initial={false}
-            animate={{
-              position: isNavigatingToNotebook ? "fixed" : "relative",
-              bottom: isNavigatingToNotebook ? "16px" : "auto",
-              left: isNavigatingToNotebook ? "64px" : "auto",
-              width: isNavigatingToNotebook ? "calc(66.666667% - 128px)" : "auto",
-              paddingLeft: isNavigatingToNotebook ? "0" : "64px",
-              paddingRight: isNavigatingToNotebook ? "0" : "64px",
-            }}
-            transition={{ 
-              duration: 0.7,
-              ease: "easeInOut"
-            }}
-          >
-            <div className="relative h-9">
-              <IntentLine
-                ref={intentLineRef}
-                type="text"
-                value={intentText}
-                onChange={(e) => setIntentText(e.target.value)}
-                transcribeAudio={typeof window !== 'undefined' ? window.api.audio.transcribe : undefined}
-                placeholder={placeholderText}
-                className={`w-full text-lg md:text-lg text-step-12 bg-transparent border-0 border-b-[1px] border-step-9 hover:border-step-11.5 focus:ring-0 focus:border-step-10 placeholder:text-step-12 ${showPlaceholder ? 'placeholder:opacity-100' : 'placeholder:opacity-0'} placeholder:transition-opacity placeholder:duration-[1500ms]`}
-                onKeyDown={(e) => {
-                  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleIntentSubmit(); }
-                }}
-                onFocus={() => {
-                  console.log("[WelcomePage] IntentLine gained focus");
-                }}
-                onBlur={() => {
-                  console.log("[WelcomePage] IntentLine lost focus");
-                }}
-                disabled={isThinking}
-                autoFocus
-                style={{
-                  opacity: isSubmitting ? 0 : 1,
-                  transition: 'opacity 0.3s ease-out'
-                }}
-              />
-              {/* Show fading submitted text overlay - positioned exactly over the input */}
-              {isSubmitting && submittedText && (
-                <motion.div
-                  className="absolute left-0 right-0 top-0 h-9 flex items-center px-3 text-lg md:text-lg text-step-12 pointer-events-none"
-                  initial={{ opacity: 1 }}
-                  animate={{ opacity: 0 }}
-                  transition={{ duration: 0.3, ease: "easeOut" }}
-                >
-                  {submittedText}
-                </motion.div>
-              )}
-            </div>
-          </motion.div>
-
-          {/* Row 3: actions / library panel (28% height) */}
-          <motion.div 
-            className="px-16 pt-0 pb-4 overflow-y-auto"
-            initial={false}
-            animate={{ 
-              flex: isNavigatingToNotebook 
-                ? "0 0 5%" // Minimal height when navigating to notebook
-                : chatMessages.length > 0 || isThinking
-                  ? "0 0 30%" // Keep minimal when there are messages or thinking
-                  : "0 0 50%" // Only expand when no messages and not thinking
-            }}
-            transition={{ 
-              duration: isSubmitting && !hasSubmittedOnce ? 1.0 : 0.7, 
-              ease: "easeInOut",
-              delay: isSubmitting && !hasSubmittedOnce ? 0.2 : 0
-            }}
-          >
-            {/* Instruction text in top left */}
-            {chatMessages.length === 0 && !isThinking && (
-              <p className="text-step-9 text-base mb-4 pl-3">
-                Set your intent above, or press return to just start computing
-              </p>
-            )}
-            
-            {/* Show suggested actions only when loaded */}
-            {suggestedActions.length > 0 && (
-              <motion.div 
-                className="flex flex-col gap-1.5 items-start"
-                initial={{ opacity: 0 }}
-                animate={{ opacity: 1 }}
-                transition={{ duration: 0.3 }}
-              >
-                {suggestedActions.map((action, index) => (
-                  <motion.button
-                    key={index}
-                    onClick={() => handleSuggestedAction(action)}
-                    className="text-left bg-step-2 hover:bg-step-1 text-step-11-5 hover:text-birkin px-3 py-1.5 rounded-md transition-colors duration-200"
-                    initial={{ opacity: 0 }}
-                    animate={{ 
-                      opacity: [0, 0.8, 1]
-                    }}
-                    transition={{ 
-                      duration: 1.8,
-                      delay: index * 0.1,
-                      times: [0, 0.5, 1],
-                      ease: "easeOut"
-                    }}
-                  >
-                    {action.displayText}
-                  </motion.button>
-                ))}
-              </motion.div>
-            )}
-          </motion.div>
-        </div>
-
-        {/* Right Column (context slices or recent notebooks) */}
-        <div className="bg-step-2 pr-2 pt-2 pb-2 h-full">
-          <div className="bg-step-3 h-full p-4 overflow-y-auto flex justify-center">
-            <div className="w-full max-w-2xl">
-            {/* Show recent notebooks when no slices are available */}
-            <AnimatePresence mode="wait">
-              {(contextSlices.status === 'idle' || (contextSlices.status === 'loaded' && !contextSlices.data?.length)) ? (
-                <motion.div
-                  key="notebooks"
-                  initial={{ opacity: 0 }}
-                  animate={{ opacity: 1 }}
-                  exit={{ opacity: 0 }}
-                  transition={{ duration: 0.7 }}
-                >
-                  <RecentNotebooksList 
-                    notebooks={recentNotebooks}
-                    onSelectNotebook={handleSelectRecentNotebook}
-                    topOffset={greetingTopOffset}
-                  />
-                </motion.div>
-              ) : (
-                <motion.div
-                  key="slices"
-                  initial={{ opacity: 0 }}
-                  animate={{ opacity: 1 }}
-                  exit={{ opacity: 0 }}
-                  transition={{ duration: 0.7 }}
-                >
-                  <SliceContext 
-                    contextState={contextSlices} 
-                    isNotebookCover={true} 
-                    onWebLayerOpen={handleLinkClick}
-                  />
-                </motion.div>
-              )}
-            </AnimatePresence>
-            </div>
-          </div>
-        </div>
-      </div>
-
-      <BookmarkUploadDialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen} />
-      <PdfUploadDialog open={isPdfUploadDialogOpen} onOpenChange={setIsPdfUploadDialogOpen} />
-      {isWebLayerVisible && webLayerInitialUrl && (
-        <WebLayer
-          initialUrl={webLayerInitialUrl}
-          isVisible={isWebLayerVisible}
-          onClose={handleCloseWebLayer}
-        />
-      )}
-      
-      {/* Compose Notebook Dialog */}
-      <Dialog open={isComposeDialogOpen} onOpenChange={setIsComposeDialogOpen}>
-        <DialogContent>
-          <DialogHeader>
-            <DialogTitle>Create New Notebook</DialogTitle>
-            <DialogDescription>
-              Give your notebook a title. The selected search results will be added as resources.
-            </DialogDescription>
-          </DialogHeader>
-          
-          <div className="py-4">
-            <Input
-              value={composeTitle}
-              onChange={(e) => setComposeTitle(e.target.value)}
-              placeholder="Enter notebook title..."
-              onKeyDown={(e) => {
-                if (e.key === 'Enter' && !isComposing && composeTitle.trim()) {
-                  handleComposeNotebook();
-                }
-              }}
-              disabled={isComposing}
-              autoFocus
-            />
-          </div>
-          
-          <DialogFooter>
-            <Button
-              variant="ghost"
-              onClick={() => setIsComposeDialogOpen(false)}
-              disabled={isComposing}
-            >
-              Cancel
-            </Button>
-            <Button
-              onClick={handleComposeNotebook}
-              disabled={!composeTitle.trim() || isComposing}
-            >
-              {isComposing ? "Creating..." : "Create Notebook"}
-            </Button>
-          </DialogFooter>
-        </DialogContent>
-      </Dialog>
-    </motion.div>
-  );
-}
+  return <HomeView />
+}
\ No newline at end of file
diff --git a/src/components/HomeView.tsx b/src/components/HomeView.tsx
new file mode 100644
index 00000000..e73b6be3
--- /dev/null
+++ b/src/components/HomeView.tsx
@@ -0,0 +1,1030 @@
+"use client";
+
+import { useEffect, useRef, useState, useCallback } from "react";
+import { Button } from "@/components/ui/button";
+import {
+  DropdownMenu,
+  DropdownMenuTrigger,
+  DropdownMenuContent,
+  DropdownMenuItem,
+} from "@/components/ui/dropdown-menu";
+import {
+  Dialog,
+  DialogContent,
+  DialogDescription,
+  DialogFooter,
+  DialogHeader,
+  DialogTitle,
+} from "@/components/ui/dialog";
+import { Input } from "@/components/ui/input";
+import { BookmarkUploadDialog } from "@/components/BookmarkUploadDialog";
+import { PdfUploadDialog } from "@/components/PdfUploadDialog";
+import { useHashRouter } from "@/hooks/useHashRouter";
+import { IntentLine } from "@/components/ui/intent-line";
+import { IntentResultPayload, ContextState, DisplaySlice, SuggestedAction, RecentNotebook, WeatherData } from "../../shared/types";
+import { WebLayer } from '@/components/apps/web-layer/WebLayer';
+import { MessageList } from "@/components/ui/message-list";
+import { motion, AnimatePresence } from "framer-motion";
+import { SliceContext } from "@/components/ui/slice-context";
+import { RecentNotebooksList } from "@/components/layout/RecentNotebooksList";
+import { CornerMasks } from "@/components/ui/corner-masks";
+
+// Define the shape of a message for the chat log (compatible with MessageList)
+interface DisplayMessage {
+  id: string;
+  role: 'user' | 'assistant';
+  content: string;
+  createdAt?: Date;
+}
+
+/**
+ * Home view component - displays the welcome page with chat interface
+ */
+export default function HomeView() {
+  const [intentText, setIntentText] = useState('');
+  const [userName, setUserName] = useState<string>('friend');
+  const [fullGreeting, setFullGreeting] = useState<string>('');
+  const [greetingPart, setGreetingPart] = useState<string>('');
+  const [weatherPart, setWeatherPart] = useState<string>('');
+  const [weatherData, setWeatherData] = useState<WeatherData | null>(null);
+  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
+  const [isPdfUploadDialogOpen, setIsPdfUploadDialogOpen] = useState(false);
+  const router = useHashRouter();
+
+  const [webLayerInitialUrl, setWebLayerInitialUrl] = useState<string | null>(null);
+  const [isWebLayerVisible, setIsWebLayerVisible] = useState<boolean>(false);
+
+  const [chatMessages, setChatMessages] = useState<DisplayMessage[]>([]);
+  const [isThinking, setIsThinking] = useState<boolean>(false);
+  const [isNavigatingToNotebook, setIsNavigatingToNotebook] = useState<boolean>(false);
+  const messagesContainerRef = useRef<HTMLDivElement>(null);
+  const intentLineRef = useRef<HTMLInputElement>(null);
+  const [streamingMessage, setStreamingMessage] = useState<string>('');
+  const [activeStreamId, setActiveStreamId] = useState<string | null>(null);
+  const intentTimingRef = useRef<{startTime: number, correlationId: string} | null>(null);
+  const [hasLoaded, setHasLoaded] = useState(false);
+  const [isSubmitting, setIsSubmitting] = useState(false);
+  const [submittedText, setSubmittedText] = useState('');
+  const [placeholderText, setPlaceholderText] = useState("What would you like to find, organize, or do?");
+  const [showPlaceholder, setShowPlaceholder] = useState(true);
+  const [hasSubmittedOnce, setHasSubmittedOnce] = useState(false);
+  const [submissionCount, setSubmissionCount] = useState(0);
+  const [shouldScrollToLatest, setShouldScrollToLatest] = useState(false);
+  const [contextSlices, setContextSlices] = useState<ContextState<DisplaySlice[]>>({ status: 'idle', data: null });
+  const thinkingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
+  const [isComposeDialogOpen, setIsComposeDialogOpen] = useState(false);
+  const [composeTitle, setComposeTitle] = useState('');
+  const [isComposing, setIsComposing] = useState(false);
+  const [suggestedActions, setSuggestedActions] = useState<SuggestedAction[]>([]);
+  const [recentNotebooks, setRecentNotebooks] = useState<RecentNotebook[]>([]);
+  
+  // Refs for alignment
+  const greetingRef = useRef<HTMLParagraphElement>(null);
+  const [greetingTopOffset, setGreetingTopOffset] = useState<number>(0);
+
+
+  // Trigger fade-in animation on mount
+  useEffect(() => {
+    setHasLoaded(true);
+    
+    // Cleanup function to clear any pending timeouts
+    return () => {
+      if (thinkingTimeoutRef.current) {
+        clearTimeout(thinkingTimeoutRef.current);
+      }
+    };
+  }, []);
+
+  useEffect(() => {
+    const fetchData = async () => {
+      try {
+        // Fetch profile
+        if (window.api?.getProfile) {
+          const profile = await window.api.getProfile();
+          if (profile && profile.name && profile.name !== 'default user') {
+            setUserName(profile.name);
+          }
+        } else {
+          console.warn("[HomeView] window.api.getProfile is not available.");
+        }
+        
+        // Fetch weather
+        if (window.api?.getWeather) {
+          const weather = await window.api.getWeather();
+          setWeatherData(weather);
+        } else {
+          console.warn("[HomeView] window.api.getWeather is not available.");
+        }
+      } catch (error) {
+        console.error("Failed to fetch data:", error);
+      }
+    };
+    fetchData();
+  }, []);
+
+  useEffect(() => {
+    const hour = new Date().getHours();
+    let timeOfDay = "day";
+    if (hour < 12) {
+      timeOfDay = "morning";
+    } else if (hour < 18) {
+      timeOfDay = "afternoon";
+    } else {
+      timeOfDay = "evening";
+    }
+    const dynamicGreeting = `Good ${timeOfDay}, ${userName}`;
+    
+    // Use real weather data if available, otherwise use default
+    let weather = "It's 68° and foggy in San Francisco.";
+    if (weatherData) {
+      weather = `It's ${weatherData.temperature}° and ${weatherData.description} in San Francisco.`;
+    }
+    
+    setGreetingPart(dynamicGreeting);
+    setWeatherPart(weather);
+    setFullGreeting("What would you like to find, learn, or do?");
+  }, [userName, weatherData]);
+
+  useEffect(() => {
+    if (messagesContainerRef.current && !shouldScrollToLatest) {
+      const container = messagesContainerRef.current;
+      
+      // Only auto-scroll for AI responses or when near bottom
+      const lastMessage = chatMessages[chatMessages.length - 1];
+      const isAIResponse = lastMessage && lastMessage.role === 'assistant';
+      
+      if (isAIResponse) {
+        // For AI responses, always scroll to show them
+        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
+        if (isNearBottom) {
+          setTimeout(() => {
+            container.scrollTop = container.scrollHeight;
+          }, 0);
+        }
+      }
+    }
+  }, [chatMessages, shouldScrollToLatest]);
+
+  // Effect for smooth scrolling to latest message when needed
+  useEffect(() => {
+    if (shouldScrollToLatest && messagesContainerRef.current) {
+      const container = messagesContainerRef.current;
+      const messages = container.querySelectorAll('[data-message-id]');
+      
+      if (messages.length > 0) {
+        const latestMessage = messages[messages.length - 1] as HTMLElement;
+        
+        // For subsequent messages (after the first exchange), scroll to show the latest message near the top
+        if (submissionCount > 1) {
+          // With the spacer, we want to position the message near the top of the visible area
+          const containerRect = container.getBoundingClientRect();
+          const messageRect = latestMessage.getBoundingClientRect();
+          const currentRelativeTop = messageRect.top - containerRect.top;
+          
+          // Calculate where we want the message to be (40px from top of container)
+          const targetRelativeTop = 40;
+          const scrollDistance = currentRelativeTop - targetRelativeTop;
+          
+          // Smooth scroll animation
+          const startScrollTop = container.scrollTop;
+          const targetScrollTop = startScrollTop + scrollDistance;
+          const distance = targetScrollTop - startScrollTop;
+          const duration = 700;
+          const startTime = performance.now();
+          
+          const animateScroll = (currentTime: number) => {
+            const elapsed = currentTime - startTime;
+            const progress = Math.min(elapsed / duration, 1);
+            
+            // Easing function (easeInOutCubic)
+            const easeProgress = progress < 0.5
+              ? 4 * progress * progress * progress
+              : 1 - Math.pow(-2 * progress + 2, 3) / 2;
+            
+            container.scrollTop = startScrollTop + (distance * easeProgress);
+            
+            if (progress < 1) {
+              requestAnimationFrame(animateScroll);
+            } else {
+              setShouldScrollToLatest(false);
+            }
+          };
+          
+          requestAnimationFrame(animateScroll);
+        } else {
+          // For the first message, just ensure it's visible
+          latestMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
+          setShouldScrollToLatest(false);
+        }
+      }
+    }
+  }, [shouldScrollToLatest, submissionCount]);
+
+  const handleIntentSubmit = useCallback(async () => {
+    // Handle empty Enter key press - create daily notebook
+    if (!intentText.trim()) {
+      try {
+        const notebook = await window.api.getOrCreateDailyNotebook();
+        router.push(`/notebook/${notebook.id}`);
+        return;
+      } catch (error) {
+        console.error("Failed to create daily notebook:", error);
+        setChatMessages(prev => [
+          ...prev,
+          { id: `error-daily-${Date.now()}`, role: 'assistant', content: "Sorry, I couldn't create today's notebook.", createdAt: new Date() }
+        ]);
+        return;
+      }
+    }
+    
+    const currentIntent = intentText;
+    const intentStartTime = performance.now();
+    const intentCorrelationId = `intent-${Date.now()}`;
+    
+    console.log(`[Performance] ${intentCorrelationId} - Frontend:intent_submitted at 0.00ms`);
+    
+    // Store timing info for response measurement
+    intentTimingRef.current = { startTime: intentStartTime, correlationId: intentCorrelationId };
+    
+    setSubmittedText(intentText);
+    setIsSubmitting(true);
+    
+    // Clear suggested actions from previous query
+    setSuggestedActions([]);
+    
+    // Don't clear the input immediately - let it fade out
+    // setIntentText('');
+    
+    // Mark that we've submitted at least once
+    setHasSubmittedOnce(true);
+    setSubmissionCount(prev => prev + 1);
+    
+    // Hide placeholder immediately
+    setShowPlaceholder(false);
+    
+    // Clear the input and reset submitting state after fade animation
+    setTimeout(() => {
+      setIntentText('');
+      setIsSubmitting(false); // Make input visible again after fade
+    }, 300);
+    
+    // Start thinking after a delay
+    thinkingTimeoutRef.current = setTimeout(() => {
+      console.log("[HomeView] Setting isThinking to true after 200ms delay");
+      setIsThinking(true);
+    }, 200);
+    
+    // Set context slices to loading state
+    setContextSlices({ status: 'loading', data: null });
+    
+    // After 3 seconds delay, show "What's next?" placeholder with fade
+    setTimeout(() => {
+      setPlaceholderText("What's next?");
+      // Start showing placeholder with opacity transition
+      setTimeout(() => {
+        setShowPlaceholder(true);
+      }, 50); // Small delay to ensure placeholder text updates first
+    }, 3000); // 3 second delay before fade-in starts
+
+    setChatMessages(prevMessages => {
+      const userMessage: DisplayMessage = {
+        id: `user-${Date.now()}`,
+        role: 'user',
+        content: currentIntent,
+        createdAt: new Date(),
+      };
+      
+      // Trigger scroll after messages update
+      setTimeout(() => setShouldScrollToLatest(true), 50);
+      
+      if (prevMessages.length === 0 && fullGreeting) {
+        return [
+          { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
+          userMessage
+        ];
+      }
+      // Simplified: if greeting isn't the first message and fullGreeting exists, prepend it.
+      // This path is unlikely if the first case handles it, but acts as a safeguard.
+      if (fullGreeting && (!prevMessages.length || prevMessages[0].id !== 'greeting-message')) {
+        return [
+          { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
+          ...prevMessages.filter(m => m.id !== 'greeting-message'), // Remove any other potential greeting messages
+          userMessage
+        ];
+      }
+      return [...prevMessages, userMessage];
+    });
+
+    console.log(`[HomeView] Submitting intent: "${currentIntent}"`);
+    try {
+      if (window.api?.setIntent) {
+        await window.api.setIntent({ intentText: currentIntent, context: 'welcome' });
+        // Refocus the intent line after submission
+        setTimeout(() => {
+          intentLineRef.current?.focus();
+        }, 0);
+      } else {
+        console.warn("[HomeView] window.api.setIntent is not available.");
+        setIsThinking(false);
+        setChatMessages(prev => prev.filter(m => m.id !== `user-${Date.now()}` && m.id !== 'greeting-message'));
+      }
+    } catch (error) {
+      console.error("Failed to set intent:", error);
+      setIsThinking(false);
+      // Don't reset isSubmitting here - let the timeout handle it
+      setChatMessages(prev => [
+        ...prev,
+        { id: `error-submit-${Date.now()}`, role: 'assistant', content: "Error submitting your request.", createdAt: new Date() }
+      ]);
+    }
+  }, [intentText, fullGreeting, router]);
+
+  useEffect(() => {
+    if (!window.api?.onIntentResult) {
+      console.warn("[HomeView] window.api.onIntentResult is not available. Intent results will not be handled.");
+      return;
+    }
+
+    const handleResult = (result: IntentResultPayload) => {
+      console.log("[HomeView] Received intent result:", result);
+      
+      // Track intent response timing
+      if (intentTimingRef.current) {
+        const elapsed = performance.now() - intentTimingRef.current.startTime;
+        console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:intent_result_received at ${elapsed.toFixed(2)}ms`, {
+          resultType: result.type,
+          hasSlices: !!(result.type === 'chat_reply' && result.slices?.length)
+        });
+        intentTimingRef.current = null; // Clear timing info
+      }
+      
+      // Clear the thinking timeout if it hasn't fired yet
+      if (thinkingTimeoutRef.current) {
+        console.log("[HomeView] Clearing thinking timeout since we got a result");
+        clearTimeout(thinkingTimeoutRef.current);
+        thinkingTimeoutRef.current = null;
+      }
+      
+      console.log("[HomeView] Setting isThinking to false in onIntentResult handler, result type:", result.type);
+      setIsThinking(false);
+      // No need to reset anything here anymore
+      
+      // Reset placeholder for next interaction (unless navigating away)
+      if (result.type !== 'open_notebook') {
+        // Keep "What's next?" if we've already submitted once
+        if (!hasSubmittedOnce) {
+          setPlaceholderText("What would you like to find, organize, or do?");
+        }
+        setShowPlaceholder(true);
+      }
+      
+      // Handle slices if this is a chat_reply with slices
+      if (result.type === 'chat_reply' && result.slices) {
+        setContextSlices({ status: 'loaded', data: result.slices });
+      } else if (result.type === 'chat_reply') {
+        // No slices returned, but still mark as loaded
+        setContextSlices({ status: 'loaded', data: [] });
+      } else if (result.type === 'error') {
+        // Error case - reset slices to idle
+        setContextSlices({ status: 'idle', data: null });
+      }
+
+      if (result.type === 'open_notebook' && result.notebookId) {
+        // Reset context slices since we're navigating away
+        setContextSlices({ status: 'idle', data: null });
+        
+        // Set navigating state to trigger animation to bottom
+        setIsNavigatingToNotebook(true);
+        // Show acknowledgment message if provided
+        if (result.message) {
+          setChatMessages(prevMessages => [...prevMessages, {
+            id: `ack-${Date.now()}`,
+            role: 'assistant',
+            content: result.message || '',
+            createdAt: new Date(),
+          }]);
+        }
+        // Small delay to show intent line animation before navigation
+        setTimeout(() => {
+          router.push(`/notebook/${result.notebookId}`);
+        }, 300); // Just enough time to see the intent line start moving
+      } else if (result.type === 'chat_reply') {
+        setChatMessages(prevMessages => {
+          const assistantMessage: DisplayMessage = {
+            id: `assistant-${Date.now()}`,
+            role: 'assistant',
+            content: result.message || '',
+            createdAt: new Date(),
+          };
+          if (prevMessages.length === 0 && fullGreeting) {
+            return [
+              { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
+              assistantMessage
+            ];
+          }
+          if (fullGreeting && (!prevMessages.length || prevMessages[0].id !== 'greeting-message')) {
+            return [
+                { id: 'greeting-message', role: 'assistant', content: fullGreeting, createdAt: new Date(Date.now() - 1000) },
+                ...prevMessages.filter(m => m.id !== 'greeting-message'),
+                assistantMessage
+            ];
+          }
+          return [...prevMessages, assistantMessage];
+        });
+      } else if (result.type === 'error') {
+        setChatMessages(prevMessages => [...prevMessages, {
+          id: `error-${Date.now()}`,
+          role: 'assistant',
+          content: `Sorry, an error occurred: ${result.message || 'Unknown error'}`,
+          createdAt: new Date(),
+        }]);
+      } else if (result.type === 'open_url' && result.url) {
+        // Reset context slices to show recent notebooks instead
+        setContextSlices({ status: 'idle', data: null });
+        
+        // Show acknowledgment message if provided
+        if (result.message) {
+          setChatMessages(prevMessages => [...prevMessages, {
+            id: `ack-${Date.now()}`,
+            role: 'assistant',
+            content: result.message || '',
+            createdAt: new Date(),
+          }]);
+        }
+        // Small delay to ensure message is visible before action
+        setTimeout(() => {
+          console.log("[HomeView] Opening WebLayer from intent result");
+          setWebLayerInitialUrl(result.url);
+          setIsWebLayerVisible(true);
+        }, 100);
+      }
+    };
+
+    const unsubscribe = window.api.onIntentResult(handleResult);
+    return () => {
+      unsubscribe();
+    };
+  }, [router, fullGreeting, hasSubmittedOnce]);
+
+  // Add streaming handlers
+  useEffect(() => {
+    if (!window.api) {
+      console.warn("[HomeView] window.api is not available. Streaming will not work.");
+      return;
+    }
+
+    const unsubscribers: (() => void)[] = [];
+
+    // Handle stream start
+    if (window.api.onIntentStreamStart) {
+      const unsubStart = window.api.onIntentStreamStart((data: { streamId: string }) => {
+        console.log("[HomeView] Stream started:", data.streamId);
+        setActiveStreamId(data.streamId);
+        setStreamingMessage('');
+        
+        // Track streaming start timing
+        if (intentTimingRef.current) {
+          const elapsed = performance.now() - intentTimingRef.current.startTime;
+          console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:stream_start at ${elapsed.toFixed(2)}ms`);
+        }
+      });
+      unsubscribers.push(unsubStart);
+    }
+
+    // Handle stream chunks
+    if (window.api.onIntentStreamChunk) {
+      const unsubChunk = window.api.onIntentStreamChunk((data: { streamId: string; chunk: string }) => {
+        if (data.streamId === activeStreamId) {
+          setStreamingMessage(prev => prev + data.chunk);
+        }
+      });
+      unsubscribers.push(unsubChunk);
+    }
+
+    // Handle stream end
+    if (window.api.onIntentStreamEnd) {
+      const unsubEnd = window.api.onIntentStreamEnd((data: { streamId: string; messageId?: string }) => {
+        console.log("[HomeView] Stream ended:", data.streamId);
+        
+        if (data.streamId === activeStreamId) {
+          // Track streaming end timing
+          if (intentTimingRef.current) {
+            const elapsed = performance.now() - intentTimingRef.current.startTime;
+            console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:stream_end at ${elapsed.toFixed(2)}ms`);
+            intentTimingRef.current = null;
+          }
+          
+          // Add the complete message to chat
+          const finalMessage = streamingMessage;
+          if (finalMessage) {
+            setChatMessages(prevMessages => {
+              const assistantMessage: DisplayMessage = {
+                id: data.messageId || `assistant-stream-${Date.now()}`,
+                role: 'assistant',
+                content: finalMessage,
+                createdAt: new Date(),
+              };
+              return [...prevMessages, assistantMessage];
+            });
+          }
+          
+          // Clean up streaming state
+          setActiveStreamId(null);
+          setStreamingMessage('');
+          console.log("[HomeView] Setting isThinking to false in stream end handler");
+          setIsThinking(false);
+          setShowPlaceholder(true);
+          
+          // Mark slices as loaded if we got them via ON_INTENT_RESULT
+          if (contextSlices.status === 'loading') {
+            setContextSlices(prev => ({ ...prev, status: 'loaded' }));
+          }
+        }
+      });
+      unsubscribers.push(unsubEnd);
+    }
+
+    // Handle stream error
+    if (window.api.onIntentStreamError) {
+      const unsubError = window.api.onIntentStreamError((data: { streamId?: string; error: string }) => {
+        console.error("[HomeView] Stream error:", data);
+        
+        if (!data.streamId || data.streamId === activeStreamId) {
+          // Track error timing
+          if (intentTimingRef.current) {
+            const elapsed = performance.now() - intentTimingRef.current.startTime;
+            console.log(`[Performance] ${intentTimingRef.current.correlationId} - Frontend:stream_error at ${elapsed.toFixed(2)}ms`);
+            intentTimingRef.current = null;
+          }
+          
+          // Show error message
+          setChatMessages(prevMessages => [...prevMessages, {
+            id: `error-stream-${Date.now()}`,
+            role: 'assistant',
+            content: `Sorry, an error occurred: ${data.error}`,
+            createdAt: new Date(),
+          }]);
+          
+          // Clean up streaming state
+          setActiveStreamId(null);
+          setStreamingMessage('');
+          console.log("[HomeView] Setting isThinking to false in stream error handler");
+          setIsThinking(false);
+          setShowPlaceholder(true);
+          setContextSlices({ status: 'idle', data: null });
+        }
+      });
+      unsubscribers.push(unsubError);
+    }
+
+    return () => {
+      unsubscribers.forEach(unsub => unsub());
+    };
+  }, [activeStreamId, streamingMessage, contextSlices.status]);
+
+  // Add listener for suggested actions
+  useEffect(() => {
+    if (!window.api?.onSuggestedActions) {
+      console.warn("[HomeView] window.api.onSuggestedActions is not available.");
+      return;
+    }
+
+    const unsubscribe = window.api.onSuggestedActions((actions: SuggestedAction[]) => {
+      console.log("[HomeView] Received suggested actions:", actions);
+      setSuggestedActions(actions);
+    });
+
+    return () => {
+      unsubscribe();
+    };
+  }, []);
+
+  const handleCloseWebLayer = useCallback(() => {
+    console.log("[HomeView] handleCloseWebLayer called");
+    setIsWebLayerVisible(false);
+    setWebLayerInitialUrl(null);
+
+    // Restore focus to intent line after a short delay
+    setTimeout(() => {
+      if (intentLineRef.current) {
+        console.log("[HomeView] Restoring focus to IntentLine");
+        intentLineRef.current.focus();
+      }
+    }, 100);
+  }, []); // Empty dependency array ensures the function instance is stable
+
+  const handleLinkClick = useCallback((href: string) => {
+    console.log("[HomeView] handleLinkClick called with href:", href);
+    setWebLayerInitialUrl(href);
+    setIsWebLayerVisible(true);
+  }, []);
+
+  const handleComposeNotebook = useCallback(async () => {
+    if (!composeTitle.trim()) {
+      return;
+    }
+
+    setIsComposing(true);
+    
+    try {
+      // Get source object IDs if we have context slices
+      const sourceObjectIds = contextSlices.data
+        ?.filter(slice => slice.sourceObjectId)
+        .map(slice => slice.sourceObjectId!) || [];
+      
+      // Call the composition API (works with or without sources)
+      const result = await window.api.composeNotebook({
+        title: composeTitle.trim(),
+        sourceObjectIds
+      });
+      
+      // Close the dialog
+      setIsComposeDialogOpen(false);
+      
+      // Navigate to the new notebook
+      router.push(`/notebook/${result.notebookId}`);
+      
+    } catch (error) {
+      console.error("[HomeView] Error composing notebook:", error);
+      // Could show an error toast here
+    } finally {
+      setIsComposing(false);
+    }
+  }, [composeTitle, contextSlices.data, router]);
+
+  // Fetch recently viewed notebooks on mount
+  useEffect(() => {
+    const fetchRecentNotebooks = async () => {
+      try {
+        if (window.api?.getRecentlyViewedNotebooks) {
+          const notebooks = await window.api.getRecentlyViewedNotebooks();
+          console.log('[HomeView] Fetched recent notebooks:', notebooks);
+          setRecentNotebooks(notebooks);
+        } else {
+          console.warn("[HomeView] window.api.getRecentlyViewedNotebooks is not available.");
+        }
+      } catch (error) {
+        console.error("Failed to fetch recent notebooks:", error);
+      }
+    };
+    fetchRecentNotebooks();
+  }, []);
+
+  const handleSelectRecentNotebook = useCallback((notebookId: string) => {
+    router.push(`/notebook/${notebookId}`);
+  }, [router]);
+
+  // Effect to measure greeting position
+  useEffect(() => {
+    const measureGreeting = () => {
+      if (greetingRef.current && chatMessages.length === 0 && !isThinking) {
+        const rect = greetingRef.current.getBoundingClientRect();
+        setGreetingTopOffset(rect.top);
+      }
+    };
+
+    // Measure on mount and when relevant states change
+    measureGreeting();
+
+    // Also measure on window resize
+    window.addEventListener('resize', measureGreeting);
+    return () => window.removeEventListener('resize', measureGreeting);
+  }, [greetingPart, chatMessages.length, isThinking, isSubmitting]);
+
+  const handleSuggestedAction = useCallback(async (action: SuggestedAction) => {
+    console.log("[HomeView] Handling suggested action:", action);
+    
+    switch (action.type) {
+      case 'open_notebook':
+        if (action.payload.notebookId) {
+          router.push(`/notebook/${action.payload.notebookId}`);
+        }
+        break;
+        
+      case 'compose_notebook':
+        setComposeTitle(action.payload.proposedTitle || '');
+        setIsComposeDialogOpen(true);
+        break;
+        
+      case 'search_web':
+        if (action.payload.searchQuery) {
+          const searchUrl = action.payload.searchEngine === 'google' 
+            ? `https://www.google.com/search?q=${encodeURIComponent(action.payload.searchQuery)}`
+            : `https://www.perplexity.ai/search?q=${encodeURIComponent(action.payload.searchQuery)}`;
+          
+          setWebLayerInitialUrl(searchUrl);
+          setIsWebLayerVisible(true);
+        }
+        break;
+    }
+  }, [router]);
+
+  return (
+    <motion.div 
+      className="h-screen flex flex-col bg-step-2 text-step-12 relative overflow-hidden"
+      initial={{ opacity: 0 }}
+      animate={{ opacity: hasLoaded ? 1 : 0 }}
+      transition={{ duration: 0.6, ease: "easeOut" }}
+    >
+      <CornerMasks />
+      {/* Menu Button - Fixed Position at Bottom Right */} 
+      <div className="fixed right-4 bottom-4 z-50">
+        <DropdownMenu>
+          <DropdownMenuTrigger asChild>
+            <Button variant="ghost" size="icon" className="text-xl" aria-label="Main menu">
+              ⋮
+            </Button>
+          </DropdownMenuTrigger>
+          <DropdownMenuContent sideOffset={8} align="end">
+            <DropdownMenuItem asChild><span>Settings</span></DropdownMenuItem>
+            <DropdownMenuItem onSelect={() => setIsUploadDialogOpen(true)}>Upload Bookmarks</DropdownMenuItem>
+            <DropdownMenuItem onSelect={() => setIsPdfUploadDialogOpen(true)}>Upload PDFs</DropdownMenuItem>
+          </DropdownMenuContent>
+        </DropdownMenu>
+      </div>
+
+      {/* Main Grid Container */}
+      <div className="flex-grow grid grid-cols-[2fr_1fr] h-full">
+        
+        {/* Left Column (chat / input / actions) */}
+        <div className="relative flex flex-col h-full overflow-hidden">
+          
+          {/* Row 1: scrollable chat log / initial greeting */}
+          <motion.div 
+            className="overflow-y-auto px-16"
+            ref={messagesContainerRef}
+            initial={false}
+            animate={{ 
+              flex: isNavigatingToNotebook 
+                ? "1 1 95%" // Almost full height when navigating to notebook
+                : chatMessages.length > 0 || isThinking
+                  ? "1 1 70%" // Keep expanded when there are messages or thinking
+                  : "1 1 auto", // Only collapse when no messages and not thinking
+            }}
+            transition={{ 
+              duration: isSubmitting && !hasSubmittedOnce ? 1.0 : 0.7, 
+              ease: "easeInOut",
+              delay: isSubmitting && !hasSubmittedOnce ? 0.2 : 0 // Only delay on first submission
+            }}
+          >
+            {/* Static Greeting Display (only if chat is empty and not thinking) */} 
+            {chatMessages.length === 0 && !isThinking && greetingPart && (
+              <motion.div 
+                className="flex flex-col justify-center h-full"
+                initial={false}
+                animate={{
+                  y: isSubmitting ? "-40%" : 0,
+                }}
+                transition={{
+                  duration: 0.5,
+                  ease: "easeOut"
+                }}
+              >
+                <p ref={greetingRef} className="text-lg">
+                  <span className="text-step-11.5" style={{ paddingLeft: '0.5rem' }}>{greetingPart}.</span>{' '}
+                  <span className="text-step-9">{weatherPart}</span>
+                </p>
+              </motion.div>
+            )}
+            {/* MessageList (only if chat has started or AI is thinking) */} 
+            {(chatMessages.length > 0 || isThinking || streamingMessage) && (
+              <>
+                <MessageList
+                  messages={
+                    streamingMessage 
+                      ? [...chatMessages, {
+                          id: 'streaming-message',
+                          role: 'assistant' as const,
+                          content: streamingMessage,
+                          createdAt: new Date()
+                        }]
+                      : chatMessages
+                  }
+                  isTyping={isThinking && !streamingMessage} 
+                  showTimeStamp={false}
+                  messageOptions={(message) => {
+                    // Special animation for the greeting message
+                    if (message.id === 'greeting-message') {
+                      return { 
+                        animation: "fade-slow",
+                        className: "mt-20" // Adds 80px top margin
+                      };
+                    }
+                    return { animation: "fade" };
+                  }}
+                  onLinkClick={handleLinkClick}
+                />
+                {/* Add some bottom padding to ensure scrollability */}
+                <div style={{ minHeight: '100px' }} />
+              </>
+            )}
+          </motion.div>
+
+          {/* Row 2: Intent line (fixed height) */}
+          <motion.div 
+            className="px-16 pb-4 flex-shrink-0 h-[52px] relative z-10"
+            initial={false}
+            animate={{
+              position: isNavigatingToNotebook ? "fixed" : "relative",
+              bottom: isNavigatingToNotebook ? "16px" : "auto",
+              left: isNavigatingToNotebook ? "64px" : "auto",
+              width: isNavigatingToNotebook ? "calc(66.666667% - 128px)" : "auto",
+              paddingLeft: isNavigatingToNotebook ? "0" : "64px",
+              paddingRight: isNavigatingToNotebook ? "0" : "64px",
+            }}
+            transition={{ 
+              duration: 0.7,
+              ease: "easeInOut"
+            }}
+          >
+            <div className="relative h-9">
+              <IntentLine
+                ref={intentLineRef}
+                type="text"
+                value={intentText}
+                onChange={(e) => setIntentText(e.target.value)}
+                transcribeAudio={typeof window !== 'undefined' ? window.api.audio.transcribe : undefined}
+                placeholder={placeholderText}
+                className={`w-full text-lg md:text-lg text-step-12 bg-transparent border-0 border-b-[1px] border-step-9 hover:border-step-11.5 focus:ring-0 focus:border-step-10 placeholder:text-step-12 ${showPlaceholder ? 'placeholder:opacity-100' : 'placeholder:opacity-0'} placeholder:transition-opacity placeholder:duration-[1500ms]`}
+                onKeyDown={(e) => {
+                  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleIntentSubmit(); }
+                }}
+                onFocus={() => {
+                  console.log("[HomeView] IntentLine gained focus");
+                }}
+                onBlur={() => {
+                  console.log("[HomeView] IntentLine lost focus");
+                }}
+                disabled={isThinking}
+                autoFocus
+                style={{
+                  opacity: isSubmitting ? 0 : 1,
+                  transition: 'opacity 0.3s ease-out'
+                }}
+              />
+              {/* Show fading submitted text overlay - positioned exactly over the input */}
+              {isSubmitting && submittedText && (
+                <motion.div
+                  className="absolute left-0 right-0 top-0 h-9 flex items-center px-3 text-lg md:text-lg text-step-12 pointer-events-none"
+                  initial={{ opacity: 1 }}
+                  animate={{ opacity: 0 }}
+                  transition={{ duration: 0.3, ease: "easeOut" }}
+                >
+                  {submittedText}
+                </motion.div>
+              )}
+            </div>
+          </motion.div>
+
+          {/* Row 3: actions / library panel (28% height) */}
+          <motion.div 
+            className="px-16 pt-0 pb-4 overflow-y-auto"
+            initial={false}
+            animate={{ 
+              flex: isNavigatingToNotebook 
+                ? "0 0 5%" // Minimal height when navigating to notebook
+                : chatMessages.length > 0 || isThinking
+                  ? "0 0 30%" // Keep minimal when there are messages or thinking
+                  : "0 0 50%" // Only expand when no messages and not thinking
+            }}
+            transition={{ 
+              duration: isSubmitting && !hasSubmittedOnce ? 1.0 : 0.7, 
+              ease: "easeInOut",
+              delay: isSubmitting && !hasSubmittedOnce ? 0.2 : 0
+            }}
+          >
+            {/* Instruction text in top left */}
+            {chatMessages.length === 0 && !isThinking && (
+              <p className="text-step-9 text-base mb-4 pl-3">
+                Set your intent above, or press return to just start computing
+              </p>
+            )}
+            
+            {/* Show suggested actions only when loaded */}
+            {suggestedActions.length > 0 && (
+              <motion.div 
+                className="flex flex-col gap-1.5 items-start"
+                initial={{ opacity: 0 }}
+                animate={{ opacity: 1 }}
+                transition={{ duration: 0.3 }}
+              >
+                {suggestedActions.map((action, index) => (
+                  <motion.button
+                    key={index}
+                    onClick={() => handleSuggestedAction(action)}
+                    className="text-left bg-step-2 hover:bg-step-1 text-step-11-5 hover:text-birkin px-3 py-1.5 rounded-md transition-colors duration-200"
+                    initial={{ opacity: 0 }}
+                    animate={{ 
+                      opacity: [0, 0.8, 1]
+                    }}
+                    transition={{ 
+                      duration: 1.8,
+                      delay: index * 0.1,
+                      times: [0, 0.5, 1],
+                      ease: "easeOut"
+                    }}
+                  >
+                    {action.displayText}
+                  </motion.button>
+                ))}
+              </motion.div>
+            )}
+          </motion.div>
+        </div>
+
+        {/* Right Column (context slices or recent notebooks) */}
+        <div className="bg-step-2 pr-2 pt-2 pb-2 h-full">
+          <div className="bg-step-3 h-full p-4 overflow-y-auto flex justify-center">
+            <div className="w-full max-w-2xl">
+            {/* Show recent notebooks when no slices are available */}
+            <AnimatePresence mode="wait">
+              {(contextSlices.status === 'idle' || (contextSlices.status === 'loaded' && !contextSlices.data?.length)) ? (
+                <motion.div
+                  key="notebooks"
+                  initial={{ opacity: 0 }}
+                  animate={{ opacity: 1 }}
+                  exit={{ opacity: 0 }}
+                  transition={{ duration: 0.7 }}
+                >
+                  <RecentNotebooksList 
+                    notebooks={recentNotebooks}
+                    onSelectNotebook={handleSelectRecentNotebook}
+                    topOffset={greetingTopOffset}
+                  />
+                </motion.div>
+              ) : (
+                <motion.div
+                  key="slices"
+                  initial={{ opacity: 0 }}
+                  animate={{ opacity: 1 }}
+                  exit={{ opacity: 0 }}
+                  transition={{ duration: 0.7 }}
+                >
+                  <SliceContext 
+                    contextState={contextSlices} 
+                    isNotebookCover={true} 
+                    onWebLayerOpen={handleLinkClick}
+                  />
+                </motion.div>
+              )}
+            </AnimatePresence>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <BookmarkUploadDialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen} />
+      <PdfUploadDialog open={isPdfUploadDialogOpen} onOpenChange={setIsPdfUploadDialogOpen} />
+      {isWebLayerVisible && webLayerInitialUrl && (
+        <WebLayer
+          initialUrl={webLayerInitialUrl}
+          isVisible={isWebLayerVisible}
+          onClose={handleCloseWebLayer}
+        />
+      )}
+      
+      {/* Compose Notebook Dialog */}
+      <Dialog open={isComposeDialogOpen} onOpenChange={setIsComposeDialogOpen}>
+        <DialogContent>
+          <DialogHeader>
+            <DialogTitle>Create New Notebook</DialogTitle>
+            <DialogDescription>
+              Give your notebook a title. The selected search results will be added as resources.
+            </DialogDescription>
+          </DialogHeader>
+          
+          <div className="py-4">
+            <Input
+              value={composeTitle}
+              onChange={(e) => setComposeTitle(e.target.value)}
+              placeholder="Enter notebook title..."
+              onKeyDown={(e) => {
+                if (e.key === 'Enter' && !isComposing && composeTitle.trim()) {
+                  handleComposeNotebook();
+                }
+              }}
+              disabled={isComposing}
+              autoFocus
+            />
+          </div>
+          
+          <DialogFooter>
+            <Button
+              variant="ghost"
+              onClick={() => setIsComposeDialogOpen(false)}
+              disabled={isComposing}
+            >
+              Cancel
+            </Button>
+            <Button
+              onClick={handleComposeNotebook}
+              disabled={!composeTitle.trim() || isComposing}
+            >
+              {isComposing ? "Creating..." : "Create Notebook"}
+            </Button>
+          </DialogFooter>
+        </DialogContent>
+      </Dialog>
+    </motion.div>
+  );
+}
\ No newline at end of file
diff --git a/src/components/NotebookView.tsx b/src/components/NotebookView.tsx
new file mode 100644
index 00000000..e8823c42
--- /dev/null
+++ b/src/components/NotebookView.tsx
@@ -0,0 +1,828 @@
+"use client";
+
+import { useEffect, useState, useCallback, useRef } from "react";
+import { useHashRouter } from "@/hooks/useHashRouter";
+import type { StoreApi } from "zustand";
+import { useStore } from "zustand";
+import { motion } from "framer-motion";
+
+import { createNotebookWindowStore, type WindowStoreState, notebookStores } from "@/store/windowStoreFactory";
+import { WindowMeta, WindowContentType, WindowPayload, IntentResultPayload, ClassicBrowserPayload, ClassicBrowserStateUpdate } from '../../shared/types';
+import { WindowFrame } from '@/components/ui/WindowFrame';
+import { AppSidebar } from '@/components/AppSidebar';
+import { SidebarProvider, SidebarInset, useSidebar } from "@/components/ui/sidebar";
+import { IntentLine } from "@/components/ui/intent-line";
+import { CornerMasks } from "@/components/ui/corner-masks";
+import { HumanComputerIcon } from "@/components/HumanComputerIcon";
+import { NotebookInfoPill } from "@/components/ui/notebook-info-pill";
+
+// Component that has access to sidebar context
+function NotebookContent({ 
+  windows, 
+  activeStore, 
+  notebookId,
+  notebookTitle,
+  setNotebookTitle,
+  onAddChat,
+  onAddBrowser,
+  onGoHome,
+  notebookIntentText,
+  setNotebookIntentText,
+  handleNotebookIntentSubmit,
+  isNotebookIntentProcessing,
+  isReady,
+  isIntentLineVisible,
+  setIsIntentLineVisible
+}: {
+  windows: WindowMeta[];
+  activeStore: StoreApi<WindowStoreState>;
+  notebookId: string;
+  notebookTitle: string;
+  setNotebookTitle: (title: string) => void;
+  onAddChat: () => void;
+  onAddBrowser: () => void;
+  onGoHome: () => void;
+  notebookIntentText: string;
+  setNotebookIntentText: (text: string) => void;
+  handleNotebookIntentSubmit: () => void;
+  isNotebookIntentProcessing: boolean;
+  isReady: boolean;
+  isIntentLineVisible: boolean;
+  setIsIntentLineVisible: (visible: boolean) => void;
+}) {
+  const { state: sidebarState } = useSidebar();
+  const [isPillHovered, setIsPillHovered] = useState(false);
+  const [isPillClicked, setIsPillClicked] = useState(false);
+  const intentLineRef = useRef<HTMLInputElement>(null);
+  
+  // Focus intent line when it becomes visible
+  useEffect(() => {
+    if (isIntentLineVisible && intentLineRef.current) {
+      // Small delay to ensure the element is rendered
+      setTimeout(() => {
+        intentLineRef.current?.focus();
+      }, 50);
+    }
+  }, [isIntentLineVisible]);
+  
+  // When clicked elsewhere, remove the clicked state
+  useEffect(() => {
+    const handleClickOutside = (e: MouseEvent) => {
+      const target = e.target as HTMLElement;
+      if (!target.closest('.notebook-info-pill-container')) {
+        setIsPillClicked(false);
+      }
+    };
+    
+    if (isPillClicked) {
+      document.addEventListener('click', handleClickOutside);
+      return () => document.removeEventListener('click', handleClickOutside);
+    }
+  }, [isPillClicked]);
+  
+  console.log(`[NotebookContent] Rendering with ${windows.length} windows:`, {
+    notebookId,
+    windowCount: windows.length,
+    sidebarState,
+    timestamp: new Date().toISOString()
+  });
+
+  const handleNotebookTitleChange = async (newTitle: string) => {
+    try {
+      if (window.api?.updateNotebook) {
+        await window.api.updateNotebook({ 
+          id: notebookId, 
+          data: { title: newTitle } 
+        });
+        // Update the local state to reflect the change immediately
+        setNotebookTitle(newTitle);
+        console.log(`[NotebookContent] Updated notebook title to: ${newTitle}`);
+      }
+    } catch (error) {
+      console.error('[NotebookContent] Failed to update notebook title:', error);
+      // Could show an error toast here
+    }
+  };
+  
+  return (
+    <>
+      <CornerMasks />
+      <motion.div 
+        className="relative w-full h-screen bg-step-1 flex"
+        initial={{ opacity: 0 }}
+        animate={{ opacity: isReady ? 1 : 0 }}
+        transition={{ duration: 0.4, ease: "easeOut" }}
+      >
+        <SidebarInset className="relative overflow-hidden">
+          {/* SidebarTrigger removed but can be re-added here if needed */}
+          
+          
+          <div className="absolute inset-0">
+            {windows.map((windowMeta) => {
+              console.log(`[NotebookContent] Rendering window:`, {
+                windowId: windowMeta.id,
+                type: windowMeta.type,
+                payload: windowMeta.payload,
+                timestamp: new Date().toISOString()
+              });
+              let content = null;
+
+              switch (windowMeta.type) {
+                case 'chat':
+                  // Content will be handled by WindowFrame directly
+                  break;
+                case 'classic-browser':
+                  // Content will be handled by WindowFrame directly
+                  break;
+                case 'note_editor':
+                  // Content will be handled by WindowFrame directly
+                  break;
+                default:
+                  content = (
+                    <div className="p-4">
+                      <p className="text-xs text-step-10">ID: {windowMeta.id}</p>
+                      <p className="text-sm">Unhandled Type: {windowMeta.type}</p>
+                      <p className="text-sm">Payload: {JSON.stringify(windowMeta.payload)}</p>
+                    </div>
+                  );
+              }
+
+              return (
+                <WindowFrame
+                  key={windowMeta.id}
+                  windowMeta={windowMeta}
+                  activeStore={activeStore}
+                  notebookId={notebookId}
+                  sidebarState={sidebarState}
+                >
+                  {content}
+                </WindowFrame>
+              );
+            })}
+          </div>
+        </SidebarInset>
+        <AppSidebar 
+          onAddChat={onAddChat}
+          onAddBrowser={onAddBrowser}
+          onGoHome={onGoHome}
+          windows={windows}
+          activeStore={activeStore}
+          notebookId={notebookId}
+        />
+      </motion.div>
+      
+      {/* Notebook info pill positioned at top left */}
+      {notebookTitle && (
+        <motion.div 
+          className="notebook-info-pill-container fixed top-4 left-4"
+          initial={{ opacity: 0 }}
+          animate={{ opacity: isReady ? 1 : 0 }}
+          transition={{ duration: 0.4, ease: "easeOut" }}
+          style={{ 
+            zIndex: isPillHovered || isPillClicked ? 10000 : 5,
+            transition: 'z-index 0.2s ease'
+          }}
+          onMouseEnter={() => setIsPillHovered(true)}
+          onMouseLeave={() => setIsPillHovered(false)}
+          onClick={() => setIsPillClicked(true)}
+        >
+          <NotebookInfoPill 
+            title={notebookTitle} 
+            onTitleChange={handleNotebookTitleChange}
+            parentZIndex={isPillHovered || isPillClicked ? 10000 : 5}
+          />
+        </motion.div>
+      )}
+      
+      {/* Fixed IntentLine at the bottom left to match homepage position */}
+      {/* Intent line is outside the motion div to remain visible during transition */}
+      {/* Homepage uses grid-cols-[2fr_1fr] with px-16 in left column, so intent line width is 2/3 - 128px */}
+      <div 
+        className="fixed bottom-4 left-4 flex items-center"
+        style={{ 
+          zIndex: isIntentLineVisible ? 10000 : 5,
+          transition: 'z-index 0.2s ease'
+        }}
+      >
+        <HumanComputerIcon 
+          onClick={() => setIsIntentLineVisible(!isIntentLineVisible)}
+          isActive={isIntentLineVisible}
+        />
+        <div 
+          className={`overflow-hidden transition-all duration-300 ease-out ${
+            isIntentLineVisible ? 'w-[calc(66.666667vw-80px)] ml-3' : 'w-0 ml-0'
+          }`}
+        >
+          <IntentLine
+            ref={intentLineRef}
+            type="text"
+            value={notebookIntentText}
+            onChange={(e) => setNotebookIntentText(e.target.value)}
+            transcribeAudio={typeof window !== 'undefined' ? window.api.audio.transcribe : undefined}
+            placeholder={`Ask or command within this notebook...`}
+            className="w-full text-lg md:text-lg text-step-12 bg-transparent border-0 border-b-[1.5px] border-step-12/30 focus:ring-0 focus:border-step-12/50 placeholder:text-step-12"
+            onKeyDown={(e) => {
+              if (e.key === 'Enter' && !e.shiftKey) {
+                e.preventDefault();
+                handleNotebookIntentSubmit();
+              }
+              if (e.key === 'Escape') {
+                setIsIntentLineVisible(false);
+              }
+            }}
+            disabled={isNotebookIntentProcessing}
+            autoFocus={isIntentLineVisible}
+          />
+        </div>
+      </div>
+    </>
+  );
+}
+
+// Child Component: Renders the actual workspace once its store is initialized
+function NotebookWorkspace({ notebookId }: { notebookId: string }) {
+  // Initialize the store synchronously and once using useState initializer
+  const [activeStore] = useState(() => {
+    console.log(`[NotebookWorkspace] Creating store for notebook ${notebookId}`);
+    return createNotebookWindowStore(notebookId);
+  });
+  const router = useHashRouter();
+
+  // Hooks are called unconditionally here, and activeStore is guaranteed to be valid.
+  const windows = useStore(activeStore, (state) => state.windows);
+  const isHydrated = useStore(activeStore, (state) => state._hasHydrated);
+  
+  console.log(`[NotebookWorkspace] Notebook ${notebookId} state:`, {
+    isHydrated,
+    windowCount: windows.length,
+    windows: windows.map(w => ({ id: w.id, type: w.type })),
+    timestamp: new Date().toISOString()
+  });
+  
+  // State for notebook intent line
+  const [notebookIntentText, setNotebookIntentText] = useState('');
+  const [isNotebookIntentProcessing, setIsNotebookIntentProcessing] = useState(false);
+  const [isIntentLineVisible, setIsIntentLineVisible] = useState(false);
+  
+  // State for transition animation with smart timing
+  const [isReady, setIsReady] = useState(false);
+  const [loadStartTime] = useState(Date.now());
+  
+  // State for notebook data
+  const [notebookTitle, setNotebookTitle] = useState<string>("");
+  
+  // Track previous window order to detect changes
+  const prevWindowOrderRef = useRef<Array<{ id: string; isFrozen: boolean; isMinimized: boolean }>>([]);
+  
+  // Fetch notebook details to trigger activity logging
+  useEffect(() => {
+    const fetchNotebook = async () => {
+      try {
+        if (window.api?.getNotebookById) {
+          console.log(`[NotebookWorkspace] Fetching notebook details for ID: ${notebookId}`);
+          const notebook = await window.api.getNotebookById(notebookId);
+          if (notebook) {
+            console.log(`[NotebookWorkspace] Successfully fetched notebook: ${notebook.title}`);
+            setNotebookTitle(notebook.title);
+          } else {
+            console.warn(`[NotebookWorkspace] Notebook not found for ID: ${notebookId}`);
+          }
+        } else {
+          console.warn("[NotebookWorkspace] window.api.getNotebookById is not available.");
+        }
+      } catch (error) {
+        console.error(`[NotebookWorkspace] Failed to fetch notebook details:`, error);
+      }
+    };
+    
+    fetchNotebook();
+  }, [notebookId]);
+
+  // Hotkey handlers
+  useEffect(() => {
+    const handleKeyDown = (e: KeyboardEvent) => {
+      // CMD+T: Open new tab in existing browser or create new browser
+      if ((e.metaKey || e.ctrlKey) && e.key === 't') {
+        e.preventDefault();
+        console.log('[Hotkey] CMD+T: Handling new tab/browser request');
+        
+        // Check for existing classic-browser windows
+        const existingBrowser = windows.find(w => w.type === 'classic-browser' && !w.isMinimized);
+        
+        if (existingBrowser) {
+          // Open a new tab in the existing browser
+          console.log('[Hotkey] CMD+T: Opening new tab in existing browser', existingBrowser.id);
+          if (window.api?.classicBrowserCreateTab) {
+            window.api.classicBrowserCreateTab(existingBrowser.id, 'https://www.are.na')
+              .then(result => {
+                if (!result.success) {
+                  console.error('[Hotkey] Failed to create new tab:', result.error);
+                }
+              })
+              .catch(err => {
+                console.error('[Hotkey] Error creating new tab:', err);
+              });
+          }
+        } else {
+          // No existing browser, create a new one
+          console.log('[Hotkey] CMD+T: No existing browser, creating new browser window');
+          
+          const newWindowPayload: ClassicBrowserPayload = {
+            initialUrl: 'https://www.are.na',
+            tabs: [], // Start with empty tabs - backend will create the initial tab
+            activeTabId: '',
+            freezeState: { type: 'ACTIVE' } // Start in active state
+          };
+          
+          // Calculate bounds
+          const viewportWidth = window.innerWidth;
+          const viewportHeight = window.innerHeight;
+          const sidebarWidth = 48;
+          
+          activeStore.getState().addWindow({
+            type: 'classic-browser',
+            payload: newWindowPayload,
+            preferredMeta: { 
+              x: 18, 
+              y: 18,
+              width: viewportWidth - sidebarWidth - 18 - 18, 
+              height: viewportHeight - 18 - 60,
+              title: "Browser"
+            }
+          });
+        }
+      }
+      
+      // CMD+/: Toggle intent line
+      if ((e.metaKey || e.ctrlKey) && e.key === '/') {
+        e.preventDefault();
+        console.log('[Hotkey] CMD+/: Toggling intent line');
+        setIsIntentLineVisible(prev => !prev);
+      }
+    };
+
+    window.addEventListener('keydown', handleKeyDown);
+    return () => window.removeEventListener('keydown', handleKeyDown);
+  }, [windows, activeStore, setIsIntentLineVisible]);
+  
+  // Synchronize window stacking order with native WebContentsViews
+  useEffect(() => {
+    // Sort windows by z-index to get the correct stacking order
+    const sortedWindows = [...windows]
+      .sort((a, b) => a.zIndex - b.zIndex)
+      .map(w => {
+        // Derive isFrozen from the state machine for classic-browser windows
+        let isFrozen = false;
+        if (w.type === 'classic-browser') {
+          const payload = w.payload as ClassicBrowserPayload;
+          if (payload.freezeState) {
+            isFrozen = payload.freezeState.type === 'FROZEN';
+          }
+        }
+        
+        return {
+          id: w.id,
+          isFrozen,
+          isMinimized: w.isMinimized || false
+        };
+      });
+    
+    // Check if the order or any window state has changed
+    const stateChanged = sortedWindows.length !== prevWindowOrderRef.current.length ||
+      sortedWindows.some((window, index) => {
+        const prev = prevWindowOrderRef.current[index];
+        return !prev || 
+               window.id !== prev.id || 
+               window.isFrozen !== prev.isFrozen || 
+               window.isMinimized !== prev.isMinimized;
+      });
+    
+    if (stateChanged && window.api?.syncWindowStackOrder) {
+      console.log('[NotebookWorkspace] Window order changed, syncing with native views:', sortedWindows);
+      
+      // Debounce the sync to avoid excessive IPC calls
+      const timeoutId = setTimeout(() => {
+        window.api.syncWindowStackOrder(sortedWindows)
+          .then(() => {
+            console.log('[NotebookWorkspace] Successfully synced window stack order');
+            prevWindowOrderRef.current = sortedWindows;
+          })
+          .catch((error) => {
+            console.error('[NotebookWorkspace] Failed to sync window stack order:', error);
+          });
+      }, 100); // 100ms debounce
+      
+      return () => clearTimeout(timeoutId);
+    }
+  }, [windows]);
+
+  // Global shortcut handler for minimizing window
+  useEffect(() => {
+    if (window.api?.onShortcutMinimizeWindow) {
+      const unsubscribe = window.api.onShortcutMinimizeWindow(() => {
+        console.log('[Shortcut] Received minimize window command.');
+        const focusedWindow = activeStore.getState().windows.find(w => w.isFocused);
+        if (focusedWindow) {
+          console.log(`[Shortcut] Toggling minimize for focused window ${focusedWindow.id}`);
+          activeStore.getState().toggleMinimize(focusedWindow.id);
+        }
+      });
+      return () => unsubscribe();
+    }
+  }, [activeStore]);
+
+  // Global shortcut handler for closing active window/tab
+  useEffect(() => {
+    if (window.api?.onCloseActiveRequested) {
+      const unsubscribe = window.api.onCloseActiveRequested(() => {
+        console.log('[Shortcut] Received close active window/tab command.');
+        const { windows, removeWindow } = activeStore.getState();
+        const focusedWindow = windows.find(w => w.isFocused);
+        
+        if (!focusedWindow) {
+          console.log('[Shortcut] No focused window found.');
+          return;
+        }
+        
+        console.log(`[Shortcut] Processing close for window ${focusedWindow.id} of type ${focusedWindow.type}`);
+        
+        if (focusedWindow.type === 'classic-browser') {
+          // For browser windows, close the active tab
+          const payload = focusedWindow.payload as ClassicBrowserPayload;
+          
+          if (payload.tabs.length > 1) {
+            // Close the active tab
+            console.log(`[Shortcut] Closing active tab ${payload.activeTabId} in browser window ${focusedWindow.id}`);
+            if (window.api?.classicBrowserCloseTab) {
+              window.api.classicBrowserCloseTab(focusedWindow.id, payload.activeTabId)
+                .then(result => {
+                  if (!result.success) {
+                    console.error('[Shortcut] Failed to close tab:', result.error);
+                  }
+                })
+                .catch(err => {
+                  console.error('[Shortcut] Error closing tab:', err);
+                });
+            }
+          } else {
+            // Last tab, close the window
+            console.log(`[Shortcut] Closing browser window ${focusedWindow.id} (last tab)`);
+            removeWindow(focusedWindow.id);
+          }
+        } else {
+          // For non-browser windows, close the window directly
+          console.log(`[Shortcut] Closing window ${focusedWindow.id}`);
+          removeWindow(focusedWindow.id);
+        }
+      });
+      return () => unsubscribe();
+    }
+  }, [activeStore]);
+
+
+  // Effect for smart transition timing
+  useEffect(() => {
+    console.log(`[NotebookWorkspace] Mounted notebook ${notebookId} with ${windows.length} windows`);
+    
+    if (isHydrated) {
+      // Calculate how long hydration took
+      const hydrationTime = Date.now() - loadStartTime;
+      const minimumAnimationTime = 600; // Reduced from 800ms for faster but still smooth transition
+      
+      console.log(`[NotebookWorkspace] Hydration completed in ${hydrationTime}ms`);
+      
+      // If hydration was fast, wait for remaining animation time
+      // If hydration was slow, proceed immediately
+      const remainingTime = Math.max(0, minimumAnimationTime - hydrationTime);
+      
+      console.log(`[NotebookWorkspace] Waiting ${remainingTime}ms before showing content`);
+      
+      const readyTimer = setTimeout(() => {
+        setIsReady(true);
+        console.log(`[NotebookWorkspace] Transition ready, starting fade-in`);
+      }, remainingTime);
+      
+      return () => {
+        clearTimeout(readyTimer);
+        console.log(`[NotebookWorkspace] Unmounting notebook ${notebookId}. Windows will be persisted.`);
+      };
+    }
+  }, [notebookId, isHydrated, loadStartTime, windows.length]);
+
+  // Effect for handling window close/unload and main process flush requests
+  useEffect(() => {
+    // Handler for flushing all stores
+    const flushAllStores = async () => {
+      console.log('[NotebookWorkspace] Flushing all notebook stores...');
+      const flushPromises: Promise<void>[] = [];
+      notebookStores.forEach(store => {
+        const persistApi = (store as StoreApi<WindowStoreState> & { persist?: { flush?: () => Promise<void> } }).persist;
+        if (persistApi && typeof persistApi.flush === 'function') {
+          flushPromises.push(persistApi.flush());
+        } else {
+          console.warn('[NotebookWorkspace] Store instance does not have a persist.flush method or persist API.', store);
+        }
+      });
+      try {
+        await Promise.all(flushPromises);
+        console.log('[NotebookWorkspace] All notebook stores flushed successfully.');
+      } catch (error) {
+        console.error('[NotebookWorkspace] Error flushing notebook stores:', error);
+      }
+    };
+
+    // Listener for 'beforeunload' event (browser tab/window close)
+    const handleBeforeUnload = () => {
+      console.log('[NotebookWorkspace] beforeunload event triggered. Flushing stores.');
+      // Fire and forget for beforeunload, as it doesn't reliably await promises
+      flushAllStores();
+    };
+    window.addEventListener('beforeunload', handleBeforeUnload);
+
+    // Listener for main process flush request
+    if (window.api && typeof window.api.onMainRequestFlush === 'function') {
+      window.api.onMainRequestFlush(async () => {
+        console.log('[NotebookWorkspace] Received flush request from main process.');
+        await flushAllStores(); // Await here as preload script handles sending completion
+      });
+      console.log('[NotebookWorkspace] Registered listener for main process flush requests.');
+    } else {
+      console.warn('[NotebookWorkspace] window.api.onMainRequestFlush is not available.');
+    }
+
+    return () => {
+      window.removeEventListener('beforeunload', handleBeforeUnload);
+      // No specific cleanup needed for onMainRequestFlush as it doesn't return a remover
+      // and is intended as a global, app-lifecycle listener.
+      console.log('[NotebookWorkspace] Cleanup: beforeunload listener removed. Main flush listener was global.');
+    };
+  }, []); // Empty dependency array: runs once on mount, cleans up on unmount
+
+  // NOTE: Removed onClassicBrowserViewFocused listener to prevent focus feedback loop.
+  // With the new controller pattern, all focus changes originate from the frontend.
+
+  // Centralized effect to subscribe to state updates from all classic browser windows
+  useEffect(() => {
+    if (window.api && typeof window.api.onClassicBrowserState === 'function') {
+      const unsubscribe = window.api.onClassicBrowserState((update: ClassicBrowserStateUpdate) => {
+        console.log(`[NotebookWorkspace] Received state update for window ${update.windowId}:`, update.update);
+        const { updateWindowProps, windows } = activeStore.getState();
+        const currentWindow = windows.find(w => w.id === update.windowId);
+        if (currentWindow && currentWindow.type === 'classic-browser') {
+          // Complete state replacement - use the tabs and activeTabId from the update
+          const newPayload: ClassicBrowserPayload = {
+            ...currentWindow.payload as ClassicBrowserPayload,
+            tabs: update.update.tabs || [],
+            activeTabId: update.update.activeTabId || ''
+          };
+
+          // Get the active tab for window title
+          const activeTab = newPayload.tabs.find(t => t.id === newPayload.activeTabId);
+          const newWindowTitle = activeTab?.title || currentWindow.title;
+
+          console.log(`[NotebookWorkspace] Updating window ${update.windowId} with ${newPayload.tabs.length} tabs, active: ${newPayload.activeTabId}`);
+          updateWindowProps(update.windowId, { title: newWindowTitle, payload: newPayload });
+        }
+      });
+
+      return () => {
+        console.log(`[NotebookWorkspace] Unsubscribing from onClassicBrowserState.`);
+        unsubscribe();
+      };
+    } else {
+      console.warn(`[NotebookWorkspace] window.api.onClassicBrowserState is not available.`);
+    }
+  }, [activeStore]);
+
+  // Handler for notebook intent submission
+  const handleNotebookIntentSubmit = useCallback(async () => {
+    if (!notebookIntentText.trim() || !notebookId) return;
+    const currentIntent = notebookIntentText;
+    setNotebookIntentText('');
+    setIsNotebookIntentProcessing(true);
+
+    console.log(`[NotebookWorkspace] Submitting intent: "${currentIntent}" for notebook: ${notebookId}`);
+    try {
+      if (window.api?.setIntent) {
+        await window.api.setIntent({
+          intentText: currentIntent,
+          context: 'notebook',
+          notebookId: notebookId,
+        });
+      } else {
+        console.warn("[NotebookWorkspace] window.api.setIntent is not available.");
+      }
+    } catch (error) {
+      console.error("[NotebookWorkspace] Failed to set intent:", error);
+    } finally {
+      setIsNotebookIntentProcessing(false);
+    }
+  }, [notebookIntentText, notebookId]);
+
+  // Effect for handling intent results
+  useEffect(() => {
+    if (!window.api?.onIntentResult) {
+      console.warn("[NotebookWorkspace] window.api.onIntentResult is not available.");
+      return;
+    }
+
+    const unsubscribe = window.api.onIntentResult((result: IntentResultPayload) => {
+      console.log(`[NotebookWorkspace] Received intent result:`, result);
+      
+      if (result.type === 'open_notebook') {
+        // Handle switching to a different notebook
+        if (result.notebookId !== notebookId) {
+          console.log(`[NotebookWorkspace] Switching to notebook: ${result.notebookId} (${result.title})`);
+          router.push(`/notebook/${result.notebookId}`);
+        } else {
+          console.log(`[NotebookWorkspace] Already in notebook: ${result.notebookId}`);
+        }
+      } else if (result.type === 'open_in_classic_browser') {
+        if (result.notebookId === notebookId) {
+          console.log(`[NotebookWorkspace] Received open_in_classic_browser for URL: ${result.url}`);
+          if (result.message) {
+            console.log(`[NotebookWorkspace] Message from intent: ${result.message}`);
+          }
+
+          // Minimize any existing classic-browser windows
+          const currentWindows = activeStore.getState().windows;
+          currentWindows.forEach(window => {
+            if (window.type === 'classic-browser' && !window.isMinimized) {
+              activeStore.getState().minimizeWindow(window.id);
+            }
+          });
+
+          const classicBrowserPayload: ClassicBrowserPayload = {
+            initialUrl: result.url,
+            tabs: [], // Start with empty tabs - backend will create the initial tab
+            activeTabId: '',
+            freezeState: { type: 'ACTIVE' } // Start in active state
+          };
+          
+          // Calculate bounds with proper padding
+          // Assuming viewport dimensions (we'll use window.innerWidth/Height)
+          // Left padding: 18px, Top padding: 18px, Right padding: 18px (before sidebar), Bottom padding: 60px
+          const viewportWidth = window.innerWidth;
+          const viewportHeight = window.innerHeight;
+          const sidebarWidth = 48; // Default sidebar width when collapsed (sidebar is on the right)
+          
+          activeStore.getState().addWindow({
+            type: 'classic-browser',
+            payload: classicBrowserPayload,
+            preferredMeta: { 
+              x: 18, 
+              y: 18,
+              width: viewportWidth - sidebarWidth - 18 - 18, 
+              height: viewportHeight - 18 - 60,
+              title: "Browser"
+            }
+          });
+        } else {
+          console.warn(`[NotebookWorkspace] Received open_in_classic_browser for a different notebook: ${result.notebookId}`);
+        }
+      }
+      // Handle other result types if needed
+    });
+
+    return () => {
+      if (unsubscribe) {
+        unsubscribe();
+      }
+    };
+  }, [notebookId, activeStore, windows.length, router]);
+
+  // MOVED UP: Define useCallback before any conditional returns.
+  const handleAddWindow = useCallback(() => {
+    // Minimize any existing classic-browser windows
+    const currentWindows = activeStore.getState().windows;
+    currentWindows.forEach(window => {
+      if (window.type === 'classic-browser' && !window.isMinimized) {
+        activeStore.getState().minimizeWindow(window.id);
+      }
+    });
+
+    const newWindowType: WindowContentType = 'classic-browser';
+    const newWindowPayload: ClassicBrowserPayload = {
+      initialUrl: 'https://www.are.na',
+      tabs: [], // Start with empty tabs - backend will create the initial tab
+      activeTabId: '',
+      freezeState: { type: 'ACTIVE' } // Start in active state
+    };
+    
+    // Calculate bounds with proper padding
+    const viewportWidth = window.innerWidth;
+    const viewportHeight = window.innerHeight;
+    const sidebarWidth = 48; // Default sidebar width when collapsed (sidebar is on the right)
+    
+    activeStore.getState().addWindow({
+      type: newWindowType,
+      payload: newWindowPayload,
+      preferredMeta: { 
+        x: 18, 
+        y: 18,
+        width: viewportWidth - sidebarWidth - 18 - 18, 
+        height: viewportHeight - 18 - 60
+      }
+    });
+  }, [activeStore]);
+
+  const handleAddChatWindow = useCallback(() => {
+    const currentWindows = activeStore.getState().windows;
+    const newWindowType: WindowContentType = 'chat';
+    // For a new chat, we'd typically get a sessionId from the backend/service
+    // For now, let's generate a client-side placeholder UUID.
+    // In a real scenario, this might involve an IPC call to a ChatService to create a session.
+    const newSessionId = crypto.randomUUID(); 
+    const newWindowPayload: WindowPayload = {
+      sessionId: newSessionId,
+    };
+    const x = (currentWindows.length % 5) * 210 + 100; // Offset slightly from browser
+    const y = Math.floor(currentWindows.length / 5) * 210 + 100; // Offset slightly
+    
+    activeStore.getState().addWindow({
+      type: newWindowType,
+      payload: newWindowPayload,
+      preferredMeta: { 
+        title: "New Chat", // Title should be within preferredMeta
+        x, 
+        y, 
+        width: 400, 
+        height: 600 
+      }
+    });
+  }, [activeStore]);
+
+  const handleGoHome = useCallback(() => {
+    router.push('/');
+  }, [router]);
+
+  // Guard: Ensure store is hydrated.
+  if (!isHydrated) {
+    console.log(`[NotebookWorkspace] Not hydrated yet for notebook ${notebookId}`);
+    return (
+      <div className="h-screen bg-step-1" />
+    );
+  }
+  
+  console.log(`[NotebookWorkspace] Rendering notebook ${notebookId} with ${windows.length} windows:`, {
+    notebookId,
+    windowCount: windows.length,
+    windows: windows.map(w => ({
+      id: w.id,
+      type: w.type,
+      title: w.title,
+      payload: w.payload
+    })),
+    timestamp: new Date().toISOString()
+  });
+
+  return (
+    <SidebarProvider defaultOpen={false}>
+      <NotebookContent 
+        windows={windows}
+        activeStore={activeStore}
+        notebookId={notebookId}
+        notebookTitle={notebookTitle}
+        setNotebookTitle={setNotebookTitle}
+        onAddChat={handleAddChatWindow}
+        onAddBrowser={handleAddWindow}
+        onGoHome={handleGoHome}
+        notebookIntentText={notebookIntentText}
+        setNotebookIntentText={setNotebookIntentText}
+        handleNotebookIntentSubmit={handleNotebookIntentSubmit}
+        isNotebookIntentProcessing={isNotebookIntentProcessing}
+        isReady={isReady}
+        isIntentLineVisible={isIntentLineVisible}
+        setIsIntentLineVisible={setIsIntentLineVisible}
+      />
+    </SidebarProvider>
+  );
+}
+
+interface NotebookViewProps {
+  notebookId: string;
+}
+
+export default function NotebookView({ notebookId }: NotebookViewProps) {
+  const [resolvedNotebookId, setResolvedNotebookId] = useState<string | null>(null);
+
+  useEffect(() => {
+    if (notebookId) {
+      console.log(`[NotebookView] Resolved notebookId: ${notebookId}`);
+      setResolvedNotebookId(notebookId);
+    } else {
+      console.warn('[NotebookView] notebookId is missing or invalid');
+      setResolvedNotebookId(null);
+    }
+  }, [notebookId]);
+
+  if (!resolvedNotebookId) {
+    return (
+      <div className="flex items-center justify-center h-screen">
+        <p className="text-xl">Resolving notebook...</p>
+      </div>
+    );
+  }
+
+  return <NotebookWorkspace notebookId={resolvedNotebookId} />;
+}
\ No newline at end of file
diff --git a/src/components/ui/notebook-info-pill.tsx b/src/components/ui/notebook-info-pill.tsx
index cecc7587..d816ecf3 100644
--- a/src/components/ui/notebook-info-pill.tsx
+++ b/src/components/ui/notebook-info-pill.tsx
@@ -12,7 +12,7 @@ import {
   DropdownMenuSeparator,
   DropdownMenuTrigger,
 } from "@/components/ui/dropdown-menu";
-import { useRouter, useParams } from "next/navigation";
+import { useHashRouter } from "@/hooks/useHashRouter";
 
 interface NotebookInfoPillProps {
   title: string;
@@ -29,9 +29,8 @@ export function NotebookInfoPill({ title, className = "", onTitleChange, parentZ
   const [recentNotebooks, setRecentNotebooks] = useState<RecentNotebook[]>([]);
   const [isDropdownOpen, setIsDropdownOpen] = useState(false);
   const inputRef = useRef<HTMLInputElement>(null);
-  const router = useRouter();
-  const params = useParams();
-  const currentNotebookId = params?.notebookId as string;
+  const router = useHashRouter();
+  const currentNotebookId = router.params.notebookId;
   
   useEffect(() => {
     const timer = setInterval(() => {
diff --git a/src/components/ui/open-in-notebook-button.tsx b/src/components/ui/open-in-notebook-button.tsx
index 9ef12300..e972080d 100644
--- a/src/components/ui/open-in-notebook-button.tsx
+++ b/src/components/ui/open-in-notebook-button.tsx
@@ -2,7 +2,7 @@
 
 import React, { useState, useCallback } from 'react';
 import { ExternalLink } from 'lucide-react';
-import { useRouter } from 'next/navigation';
+import { useHashRouter } from '@/hooks/useHashRouter';
 import { cn } from '@/lib/utils';
 import {
   DropdownMenu,
@@ -23,7 +23,7 @@ interface OpenInNotebookButtonProps {
 export function OpenInNotebookButton({ url, className, onBeforeOpen, onAfterClose }: OpenInNotebookButtonProps) {
   const [notebooks, setNotebooks] = useState<Array<{ id: string; title: string }>>([]);
   const [isLoading, setIsLoading] = useState(false);
-  const router = useRouter();
+  const router = useHashRouter();
 
   const loadNotebooks = useCallback(async () => {
     setIsLoading(true);
diff --git a/src/hooks/useHashRouter.ts b/src/hooks/useHashRouter.ts
new file mode 100644
index 00000000..bba66e0a
--- /dev/null
+++ b/src/hooks/useHashRouter.ts
@@ -0,0 +1,51 @@
+"use client";
+
+import { useState, useEffect, useCallback, useMemo } from "react";
+
+interface HashRouterParams {
+  notebookId?: string;
+}
+
+interface HashRouter {
+  push: (path: string) => void;
+  params: HashRouterParams;
+  pathname: string;
+}
+
+export function useHashRouter(): HashRouter {
+  const [currentPath, setCurrentPath] = useState<string>('');
+
+  useEffect(() => {
+    const handleHashChange = () => {
+      const hash = window.location.hash.slice(1) || '/';
+      setCurrentPath(hash);
+    };
+
+    // Set initial path
+    handleHashChange();
+
+    // Listen for hash changes
+    window.addEventListener('hashchange', handleHashChange);
+
+    return () => {
+      window.removeEventListener('hashchange', handleHashChange);
+    };
+  }, []);
+
+  const push = useCallback((path: string) => {
+    window.location.hash = path;
+  }, []);
+
+  const params = useMemo((): HashRouterParams => {
+    const match = currentPath.match(/\/notebook\/([^\/]+)/);
+    return {
+      notebookId: match?.[1] || undefined
+    };
+  }, [currentPath]);
+
+  return {
+    push,
+    params,
+    pathname: currentPath
+  };
+}
\ No newline at end of file
