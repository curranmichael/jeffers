import Database from 'better-sqlite3';
import { getDb } from './db'; // Assuming getDb is similar to ObjectModel's setup
import { logger } from '../utils/logger';
import { NotebookRecord } from '../shared/types';

// Interface for the database record (snake_case columns)
interface NotebookDbRecord {
  id: string;
  title: string;
  description: string | null;
  object_id: string | null;
  created_at: string;
  updated_at: string;
  // TSTP fields
  summary?: string | null;
  tags_json?: string | null;
  propositions_json?: string | null;
  tstp_generated_at?: string | null;
}

// Helper to convert DB record (snake_case) to application object (camelCase)
function mapRecordToNotebook(record: NotebookDbRecord): NotebookRecord {
  return {
    id: record.id,
    title: record.title,
    description: record.description,
    objectId: record.object_id ?? "",  // Convert null to empty string for type compatibility
    createdAt: record.created_at,
    updatedAt: record.updated_at,
    // TSTP fields
    summary: record.summary,
    tagsJson: record.tags_json,
    propositionsJson: record.propositions_json,
    tstpGeneratedAt: record.tstp_generated_at,
  };
}

export class NotebookModel {
  private db: Database.Database;

  constructor(dbInstance?: Database.Database) {
    this.db = dbInstance ?? getDb();
    logger.info(`[NotebookModel] Initialized with database: ${this.db.name}`);
  }

  /**
   * Creates a new notebook record in the database.
   * Assumes id is provided (generated by the service layer).
   * Timestamps are set automatically by the database using ISO 8601 format.
   * @param id - The UUID of the notebook.
   * @param title - The title of the notebook.
   * @param objectId - The ID of the associated JeffersObject, or null for NotebookCovers.
   * @param description - Optional description for the notebook.
   * @returns Promise resolving to the created NotebookRecord.
   */
  async create(id: string, title: string, objectId: string | null, description?: string | null): Promise<NotebookRecord> {
    const now = new Date().toISOString();
    const stmt = this.db.prepare(`
      INSERT INTO notebooks (id, title, description, object_id, created_at, updated_at)
      VALUES (@id, @title, @description, @objectId, @createdAt, @updatedAt)
    `);

    try {
      stmt.run({
        id,
        title,
        description: description ?? null,
        objectId,
        createdAt: now,
        updatedAt: now,
      });
      logger.debug(`[NotebookModel] Created notebook with ID: ${id}, ObjectId: ${objectId}`);
      
      // Construct and return the NotebookRecord directly as getById would also need object_id from DB
      // which requires schema change. This assumes insert was successful.
      return {
        id,
        title,
        description: description ?? null,
        objectId: objectId ?? "",  // Convert null to empty string for type compatibility
        createdAt: now,
        updatedAt: now,
      };
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to create notebook with ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Retrieves a single notebook by its UUID.
   * @param id - The UUID of the notebook.
   * @returns Promise resolving to the NotebookRecord or null if not found.
   */
  async getById(id: string): Promise<NotebookRecord | null> {
    const stmt = this.db.prepare('SELECT * FROM notebooks WHERE id = ?');
    try {
      const record = stmt.get(id) as NotebookDbRecord | undefined;
      return record ? mapRecordToNotebook(record) : null;
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to get notebook by ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Retrieves all notebook records from the database.
   * Ordered by title ascending.
   * @returns Promise resolving to an array of NotebookRecord.
   */
  async getAll(): Promise<NotebookRecord[]> {
    const stmt = this.db.prepare('SELECT * FROM notebooks ORDER BY title ASC');
    try {
      const records = stmt.all() as NotebookDbRecord[];
      logger.info(`[NotebookModel] getAll() found ${records.length} notebooks in database`);
      if (records.length > 0) {
        logger.debug('[NotebookModel] Sample notebook:', records[0]);
      }
      return records.map(mapRecordToNotebook);
    } catch (error: any) {
      logger.error('[NotebookModel] Failed to get all notebooks:', error);
      throw error;
    }
  }

  /**
   * Retrieves all regular notebooks (excludes NotebookCovers).
   * A NotebookCover has an ID that starts with "cover-".
   * Ordered by title ascending.
   * @returns Promise resolving to an array of NotebookRecord.
   */
  async getAllRegularNotebooks(): Promise<NotebookRecord[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM notebooks 
      WHERE id NOT LIKE 'cover-%' 
      ORDER BY title ASC
    `);
    try {
      const records = stmt.all() as NotebookDbRecord[];
      logger.info(`[NotebookModel] getAllRegularNotebooks() found ${records.length} regular notebooks`);
      return records.map(mapRecordToNotebook);
    } catch (error: any) {
      logger.error('[NotebookModel] Failed to get regular notebooks:', error);
      throw error;
    }
  }

  /**
   * Retrieves the NotebookCover for a specific user.
   * @param userId - The user ID (defaults to 'default_user').
   * @returns Promise resolving to the NotebookCover or null if not found.
   */
  async getNotebookCover(userId: string = 'default_user'): Promise<NotebookRecord | null> {
    const coverId = `cover-${userId}`;
    const stmt = this.db.prepare('SELECT * FROM notebooks WHERE id = ?');
    try {
      const record = stmt.get(coverId) as NotebookDbRecord | undefined;
      if (record) {
        logger.debug(`[NotebookModel] Found NotebookCover for user ${userId}`);
        return mapRecordToNotebook(record);
      }
      logger.debug(`[NotebookModel] No NotebookCover found for user ${userId}`);
      return null;
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to get NotebookCover for user ${userId}:`, error);
      throw error;
    }
  }

  /**
   * Retrieves multiple notebooks by their IDs.
   * @param ids - Array of notebook IDs to retrieve.
   * @returns Promise resolving to an array of NotebookRecord.
   */
  async getByIds(ids: string[]): Promise<NotebookRecord[]> {
    if (ids.length === 0) {
      return [];
    }

    const placeholders = ids.map(() => '?').join(', ');
    const stmt = this.db.prepare(`
      SELECT * FROM notebooks 
      WHERE id IN (${placeholders})
    `);
    
    try {
      const records = stmt.all(...ids) as NotebookDbRecord[];
      logger.debug(`[NotebookModel] getByIds() found ${records.length} notebooks out of ${ids.length} requested`);
      return records.map(mapRecordToNotebook);
    } catch (error: any) {
      logger.error('[NotebookModel] Failed to get notebooks by IDs:', error);
      throw error;
    }
  }

  /**
   * Creates a NotebookCover for a specific user if it doesn't exist.
   * @param userId - The user ID (defaults to 'default_user').
   * @returns Promise resolving to the NotebookCover.
   */
  async ensureNotebookCover(userId: string = 'default_user'): Promise<NotebookRecord> {
    const existingCover = await this.getNotebookCover(userId);
    if (existingCover) {
      return existingCover;
    }

    // Create new NotebookCover
    const coverId = `cover-${userId}`;
    const title = 'Homepage Conversations';
    const description = `This is a special notebook that stores all homepage chat conversations for ${userId}`;
    
    try {
      // NotebookCovers don't have associated objects, so pass null for objectId
      return await this.create(coverId, title, null, description);
    } catch (error: any) {
      // Handle race condition where another process might have created it
      if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
        const cover = await this.getNotebookCover(userId);
        if (cover) {
          return cover;
        }
      }
      throw error;
    }
  }

  /**
   * Updates specific fields of a notebook record.
   * Currently supports updating 'title' and 'description'.
   * Automatically updates the 'updated_at' timestamp.
   * @param id - The UUID of the notebook to update.
   * @param data - An object containing fields to update (e.g., { title: 'New Title', description: 'New Desc' }).
   * @returns Promise resolving to the updated NotebookRecord or null if not found or no changes made.
   */
  async update(id: string, data: Partial<Pick<NotebookRecord, 'title' | 'description'>>): Promise<NotebookRecord | null> {
    const fieldsToSet: string[] = [];
    const params: Record<string, any> = { id };

    if (data.title !== undefined) {
      fieldsToSet.push('title = @title');
      params.title = data.title;
    }
    if (data.description !== undefined) {
      fieldsToSet.push('description = @description');
      params.description = data.description;
    }

    if (fieldsToSet.length === 0) {
      logger.warn(`[NotebookModel] Update called for notebook ${id} with no fields to update.`);
      return this.getById(id); // Return current record if no actual update occurred
    }

    const stmt = this.db.prepare(`
      UPDATE notebooks
      SET ${fieldsToSet.join(', ')}
      WHERE id = @id
    `);

    try {
      const info = stmt.run(params);
      if (info.changes > 0) {
        logger.debug(`[NotebookModel] Updated notebook ${id}. Fields: ${Object.keys(data).join(', ')}`);
        return this.getById(id); // Fetch and return the updated record
      } else {
        logger.warn(`[NotebookModel] Attempted to update non-existent notebook ID ${id} or no changes made that triggered an update.`);
        return null; // Or fetch by ID if you want to return the record even if DB reports no change
      }
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to update notebook ${id}:`, error);
      throw error;
    }
  }
  
  /**
   * Deletes a notebook by its ID.
   * Note: This does not handle cascades to related 'chunks' or other entities.
   * That logic should be in the service layer or handled by DB foreign key constraints with ON DELETE CASCADE.
   * @param id The UUID of the notebook to delete.
   * @returns Promise<boolean> indicating success (true if a row was deleted, false otherwise).
   */
  async delete(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM notebooks WHERE id = ?');
    try {
      const info = stmt.run(id);
      if (info.changes > 0) {
        logger.debug(`[NotebookModel] Deleted notebook with ID: ${id}`);
        return true;
      }
      logger.warn(`[NotebookModel] Attempted to delete non-existent notebook ID ${id}`);
      return false;
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to delete notebook ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Gets all object IDs associated with a notebook via the junction table.
   * @param notebookId - The UUID of the notebook.
   * @returns Array of object IDs.
   */
  getObjectIdsForNotebook(notebookId: string): string[] {
    const stmt = this.db.prepare(`
      SELECT object_id 
      FROM notebook_objects 
      WHERE notebook_id = ?
      ORDER BY added_at DESC
    `);
    
    try {
      const rows = stmt.all(notebookId) as { object_id: string }[];
      logger.debug(`[NotebookModel] Found ${rows.length} objects for notebook ${notebookId}`);
      return rows.map(row => row.object_id);
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to get object IDs for notebook ${notebookId}:`, error);
      throw error;
    }
  }

  /**
   * Gets all notebook IDs that contain a specific object.
   * @param objectId - The UUID of the object.
   * @returns Array of notebook IDs.
   */
  getNotebookIdsForObject(objectId: string): string[] {
    const stmt = this.db.prepare(`
      SELECT notebook_id 
      FROM notebook_objects 
      WHERE object_id = ?
      ORDER BY added_at DESC
    `);
    
    try {
      const rows = stmt.all(objectId) as { notebook_id: string }[];
      logger.debug(`[NotebookModel] Found ${rows.length} notebooks containing object ${objectId}`);
      return rows.map(row => row.notebook_id);
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to get notebook IDs for object ${objectId}:`, error);
      throw error;
    }
  }

  /**
   * Checks if an object is associated with a notebook.
   * @param notebookId - The UUID of the notebook.
   * @param objectId - The UUID of the object.
   * @returns True if the association exists, false otherwise.
   */
  isObjectInNotebook(notebookId: string, objectId: string): boolean {
    const stmt = this.db.prepare(`
      SELECT 1 
      FROM notebook_objects 
      WHERE notebook_id = ? AND object_id = ?
      LIMIT 1
    `);
    
    try {
      const result = stmt.get(notebookId, objectId);
      return result !== undefined;
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to check if object ${objectId} is in notebook ${notebookId}:`, error);
      throw error;
    }
  }

  /**
   * Gets the count of objects in a notebook.
   * @param notebookId - The UUID of the notebook.
   * @returns The number of objects in the notebook.
   */
  getObjectCountForNotebook(notebookId: string): number {
    const stmt = this.db.prepare(`
      SELECT COUNT(*) as count 
      FROM notebook_objects 
      WHERE notebook_id = ?
    `);
    
    try {
      const result = stmt.get(notebookId) as { count: number };
      return result.count;
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to get object count for notebook ${notebookId}:`, error);
      throw error;
    }
  }

  /**
   * Updates the TSTP (Tags, Summary, Propositions) fields for a notebook.
   * @param notebookId - The UUID of the notebook to update.
   * @param tstp - Object containing the TSTP data to save.
   * @returns Promise resolving to the updated NotebookRecord or null if not found.
   */
  async updateTSTP(notebookId: string, tstp: {
    summary: string;
    tags: string[];
    propositions: any[];
  }): Promise<NotebookRecord | null> {
    const now = new Date().toISOString();
    const stmt = this.db.prepare(`
      UPDATE notebooks
      SET summary = @summary,
          tags_json = @tagsJson,
          propositions_json = @propositionsJson,
          tstp_generated_at = @tstpGeneratedAt,
          updated_at = @updatedAt
      WHERE id = @id
    `);

    try {
      const info = stmt.run({
        id: notebookId,
        summary: tstp.summary,
        tagsJson: JSON.stringify(tstp.tags),
        propositionsJson: JSON.stringify(tstp.propositions),
        tstpGeneratedAt: now,
        updatedAt: now,
      });

      if (info.changes > 0) {
        logger.debug(`[NotebookModel] Updated TSTP for notebook ${notebookId}`);
        return this.getById(notebookId);
      } else {
        logger.warn(`[NotebookModel] Failed to update TSTP for non-existent notebook ${notebookId}`);
        return null;
      }
    } catch (error: any) {
      logger.error(`[NotebookModel] Failed to update TSTP for notebook ${notebookId}:`, error);
      throw error;
    }
  }
} 