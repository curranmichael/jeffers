# Electron Packaging & Routing Architecture Overhaul

## Technical Problem Overview

The core issue was that Next.js App Router with dynamic routes cannot be packaged as a static export for Electron. When you build for Electron, you need static files that can be served via the `file://` protocol, but Next.js dynamic routes require server-side rendering or API routes to handle the `[notebookId]` parameter.

## Architecture Changes

### 1. Static Export Configuration

**Next.js Configuration** (`next.config.ts`):
```typescript
const nextConfig: NextConfig = {
  output: 'export',           // Generate static HTML files
  images: { unoptimized: true }, // Disable Next.js image optimization
  trailingSlash: false,       // Clean URLs
  generateBuildId: async () => 'static-build' // Consistent build ID
};
```

This configuration tells Next.js to:
- Generate static HTML files instead of server-side rendering
- Skip image optimization (incompatible with Electron)
- Use a consistent build ID for predictable asset paths

### 2. The Giant Single-Page Application

**The Core Insight**: Instead of multiple HTML files for different routes, we generate one massive `index.html` file that contains the entire application as a single-page application.

**What happens during build**:
1. Next.js processes all pages and components
2. Bundles everything into static JavaScript chunks
3. Generates a single `index.html` with all the bundled JavaScript
4. Creates a `_next/static/` directory with chunked JavaScript and CSS files

**The Generated Structure**:
```
out/
├── index.html              # The giant single HTML file
├── _next/static/
│   ├── chunks/             # 200+ JavaScript chunks
│   │   ├── app/
│   │   │   ├── page-ad3237d53c25140a.js      # Home page
│   │   │   └── notebook/[notebookId]/
│   │   │       └── page-4b820eda9dd93279.js  # Notebook page
│   │   ├── framework-47112191c39a1cff.js     # React framework
│   │   ├── main-app-b04e66c0f06ca741.js      # Main app bundle
│   │   └── [hundreds of other chunks]
│   ├── css/               # Consolidated CSS files
│   └── media/             # Font files and assets
└── fonts/                 # Custom fonts (Soehne, Signifier)
```

### 3. Component Architecture Transformation

**Before**: Server Components with Dynamic Routes
```typescript
// src/app/notebook/[notebookId]/page.tsx
export default function NotebookPage({ params }: { params: { notebookId: string } }) {
  // This requires server-side rendering
  return <NotebookView notebookId={params.notebookId} />;
}
```

**After**: Client Components with Hash Routing
```typescript
// src/components/NotebookView.tsx
"use client";
export function NotebookView() {
  const { notebookId } = useHashRouter(); // Custom hook reads from window.location.hash
  return <div>Notebook {notebookId}</div>;
}
```

**Component Extraction**:
- `src/app/page.tsx` → `src/components/HomeView.tsx`
- `src/app/notebook/[notebookId]/page.tsx` → `src/components/NotebookView.tsx`

### 4. Hash-Based Routing System

**Custom Router Hook** (`src/hooks/useHashRouter.ts`):
```typescript
export function useHashRouter() {
  const [hash, setHash] = useState(() => window.location.hash);
  
  useEffect(() => {
    const handleHashChange = () => setHash(window.location.hash);
    window.addEventListener('hashchange', handleHashChange);
    return () => window.removeEventListener('hashchange', handleHashChange);
  }, []);
  
  // Parse #/notebook/123 into { notebookId: '123' }
  const parsed = parseHash(hash);
  return { ...parsed, navigate: (path) => window.location.hash = path };
}
```

**Navigation Examples**:
- Home: `#/` or just `#`
- Notebook: `#/notebook/abc123`
- Navigation: `navigate('/notebook/xyz789')`

### 5. Asset Path Resolution Crisis

**The Problem**: Next.js generates absolute paths like `//_next/static/...` but Electron serves files via `file://` protocol, making these paths invalid.

**The Solution**: Post-build script (`scripts/fix-electron-paths.js`):
```javascript
function fixHtmlFiles() {
  const htmlFiles = globSync('**/*.html', { cwd: outDir });
  for (const file of htmlFiles) {
    let content = fs.readFileSync(filePath, 'utf-8');
    // Convert: href="/_next/static/..." → href="./_next/static/..."
    content = content.replace(/href="\/(_next\/)/g, 'href="./$1');
    content = content.replace(/src="\/(_next\/)/g, 'src="./$1');
    fs.writeFileSync(filePath, content);
  }
}
```

**Critical Path Transformations**:
- `/_next/static/chunks/main.js` → `./_next/static/chunks/main.js`
- `/_next/static/css/styles.css` → `./_next/static/css/styles.css`
- Font paths, image paths, all static assets get relativized

### 6. Electron Main Process Integration

**Protocol Handler** (`electron/main.ts`):
```typescript
// Register custom protocol to serve static files
protocol.registerFileProtocol('app', (request, callback) => {
  const filePath = path.join(app.getAppPath(), 'out', url.fileURLToPath(request.url));
  callback(filePath);
});

// Load the app
mainWindow.loadURL(isDev ? 'http://localhost:3000' : `file://${path.join(__dirname, '../out/index.html')}`);
```

**Build Hook** (`forge.config.js`):
```javascript
hooks: {
  packageAfterPrune: async (config, buildPath) => {
    // Copy the 'out' directory (Next.js static export) to the packaged app
    const outSourcePath = path.join(__dirname, 'out');
    const outDestPath = path.join(buildPath, 'out');
    fs.cpSync(outSourcePath, outDestPath, { recursive: true });
  }
}
```

### 7. The Build Pipeline

**Complete Build Process**:
1. `npm run build:nextjs` 
   - Sets `ELECTRON_BUILD=true`
   - Runs `next build` (generates `out/` directory)
   - Runs `node scripts/fix-electron-paths.js` (fixes asset paths)
2. `npm run electron:build`
   - Compiles TypeScript Electron code
   - Bundles main process and preload scripts
   - Copies migrations and workers
3. `npm run package:mac/win/linux`
   - Electron Forge packages the app
   - Copies `out/` directory to packaged app via build hook
   - Creates platform-specific distributables

### 8. Platform-Specific Builds

**Package Scripts**:
- `package:mac` → Creates `.app` bundle for macOS
- `package:win` → Creates Windows executable
- `package:linux` → Creates Linux AppImage/deb/rpm

**Forge Makers Configuration**:
- **macOS**: ZIP archive (`.zip`)
- **Windows**: Squirrel installer (`.exe`)
- **Linux**: DEB and RPM packages

## The Result: How It All Works

**In Development**:
- Next.js dev server runs at `http://localhost:3000`
- Electron loads from dev server
- Hot reloading works normally
- Next.js App Router functions normally

**In Production**:
- Single `index.html` file loads the entire app
- JavaScript chunks load dynamically as needed
- Hash-based routing handles navigation
- All assets load via relative paths from `file://` protocol
- No server required - pure static file serving

**Runtime Navigation Flow**:
1. User clicks "Open Notebook"
2. `useHashRouter` sets `window.location.hash = '#/notebook/abc123'`
3. Hash change event triggers re-render
4. `NotebookView` component reads `notebookId` from hash
5. Component renders with correct notebook data
6. Browser back/forward buttons work via hash navigation

## Technical Benefits

1. **Single Build Artifact**: One HTML file contains the entire app
2. **Fast Loading**: Chunked JavaScript loads on-demand
3. **Offline-First**: No server dependency, pure static files
4. **Platform Compatibility**: Works identically on macOS, Windows, Linux
5. **Development Experience**: Maintains Next.js dev experience
6. **Progressive Enhancement**: Chunks load as needed, not all at once

## Files Modified

- **Build Configuration**: `next.config.ts`, `forge.config.js`, `package.json`
- **Asset Processing**: `scripts/fix-electron-paths.js` (post-build path fixing)
- **Routing System**: `src/hooks/useHashRouter.ts` (custom router)
- **Component Architecture**: Extracted server components to client components
- **Main Process**: `electron/main.ts` (protocol handlers, path resolution)
- **Database**: `models/LanceVectorModel.ts` (import fixes)

This architecture successfully bridges the gap between Next.js's modern development experience and Electron's static file serving requirements, creating a robust desktop application that feels native while maintaining web development velocity.