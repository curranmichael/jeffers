"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotebookModel = void 0;
const db_1 = require("./db"); // Assuming getDb is similar to ObjectModel's setup
const logger_1 = require("../utils/logger");
// Helper to convert DB record (snake_case) to application object (camelCase)
function mapRecordToNotebook(record) {
    return {
        id: record.id,
        title: record.title,
        description: record.description,
        createdAt: record.created_at,
        updatedAt: record.updated_at,
    };
}
class NotebookModel {
    constructor(dbInstance) {
        this.db = dbInstance ?? (0, db_1.getDb)();
    }
    /**
     * Creates a new notebook record in the database.
     * Assumes id is provided (generated by the service layer).
     * Timestamps are set to Date.now().
     * @param id - The UUID of the notebook.
     * @param title - The title of the notebook.
     * @param description - Optional description for the notebook.
     * @returns Promise resolving to the created NotebookRecord.
     */
    async create(id, title, description) {
        const now = Date.now();
        const stmt = this.db.prepare(`
      INSERT INTO notebooks (id, title, description, created_at, updated_at)
      VALUES (@id, @title, @description, @createdAt, @updatedAt)
    `);
        try {
            stmt.run({
                id,
                title,
                description: description ?? null,
                createdAt: now,
                updatedAt: now,
            });
            logger_1.logger.debug(`[NotebookModel] Created notebook with ID: ${id}`);
            // Fetch and return the created record to ensure consistency
            const newRecord = await this.getById(id);
            if (!newRecord) {
                // This should ideally not happen if insert succeeded
                throw new Error('Failed to retrieve newly created notebook');
            }
            return newRecord;
        }
        catch (error) {
            logger_1.logger.error(`[NotebookModel] Failed to create notebook with ID ${id}:`, error);
            throw error;
        }
    }
    /**
     * Retrieves a single notebook by its UUID.
     * @param id - The UUID of the notebook.
     * @returns Promise resolving to the NotebookRecord or null if not found.
     */
    async getById(id) {
        const stmt = this.db.prepare('SELECT * FROM notebooks WHERE id = ?');
        try {
            const record = stmt.get(id);
            return record ? mapRecordToNotebook(record) : null;
        }
        catch (error) {
            logger_1.logger.error(`[NotebookModel] Failed to get notebook by ID ${id}:`, error);
            throw error;
        }
    }
    /**
     * Retrieves all notebook records from the database.
     * Ordered by title ascending.
     * @returns Promise resolving to an array of NotebookRecord.
     */
    async getAll() {
        const stmt = this.db.prepare('SELECT * FROM notebooks ORDER BY title ASC');
        try {
            const records = stmt.all();
            return records.map(mapRecordToNotebook);
        }
        catch (error) {
            logger_1.logger.error('[NotebookModel] Failed to get all notebooks:', error);
            throw error;
        }
    }
    /**
     * Updates specific fields of a notebook record.
     * Currently supports updating 'title' and 'description'.
     * Automatically updates the 'updated_at' timestamp.
     * @param id - The UUID of the notebook to update.
     * @param data - An object containing fields to update (e.g., { title: 'New Title', description: 'New Desc' }).
     * @returns Promise resolving to the updated NotebookRecord or null if not found or no changes made.
     */
    async update(id, data) {
        const fieldsToSet = [];
        const params = { id };
        if (data.title !== undefined) {
            fieldsToSet.push('title = @title');
            params.title = data.title;
        }
        if (data.description !== undefined) {
            fieldsToSet.push('description = @description');
            params.description = data.description;
        }
        if (fieldsToSet.length === 0) {
            logger_1.logger.warn(`[NotebookModel] Update called for notebook ${id} with no fields to update.`);
            return this.getById(id); // Return current record if no actual update occurred
        }
        const stmt = this.db.prepare(`
      UPDATE notebooks
      SET ${fieldsToSet.join(', ')}
      WHERE id = @id
    `);
        try {
            const info = stmt.run(params);
            if (info.changes > 0) {
                logger_1.logger.debug(`[NotebookModel] Updated notebook ${id}. Fields: ${Object.keys(data).join(', ')}`);
                return this.getById(id); // Fetch and return the updated record
            }
            else {
                logger_1.logger.warn(`[NotebookModel] Attempted to update non-existent notebook ID ${id} or no changes made that triggered an update.`);
                return null; // Or fetch by ID if you want to return the record even if DB reports no change
            }
        }
        catch (error) {
            logger_1.logger.error(`[NotebookModel] Failed to update notebook ${id}:`, error);
            throw error;
        }
    }
    /**
     * Deletes a notebook by its ID.
     * Note: This does not handle cascades to related 'chunks' or other entities.
     * That logic should be in the service layer or handled by DB foreign key constraints with ON DELETE CASCADE.
     * @param id The UUID of the notebook to delete.
     * @returns Promise<boolean> indicating success (true if a row was deleted, false otherwise).
     */
    async delete(id) {
        const stmt = this.db.prepare('DELETE FROM notebooks WHERE id = ?');
        try {
            const info = stmt.run(id);
            if (info.changes > 0) {
                logger_1.logger.debug(`[NotebookModel] Deleted notebook with ID: ${id}`);
                return true;
            }
            logger_1.logger.warn(`[NotebookModel] Attempted to delete non-existent notebook ID ${id}`);
            return false;
        }
        catch (error) {
            logger_1.logger.error(`[NotebookModel] Failed to delete notebook ID ${id}:`, error);
            throw error;
        }
    }
}
exports.NotebookModel = NotebookModel;
//# sourceMappingURL=NotebookModel.js.map