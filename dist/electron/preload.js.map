{
  "version": 3,
  "sources": ["../../electron/preload.ts", "../../shared/ipcChannels.ts"],
  "sourcesContent": ["import { contextBridge, ipcRenderer } from 'electron';\nimport {\n  type IpcRendererEvent,\n} from 'electron';\n\n// Import channel constants and types from shared\nimport {\n    PROFILE_GET,\n    BOOKMARKS_IMPORT,\n    FILE_SAVE_TEMP,\n    BOOKMARKS_PROGRESS,\n    CHAT_STREAM_START,\n    CHAT_STREAM_STOP,\n    ON_CHAT_RESPONSE_CHUNK,\n    ON_CHAT_STREAM_END,\n    ON_CHAT_STREAM_ERROR,\n    CHAT_GET_MESSAGES,\n    GET_SLICE_DETAILS,\n    SET_INTENT,\n    ON_INTENT_RESULT,\n    // Notebook and Chat Session channels\n    NOTEBOOK_CREATE,\n    NOTEBOOK_GET_BY_ID,\n    NOTEBOOK_GET_ALL,\n    NOTEBOOK_UPDATE,\n    NOTEBOOK_DELETE,\n    NOTEBOOK_GET_CHUNKS,\n    CHAT_SESSION_CREATE_IN_NOTEBOOK,\n    CHAT_SESSION_LIST_FOR_NOTEBOOK,\n    CHAT_SESSION_TRANSFER_TO_NOTEBOOK,\n    // Store persistence channels\n    STORE_GET,\n    STORE_SET,\n    STORE_REMOVE,\n    // Add new channels for flushing\n    MAIN_REQUEST_RENDERER_FLUSH,\n    RENDERER_FLUSH_COMPLETE,\n    // Updated Classic Browser channel imports\n    CLASSIC_BROWSER_CREATE, // Renamed from CLASSIC_BROWSER_INIT_VIEW\n    CLASSIC_BROWSER_NAVIGATE,\n    CLASSIC_BROWSER_SET_BOUNDS, // New\n    CLASSIC_BROWSER_SET_VISIBILITY, // New\n    ON_CLASSIC_BROWSER_STATE, // Renamed from ON_CLASSIC_BROWSER_STATE_UPDATE\n    CLASSIC_BROWSER_DESTROY,\n    CLASSIC_BROWSER_LOAD_URL, // Added new channel\n} from '../shared/ipcChannels';\n// Import IChatMessage along with other types\nimport {\n  IAppAPI,\n  BookmarksProgressEvent,\n  IChatMessage,\n  SliceDetail,\n  StructuredChatMessage,\n  ChatMessageSourceMetadata,\n  IntentPayload,\n  IntentResultPayload,\n  NotebookRecord,\n  ObjectChunk,\n  IChatSession,\n  ClassicBrowserPayload,\n} from '../shared/types';\n\nconsole.log('[Preload Script] Loading...');\n\n// Define the API structure that will be exposed to the renderer\n// This should match the IAppAPI interface defined in shared/types.d.ts\nconst api = {\n  // Example function structure (uncomment and adapt when needed):\n  /*\n  exampleAction: (args: ExampleType): Promise<any> => {\n    console.log('[Preload Script] Calling exampleAction via IPC');\n    return ipcRenderer.invoke(CHANNEL_NAME_EXAMPLE, args);\n  },\n  */\n  // --- Add actual API functions here as features are implemented ---\n\n  // Simple example to confirm preload is working\n  getAppVersion: (): Promise<string> => {\n    console.log('[Preload Script] Requesting app version via IPC');\n    // We'll need to create a handler for this in main.ts later\n    return ipcRenderer.invoke('get-app-version'); // Note: This uses a string literal, should use GET_APP_VERSION constant\n  },\n\n  getProfile: (): Promise<{ name?: string }> => {\n    console.log('[Preload Script] Requesting profile via IPC');\n    return ipcRenderer.invoke(PROFILE_GET);\n  },\n\n  // Add importBookmarks function\n  importBookmarks: (filePath: string): Promise<number> => {\n    console.log('[Preload Script] Invoking bookmarks import via IPC');\n    return ipcRenderer.invoke(BOOKMARKS_IMPORT, filePath);\n  },\n\n  // Add saveTempFile function\n  saveTempFile: (fileName: string, data: Uint8Array): Promise<string> => {\n    console.log('[Preload Script] Invoking save temp file via IPC');\n    // Pass data directly; IPC handles serialization of Uint8Array/Buffer\n    return ipcRenderer.invoke(FILE_SAVE_TEMP, { fileName, data });\n  },\n\n  // Add listener for bookmark progress\n  onBookmarksProgress: (callback: (event: BookmarksProgressEvent) => void) => {\n    console.log('[Preload Script] Setting up listener for', BOOKMARKS_PROGRESS);\n    const listener = (_event: Electron.IpcRendererEvent, event: BookmarksProgressEvent) => {\n      // Basic validation of received data structure could be added here\n      // console.debug('[Preload Script] Received bookmark progress:', event);\n      callback(event);\n    };\n    ipcRenderer.on(BOOKMARKS_PROGRESS, listener);\n    // Return a function to remove this specific listener\n    return () => {\n      console.log('[Preload Script] Removing listener for', BOOKMARKS_PROGRESS);\n      ipcRenderer.removeListener(BOOKMARKS_PROGRESS, listener);\n    };\n  },\n\n  // --- Chat Streaming --- \n  startChatStream: (sessionId: string, question: string): void => {\n    if (!sessionId || !question) {\n        console.error('[Preload Script] startChatStream called with invalid sessionId or question.');\n        return;\n    }\n    console.log(`[Preload Script] Sending CHAT_STREAM_START for session: ${sessionId}, question: \"${question.substring(0,30)}...\"`);\n    ipcRenderer.send(CHAT_STREAM_START, { sessionId, question });\n  },\n\n  stopChatStream: (): void => {\n    console.log(`[Preload Script] Sending CHAT_STREAM_STOP`);\n    ipcRenderer.send(CHAT_STREAM_STOP);\n  },\n\n  // Listener for incoming chat chunks (Main -> Renderer)\n  onChatChunk: (callback: (chunk: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, chunk: string) => callback(chunk);\n    ipcRenderer.on(ON_CHAT_RESPONSE_CHUNK, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_RESPONSE_CHUNK, listener);\n  },\n\n  // Listener for stream end signal (Main -> Renderer)\n  onChatStreamEnd: (callback: (result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => callback(result);\n    ipcRenderer.on(ON_CHAT_STREAM_END, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_END, listener);\n  },\n\n  // Listener for stream error signal (Main -> Renderer)\n  onChatStreamError: (callback: (errorMessage: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, errorMessage: string) => callback(errorMessage);\n    ipcRenderer.on(ON_CHAT_STREAM_ERROR, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_ERROR, listener);\n  },\n\n  // --- End Chat Streaming ---\n\n  // --- Add Chat Message Retrieval ---\n  getMessages: (\n    sessionId: string,\n    limit?: number,\n    beforeTimestamp?: string\n  ): Promise<StructuredChatMessage[]> => {\n    console.log(`[Preload Script] Invoking getMessages for session: ${sessionId}, limit: ${limit}`);\n    return ipcRenderer.invoke(CHAT_GET_MESSAGES, { sessionId, limit, beforeTimestamp });\n  },\n\n  // --- Add Slice Detail Retrieval ---\n  getSliceDetails: (chunkIds: number[]): Promise<SliceDetail[]> => {\n      console.log(`[Preload Script] Invoking getSliceDetails for ${chunkIds.length} IDs: [${chunkIds.slice(0, 5).join(', ')}]...`);\n      // Basic input validation\n      if (!Array.isArray(chunkIds) || chunkIds.some(id => typeof id !== 'number')) {\n          console.error('[Preload Script] getSliceDetails called with invalid input (must be array of numbers).');\n          // Return a rejected promise for invalid input\n          return Promise.reject(new Error('Invalid input: chunkIds must be an array of numbers.'));\n      }\n      return ipcRenderer.invoke(GET_SLICE_DETAILS, chunkIds);\n  },\n\n  // --- Intent Handling ---\n  setIntent: (payload: IntentPayload): Promise<void> => {\n    console.log('[Preload Script] Sending SET_INTENT with payload:', payload.intentText.substring(0, 50) + \"...\");\n    // Assuming setIntent is an invoke call for potential acknowledgement, though void promise suggests send might also be fine.\n    // Sticking to invoke as per plan (Promise<void> can be an ack from handler)\n    return ipcRenderer.invoke(SET_INTENT, payload);\n  },\n\n  onIntentResult: (callback: (result: IntentResultPayload) => void): (() => void) => {\n    console.log('[Preload Script] Setting up listener for ON_INTENT_RESULT');\n    const listener = (_event: Electron.IpcRendererEvent, result: IntentResultPayload) => {\n      // console.debug('[Preload Script] Received intent result:', result);\n      callback(result);\n    };\n    ipcRenderer.on(ON_INTENT_RESULT, listener);\n    return () => {\n      console.log('[Preload Script] Removing listener for ON_INTENT_RESULT');\n      ipcRenderer.removeListener(ON_INTENT_RESULT, listener);\n    };\n  },\n\n  // --- Notebook Functions ---\n  createNotebook: (params: { title: string, description?: string | null }): Promise<NotebookRecord> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_CREATE}`);\n    return ipcRenderer.invoke(NOTEBOOK_CREATE, params);\n  },\n  getNotebookById: (id: string): Promise<NotebookRecord | null> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_BY_ID} for ID: ${id}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_BY_ID, id);\n  },\n  getAllNotebooks: (): Promise<NotebookRecord[]> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_ALL}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_ALL);\n  },\n  updateNotebook: (params: { id: string, data: { title?: string, description?: string | null } }): Promise<NotebookRecord | null> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_UPDATE} for ID: ${params.id}`);\n    return ipcRenderer.invoke(NOTEBOOK_UPDATE, params);\n  },\n  deleteNotebook: (id: string): Promise<boolean> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_DELETE} for ID: ${id}`);\n    return ipcRenderer.invoke(NOTEBOOK_DELETE, id);\n  },\n  getChunksForNotebook: (notebookId: string): Promise<ObjectChunk[]> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_CHUNKS} for notebook ID: ${notebookId}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_CHUNKS, notebookId);\n  },\n\n  // --- Chat Session Functions (within Notebooks) ---\n  createChatInNotebook: (params: { notebookId: string, chatTitle?: string | null }): Promise<IChatSession> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_CREATE_IN_NOTEBOOK} for notebook ID: ${params.notebookId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_CREATE_IN_NOTEBOOK, params);\n  },\n  listChatsForNotebook: (notebookId: string): Promise<IChatSession[]> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_LIST_FOR_NOTEBOOK} for notebook ID: ${notebookId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_LIST_FOR_NOTEBOOK, notebookId);\n  },\n  transferChatToNotebook: (params: { sessionId: string, newNotebookId: string }): Promise<boolean> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_TRANSFER_TO_NOTEBOOK} for session ID: ${params.sessionId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_TRANSFER_TO_NOTEBOOK, params);\n  },\n\n  // --- Zustand Store Persistence --- \n  storeGet: (key: string): Promise<string | null> => {\n    console.log(`[Preload Script] Invoking ${STORE_GET} for key: ${key}`);\n    return ipcRenderer.invoke(STORE_GET, key);\n  },\n  storeSet: (key: string, value: string): Promise<void> => {\n    console.log(`[Preload Script] Invoking ${STORE_SET} for key: ${key}`);\n    return ipcRenderer.invoke(STORE_SET, { key, value });\n  },\n  storeRemove: (key: string): Promise<void> => {\n    console.log(`[Preload Script] Invoking ${STORE_REMOVE} for key: ${key}`);\n    return ipcRenderer.invoke(STORE_REMOVE, key);\n  },\n\n  // Listen for a flush request from the main process\n  onMainRequestFlush: (callback: () => Promise<void>): void => {\n    const listener = async (_event: IpcRendererEvent) => {\n      console.log('[Preload Script] Received MAIN_REQUEST_RENDERER_FLUSH');\n      try {\n        await callback();\n        console.log('[Preload Script] Renderer flush callback completed. Sending RENDERER_FLUSH_COMPLETE.');\n        ipcRenderer.send(RENDERER_FLUSH_COMPLETE);\n      } catch (error) {\n        console.error('[Preload Script] Error during renderer flush callback:', error);\n        // Still send complete, or an error signal? For now, send complete to prevent main from hanging.\n        // Consider adding a RENDERER_FLUSH_ERROR if main needs to know.\n        ipcRenderer.send(RENDERER_FLUSH_COMPLETE); \n      }\n    };\n    ipcRenderer.on(MAIN_REQUEST_RENDERER_FLUSH, listener);\n    // Note: This type of listener typically doesn't return a cleanup function in IAppAPI \n    // because it's a global handler for app lifecycle. If multiple registrations \n    // were possible and needed cleanup, the API would need to change to return () => void.\n  },\n\n  // --- Classic Browser API --- \n  classicBrowserCreate: (windowId: string, bounds: Electron.Rectangle, initialUrl?: string): Promise<{ success: boolean } | undefined> => {\n    console.log(`[Preload Script] Creating ClassicBrowser view ${windowId}`);\n    return ipcRenderer.invoke(CLASSIC_BROWSER_CREATE, { windowId, bounds, initialUrl });\n  },\n\n  classicBrowserLoadUrl: (windowId: string, url: string): Promise<void> => {\n    console.log(`[Preload Script] Invoking classicBrowserLoadUrl for window ${windowId}, url: ${url}`);\n    return ipcRenderer.invoke(CLASSIC_BROWSER_LOAD_URL, { windowId, url });\n  },\n\n  classicBrowserNavigate: (windowId: string, action: 'back' | 'forward' | 'reload' | 'stop', url?: string): Promise<void> => {\n    console.log(`[Preload Script] Invoking classicBrowserNavigate for window ${windowId}, action: ${action}, url: ${url}`);\n    return ipcRenderer.invoke(CLASSIC_BROWSER_NAVIGATE, { windowId, action, url });\n  },\n\n  classicBrowserSetBounds: (windowId: string, bounds: Electron.Rectangle): Promise<void> => {\n    return ipcRenderer.invoke(CLASSIC_BROWSER_SET_BOUNDS, { windowId, bounds });\n  },\n\n  classicBrowserSetVisibility: (windowId: string, isVisible: boolean): Promise<void> => {\n    return ipcRenderer.invoke(CLASSIC_BROWSER_SET_VISIBILITY, { windowId, isVisible });\n  },\n\n  classicBrowserDestroy: (windowId: string): Promise<void> => {\n    console.log(`[Preload Script] Destroying ClassicBrowser view ${windowId}`);\n    return ipcRenderer.invoke(CLASSIC_BROWSER_DESTROY, { windowId });\n  },\n\n  onClassicBrowserState: (callback: (update: { windowId: string, state: Partial<ClassicBrowserPayload> }) => void): (() => void) => {\n    console.log('[Preload Script] Setting up listener for ON_CLASSIC_BROWSER_STATE');\n    const listener = (_event: Electron.IpcRendererEvent, update: { windowId: string, state: Partial<ClassicBrowserPayload> }) => {\n      callback(update);\n    };\n    ipcRenderer.on(ON_CLASSIC_BROWSER_STATE, listener);\n    return () => {\n      console.log('[Preload Script] Removing listener for ON_CLASSIC_BROWSER_STATE');\n      ipcRenderer.removeListener(ON_CLASSIC_BROWSER_STATE, listener);\n    };\n  },\n};\n\n// Securely expose the defined API to the renderer process\ntry {\n  // Use 'satisfies' to check the api object against the interface\n  contextBridge.exposeInMainWorld('api', api satisfies IAppAPI);\n  console.log('[Preload Script] API exposed successfully.');\n} catch (error) {\n  console.error('[Preload Script] Failed to expose API:', error);\n}\n\n// Type definition for the API (to be placed in shared/types.d.ts)\n/*\ndeclare global {\n  interface Window {\n    api: IAppAPI;\n  }\n}\n\nexport interface IAppAPI {\n  // Signatures for the methods exposed above\n  getAppVersion: () => Promise<string>;\n  // exampleAction: (args: ExampleType) => Promise<any>;\n  // ... other method signatures\n}\n*/\n", "// This file defines the string constants used for IPC channel names.\n// Follow naming conventions (e.g., NOUN_VERB or feature:action).\n// Example: export const NOTEBOOK_SAVE = 'notebook:save';\n\n/** Simple channel for renderer to check main process version. */\nexport const GET_APP_VERSION = 'get-app-version';\n\n// Profile channels\n/** Get the current user profile information. */\nexport const PROFILE_GET = 'profile:get';\n\n/** Start the import process for a bookmarks file (HTML/JSON). Expects temp file path. */\nexport const BOOKMARKS_IMPORT = 'bookmarks:import';\n\n// File operations\n/** Save uploaded file data to a temporary location. Expects { fileName, data }. Returns absolute path. */\nexport const FILE_SAVE_TEMP = 'file:saveTemp';\n\n// Bookmark ingestion progress event\n/** Event channel for broadcasting bookmark import progress updates. */\nexport const BOOKMARKS_PROGRESS = 'bookmarks:progress';\n\n// --- Chat Streaming Channels ---\n/** Renderer -> Main: Start a chat stream request with a question. */\nexport const CHAT_STREAM_START = 'chat:stream:start';\n\n/** Renderer -> Main: Request to stop an ongoing chat stream. */\nexport const CHAT_STREAM_STOP = 'chat:stream:stop';\n\n/** Main -> Renderer: Send a chunk of the streaming response. */\nexport const ON_CHAT_RESPONSE_CHUNK = 'chat:onResponseChunk';\n\n/** Main -> Renderer: Signal that the chat stream has ended successfully. */\nexport const ON_CHAT_STREAM_END = 'chat:onStreamEnd';\n\n/** Main -> Renderer: Signal that an error occurred during the chat stream. */\nexport const ON_CHAT_STREAM_ERROR = 'chat:onStreamError';\n\n// --- Add new channel ---\n/** Renderer -> Main: Request to retrieve messages for a specific chat session. */\nexport const CHAT_GET_MESSAGES = 'chat:getMessages';\n\n// --- Add new channel for fetching slice details ---\n/** Renderer -> Main: Request detailed information for specific chunk IDs (returns SliceDetail[]). */\nexport const GET_SLICE_DETAILS = 'slices:getDetails';\n\n// --- Intent Handling Channels ---\n/** Renderer -> Main: Send user's intent from Welcome Page or Command Bar. */\nexport const SET_INTENT = 'intent:set';\n\n/** Main -> Renderer: Send the result/outcome of processing an intent. */\nexport const ON_INTENT_RESULT = 'intent:on-result';\n\n// --- Notebook Operations ---\n/** Renderer -> Main: Create a new notebook. */\nexport const NOTEBOOK_CREATE = 'notebook:create';\n/** Renderer -> Main: Get a notebook by its ID. */\nexport const NOTEBOOK_GET_BY_ID = 'notebook:getById';\n/** Renderer -> Main: Get all notebooks. */\nexport const NOTEBOOK_GET_ALL = 'notebook:getAll';\n/** Renderer -> Main: Update a notebook. */\nexport const NOTEBOOK_UPDATE = 'notebook:update';\n/** Renderer -> Main: Delete a notebook. */\nexport const NOTEBOOK_DELETE = 'notebook:delete';\n/** Renderer -> Main: Get all chunks for a notebook. */\nexport const NOTEBOOK_GET_CHUNKS = 'notebook:getChunks';\n\n// --- Chat Session Operations within Notebooks ---\n/** Renderer -> Main: Create a new chat session in a notebook. */\nexport const CHAT_SESSION_CREATE_IN_NOTEBOOK = 'chatSession:createInNotebook';\n/** Renderer -> Main: List all chat sessions for a notebook. */\nexport const CHAT_SESSION_LIST_FOR_NOTEBOOK = 'chatSession:listForNotebook';\n/** Renderer -> Main: Transfer a chat session to a different notebook. */\nexport const CHAT_SESSION_TRANSFER_TO_NOTEBOOK = 'chatSession:transferToNotebook';\n\n// --- Zustand Store Persistence Channels ---\n/** Renderer -> Main: Get a value from the persistent store. Expects key, returns string or null. */\nexport const STORE_GET = 'store:get';\n/** Renderer -> Main: Set a value in the persistent store. Expects key and string value. */\nexport const STORE_SET = 'store:set';\n/** Renderer -> Main: Remove a value from the persistent store. Expects key. */\nexport const STORE_REMOVE = 'store:remove';\n\n// Add these for flushing stores on quit\nexport const MAIN_REQUEST_RENDERER_FLUSH = 'main:request-renderer-flush';\nexport const RENDERER_FLUSH_COMPLETE = 'renderer:flush-complete';\n\n// --- Classic Browser Channels ---\n/** Renderer -> Main: create and attach a BrowserView */\nexport const CLASSIC_BROWSER_CREATE = 'browser:create';\n/** Renderer -> Main: Request navigation action (back, forward, reload, stop, url) in a classic browser window. */\nexport const CLASSIC_BROWSER_NAVIGATE = 'browser:navigate';\n/** Renderer -> Main: Request to load a specific URL in a classic browser window. */\nexport const CLASSIC_BROWSER_LOAD_URL = 'browser:loadUrl';\n/** Renderer -> Main: Set BrowserView bounds */\nexport const CLASSIC_BROWSER_SET_BOUNDS = 'classic-browser:set-bounds';\n/** Renderer -> Main: Set BrowserView visibility */\nexport const CLASSIC_BROWSER_SET_VISIBILITY = 'classic-browser:set-visibility';\n/** Main -> Renderer: Send state updates for a classic browser window (e.g., URL change, loading status). */\nexport const ON_CLASSIC_BROWSER_STATE = 'browser:onState';\n/** Renderer -> Main: destroy a BrowserView */\nexport const CLASSIC_BROWSER_DESTROY = 'browser:destroy';\n\n// --- Electron Store Persistence Channels ---\n/** Renderer -> Main: Get a value from the persistent store. Expects key, returns string or null. */\n/** Renderer -> Main: Set a value in the persistent store. Expects key and string value. */\n/** Renderer -> Main: Remove a value from the persistent store. Expects key. */\n"],
  "mappings": "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",
  "names": ["import_electron", "PROFILE_GET", "BOOKMARKS_IMPORT", "FILE_SAVE_TEMP", "BOOKMARKS_PROGRESS", "CHAT_STREAM_START", "CHAT_STREAM_STOP", "ON_CHAT_RESPONSE_CHUNK", "ON_CHAT_STREAM_END", "ON_CHAT_STREAM_ERROR", "CHAT_GET_MESSAGES", "GET_SLICE_DETAILS", "SET_INTENT", "ON_INTENT_RESULT", "NOTEBOOK_CREATE", "NOTEBOOK_GET_BY_ID", "NOTEBOOK_GET_ALL", "NOTEBOOK_UPDATE", "NOTEBOOK_DELETE", "NOTEBOOK_GET_CHUNKS", "CHAT_SESSION_CREATE_IN_NOTEBOOK", "CHAT_SESSION_LIST_FOR_NOTEBOOK", "CHAT_SESSION_TRANSFER_TO_NOTEBOOK", "STORE_GET", "STORE_SET", "STORE_REMOVE", "MAIN_REQUEST_RENDERER_FLUSH", "RENDERER_FLUSH_COMPLETE", "CLASSIC_BROWSER_CREATE", "CLASSIC_BROWSER_NAVIGATE", "CLASSIC_BROWSER_LOAD_URL", "CLASSIC_BROWSER_SET_BOUNDS", "CLASSIC_BROWSER_SET_VISIBILITY", "ON_CLASSIC_BROWSER_STATE", "CLASSIC_BROWSER_DESTROY", "api", "PROFILE_GET", "filePath", "BOOKMARKS_IMPORT", "fileName", "data", "FILE_SAVE_TEMP", "callback", "BOOKMARKS_PROGRESS", "listener", "_event", "event", "sessionId", "question", "CHAT_STREAM_START", "CHAT_STREAM_STOP", "chunk", "ON_CHAT_RESPONSE_CHUNK", "result", "ON_CHAT_STREAM_END", "errorMessage", "ON_CHAT_STREAM_ERROR", "limit", "beforeTimestamp", "CHAT_GET_MESSAGES", "chunkIds", "id", "GET_SLICE_DETAILS", "payload", "SET_INTENT", "ON_INTENT_RESULT", "params", "NOTEBOOK_CREATE", "NOTEBOOK_GET_BY_ID", "NOTEBOOK_GET_ALL", "NOTEBOOK_UPDATE", "NOTEBOOK_DELETE", "notebookId", "NOTEBOOK_GET_CHUNKS", "CHAT_SESSION_CREATE_IN_NOTEBOOK", "CHAT_SESSION_LIST_FOR_NOTEBOOK", "CHAT_SESSION_TRANSFER_TO_NOTEBOOK", "key", "STORE_GET", "value", "STORE_SET", "STORE_REMOVE", "RENDERER_FLUSH_COMPLETE", "error", "MAIN_REQUEST_RENDERER_FLUSH", "windowId", "bounds", "initialUrl", "CLASSIC_BROWSER_CREATE", "url", "CLASSIC_BROWSER_LOAD_URL", "action", "CLASSIC_BROWSER_NAVIGATE", "CLASSIC_BROWSER_SET_BOUNDS", "isVisible", "CLASSIC_BROWSER_SET_VISIBILITY", "CLASSIC_BROWSER_DESTROY", "update", "ON_CLASSIC_BROWSER_STATE"]
}
