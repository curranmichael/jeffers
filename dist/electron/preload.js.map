{
  "version": 3,
  "sources": ["../../electron/preload.ts", "../../shared/ipcChannels.ts"],
  "sourcesContent": ["import { contextBridge, ipcRenderer } from 'electron';\nimport {\n  type IpcRendererEvent,\n} from 'electron';\n\n// Import channel constants and types from shared\nimport {\n    PROFILE_GET,\n    BOOKMARKS_IMPORT,\n    FILE_SAVE_TEMP,\n    BOOKMARKS_PROGRESS,\n    CHAT_STREAM_START,\n    CHAT_STREAM_STOP,\n    ON_CHAT_RESPONSE_CHUNK,\n    ON_CHAT_STREAM_END,\n    ON_CHAT_STREAM_ERROR,\n    CHAT_GET_MESSAGES,\n    GET_SLICE_DETAILS,\n    SET_INTENT,\n    ON_INTENT_RESULT,\n    // Notebook and Chat Session channels\n    NOTEBOOK_CREATE,\n    NOTEBOOK_GET_BY_ID,\n    NOTEBOOK_GET_ALL,\n    NOTEBOOK_UPDATE,\n    NOTEBOOK_DELETE,\n    NOTEBOOK_GET_CHUNKS,\n    CHAT_SESSION_CREATE_IN_NOTEBOOK,\n    CHAT_SESSION_LIST_FOR_NOTEBOOK,\n    CHAT_SESSION_TRANSFER_TO_NOTEBOOK,\n} from '../shared/ipcChannels';\n// Import IChatMessage along with other types\nimport {\n  IAppAPI,\n  BookmarksProgressEvent,\n  IChatMessage,\n  SliceDetail,\n  StructuredChatMessage,\n  ChatMessageSourceMetadata,\n  IntentPayload,\n  IntentResultPayload,\n  NotebookRecord,\n  ObjectChunk,\n  IChatSession,\n} from '../shared/types';\n\nconsole.log('[Preload Script] Loading...');\n\n// Define the API structure that will be exposed to the renderer\n// This should match the IAppAPI interface defined in shared/types.d.ts\nconst api = {\n  // Example function structure (uncomment and adapt when needed):\n  /*\n  exampleAction: (args: ExampleType): Promise<any> => {\n    console.log('[Preload Script] Calling exampleAction via IPC');\n    return ipcRenderer.invoke(CHANNEL_NAME_EXAMPLE, args);\n  },\n  */\n  // --- Add actual API functions here as features are implemented ---\n\n  // Simple example to confirm preload is working\n  getAppVersion: (): Promise<string> => {\n    console.log('[Preload Script] Requesting app version via IPC');\n    // We'll need to create a handler for this in main.ts later\n    return ipcRenderer.invoke('get-app-version'); // Note: This uses a string literal, should use GET_APP_VERSION constant\n  },\n\n  getProfile: (): Promise<{ name?: string }> => {\n    console.log('[Preload Script] Requesting profile via IPC');\n    return ipcRenderer.invoke(PROFILE_GET);\n  },\n\n  // Add importBookmarks function\n  importBookmarks: (filePath: string): Promise<number> => {\n    console.log('[Preload Script] Invoking bookmarks import via IPC');\n    return ipcRenderer.invoke(BOOKMARKS_IMPORT, filePath);\n  },\n\n  // Add saveTempFile function\n  saveTempFile: (fileName: string, data: Uint8Array): Promise<string> => {\n    console.log('[Preload Script] Invoking save temp file via IPC');\n    // Pass data directly; IPC handles serialization of Uint8Array/Buffer\n    return ipcRenderer.invoke(FILE_SAVE_TEMP, { fileName, data });\n  },\n\n  // Add listener for bookmark progress\n  onBookmarksProgress: (callback: (event: BookmarksProgressEvent) => void) => {\n    console.log('[Preload Script] Setting up listener for', BOOKMARKS_PROGRESS);\n    const listener = (_event: Electron.IpcRendererEvent, event: BookmarksProgressEvent) => {\n      // Basic validation of received data structure could be added here\n      // console.debug('[Preload Script] Received bookmark progress:', event);\n      callback(event);\n    };\n    ipcRenderer.on(BOOKMARKS_PROGRESS, listener);\n    // Return a function to remove this specific listener\n    return () => {\n      console.log('[Preload Script] Removing listener for', BOOKMARKS_PROGRESS);\n      ipcRenderer.removeListener(BOOKMARKS_PROGRESS, listener);\n    };\n  },\n\n  // --- Chat Streaming --- \n  startChatStream: (sessionId: string, question: string): void => {\n    if (!sessionId || !question) {\n        console.error('[Preload Script] startChatStream called with invalid sessionId or question.');\n        return;\n    }\n    console.log(`[Preload Script] Sending CHAT_STREAM_START for session: ${sessionId}, question: \"${question.substring(0,30)}...\"`);\n    ipcRenderer.send(CHAT_STREAM_START, { sessionId, question });\n  },\n\n  stopChatStream: (): void => {\n    console.log(`[Preload Script] Sending CHAT_STREAM_STOP`);\n    ipcRenderer.send(CHAT_STREAM_STOP);\n  },\n\n  // Listener for incoming chat chunks (Main -> Renderer)\n  onChatChunk: (callback: (chunk: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, chunk: string) => callback(chunk);\n    ipcRenderer.on(ON_CHAT_RESPONSE_CHUNK, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_RESPONSE_CHUNK, listener);\n  },\n\n  // Listener for stream end signal (Main -> Renderer)\n  onChatStreamEnd: (callback: (result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => callback(result);\n    ipcRenderer.on(ON_CHAT_STREAM_END, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_END, listener);\n  },\n\n  // Listener for stream error signal (Main -> Renderer)\n  onChatStreamError: (callback: (errorMessage: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, errorMessage: string) => callback(errorMessage);\n    ipcRenderer.on(ON_CHAT_STREAM_ERROR, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_ERROR, listener);\n  },\n\n  // --- End Chat Streaming ---\n\n  // --- Add Chat Message Retrieval ---\n  getMessages: (\n    sessionId: string,\n    limit?: number,\n    beforeTimestamp?: string\n  ): Promise<StructuredChatMessage[]> => {\n    console.log(`[Preload Script] Invoking getMessages for session: ${sessionId}, limit: ${limit}`);\n    return ipcRenderer.invoke(CHAT_GET_MESSAGES, { sessionId, limit, beforeTimestamp });\n  },\n\n  // --- Add Slice Detail Retrieval ---\n  getSliceDetails: (chunkIds: number[]): Promise<SliceDetail[]> => {\n      console.log(`[Preload Script] Invoking getSliceDetails for ${chunkIds.length} IDs: [${chunkIds.slice(0, 5).join(', ')}]...`);\n      // Basic input validation\n      if (!Array.isArray(chunkIds) || chunkIds.some(id => typeof id !== 'number')) {\n          console.error('[Preload Script] getSliceDetails called with invalid input (must be array of numbers).');\n          // Return a rejected promise for invalid input\n          return Promise.reject(new Error('Invalid input: chunkIds must be an array of numbers.'));\n      }\n      return ipcRenderer.invoke(GET_SLICE_DETAILS, chunkIds);\n  },\n\n  // --- Intent Handling ---\n  setIntent: (payload: IntentPayload): Promise<void> => {\n    console.log('[Preload Script] Sending SET_INTENT with payload:', payload.intentText.substring(0, 50) + \"...\");\n    // Assuming setIntent is an invoke call for potential acknowledgement, though void promise suggests send might also be fine.\n    // Sticking to invoke as per plan (Promise<void> can be an ack from handler)\n    return ipcRenderer.invoke(SET_INTENT, payload);\n  },\n\n  onIntentResult: (callback: (result: IntentResultPayload) => void): (() => void) => {\n    console.log('[Preload Script] Setting up listener for ON_INTENT_RESULT');\n    const listener = (_event: Electron.IpcRendererEvent, result: IntentResultPayload) => {\n      // console.debug('[Preload Script] Received intent result:', result);\n      callback(result);\n    };\n    ipcRenderer.on(ON_INTENT_RESULT, listener);\n    return () => {\n      console.log('[Preload Script] Removing listener for ON_INTENT_RESULT');\n      ipcRenderer.removeListener(ON_INTENT_RESULT, listener);\n    };\n  },\n\n  // --- Notebook Functions ---\n  createNotebook: (params: { title: string, description?: string | null }): Promise<NotebookRecord> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_CREATE}`);\n    return ipcRenderer.invoke(NOTEBOOK_CREATE, params);\n  },\n  getNotebookById: (id: string): Promise<NotebookRecord | null> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_BY_ID} for ID: ${id}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_BY_ID, id);\n  },\n  getAllNotebooks: (): Promise<NotebookRecord[]> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_ALL}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_ALL);\n  },\n  updateNotebook: (params: { id: string, data: { title?: string, description?: string | null } }): Promise<NotebookRecord | null> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_UPDATE} for ID: ${params.id}`);\n    return ipcRenderer.invoke(NOTEBOOK_UPDATE, params);\n  },\n  deleteNotebook: (id: string): Promise<boolean> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_DELETE} for ID: ${id}`);\n    return ipcRenderer.invoke(NOTEBOOK_DELETE, id);\n  },\n  getChunksForNotebook: (notebookId: string): Promise<ObjectChunk[]> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_CHUNKS} for notebook ID: ${notebookId}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_CHUNKS, notebookId);\n  },\n\n  // --- Chat Session Functions (within Notebooks) ---\n  createChatInNotebook: (params: { notebookId: string, chatTitle?: string | null }): Promise<IChatSession> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_CREATE_IN_NOTEBOOK} for notebook ID: ${params.notebookId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_CREATE_IN_NOTEBOOK, params);\n  },\n  listChatsForNotebook: (notebookId: string): Promise<IChatSession[]> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_LIST_FOR_NOTEBOOK} for notebook ID: ${notebookId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_LIST_FOR_NOTEBOOK, notebookId);\n  },\n  transferChatToNotebook: (params: { sessionId: string, newNotebookId: string }): Promise<boolean> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_TRANSFER_TO_NOTEBOOK} for session ID: ${params.sessionId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_TRANSFER_TO_NOTEBOOK, params);\n  },\n};\n\n// Securely expose the defined API to the renderer process\ntry {\n  // Use 'satisfies' to check the api object against the interface\n  contextBridge.exposeInMainWorld('api', api satisfies IAppAPI);\n  console.log('[Preload Script] API exposed successfully.');\n} catch (error) {\n  console.error('[Preload Script] Failed to expose API:', error);\n}\n\n// Type definition for the API (to be placed in shared/types.d.ts)\n/*\ndeclare global {\n  interface Window {\n    api: IAppAPI;\n  }\n}\n\nexport interface IAppAPI {\n  // Signatures for the methods exposed above\n  getAppVersion: () => Promise<string>;\n  // exampleAction: (args: ExampleType) => Promise<any>;\n  // ... other method signatures\n}\n*/\n", "// This file defines the string constants used for IPC channel names.\n// Follow naming conventions (e.g., NOUN_VERB or feature:action).\n// Example: export const NOTEBOOK_SAVE = 'notebook:save';\n\n/** Simple channel for renderer to check main process version. */\nexport const GET_APP_VERSION = 'get-app-version';\n\n// Profile channels\n/** Get the current user profile information. */\nexport const PROFILE_GET = 'profile:get';\n\n/** Start the import process for a bookmarks file (HTML/JSON). Expects temp file path. */\nexport const BOOKMARKS_IMPORT = 'bookmarks:import';\n\n// File operations\n/** Save uploaded file data to a temporary location. Expects { fileName, data }. Returns absolute path. */\nexport const FILE_SAVE_TEMP = 'file:saveTemp';\n\n// Bookmark ingestion progress event\n/** Event channel for broadcasting bookmark import progress updates. */\nexport const BOOKMARKS_PROGRESS = 'bookmarks:progress';\n\n// --- Chat Streaming Channels ---\n/** Renderer -> Main: Start a chat stream request with a question. */\nexport const CHAT_STREAM_START = 'chat:stream:start';\n\n/** Renderer -> Main: Request to stop an ongoing chat stream. */\nexport const CHAT_STREAM_STOP = 'chat:stream:stop';\n\n/** Main -> Renderer: Send a chunk of the streaming response. */\nexport const ON_CHAT_RESPONSE_CHUNK = 'chat:onResponseChunk';\n\n/** Main -> Renderer: Signal that the chat stream has ended successfully. */\nexport const ON_CHAT_STREAM_END = 'chat:onStreamEnd';\n\n/** Main -> Renderer: Signal that an error occurred during the chat stream. */\nexport const ON_CHAT_STREAM_ERROR = 'chat:onStreamError';\n\n// --- Add new channel ---\n/** Renderer -> Main: Request to retrieve messages for a specific chat session. */\nexport const CHAT_GET_MESSAGES = 'chat:getMessages';\n\n// --- Add new channel for fetching slice details ---\n/** Renderer -> Main: Request detailed information for specific chunk IDs (returns SliceDetail[]). */\nexport const GET_SLICE_DETAILS = 'slices:getDetails';\n\n// --- Intent Handling Channels ---\n/** Renderer -> Main: Send user's intent from Welcome Page or Command Bar. */\nexport const SET_INTENT = 'intent:set';\n\n/** Main -> Renderer: Send the result/outcome of processing an intent. */\nexport const ON_INTENT_RESULT = 'intent:on-result';\n\n// --- Notebook Operations ---\n/** Renderer -> Main: Create a new notebook. */\nexport const NOTEBOOK_CREATE = 'notebook:create';\n/** Renderer -> Main: Get a notebook by its ID. */\nexport const NOTEBOOK_GET_BY_ID = 'notebook:getById';\n/** Renderer -> Main: Get all notebooks. */\nexport const NOTEBOOK_GET_ALL = 'notebook:getAll';\n/** Renderer -> Main: Update a notebook. */\nexport const NOTEBOOK_UPDATE = 'notebook:update';\n/** Renderer -> Main: Delete a notebook. */\nexport const NOTEBOOK_DELETE = 'notebook:delete';\n/** Renderer -> Main: Get all chunks for a notebook. */\nexport const NOTEBOOK_GET_CHUNKS = 'notebook:getChunks';\n\n// --- Chat Session Operations within Notebooks ---\n/** Renderer -> Main: Create a new chat session in a notebook. */\nexport const CHAT_SESSION_CREATE_IN_NOTEBOOK = 'chatSession:createInNotebook';\n/** Renderer -> Main: List all chat sessions for a notebook. */\nexport const CHAT_SESSION_LIST_FOR_NOTEBOOK = 'chatSession:listForNotebook';\n/** Renderer -> Main: Transfer a chat session to a different notebook. */\nexport const CHAT_SESSION_TRANSFER_TO_NOTEBOOK = 'chatSession:transferToNotebook';\n"],
  "mappings": "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",
  "names": ["import_electron", "PROFILE_GET", "BOOKMARKS_IMPORT", "FILE_SAVE_TEMP", "BOOKMARKS_PROGRESS", "CHAT_STREAM_START", "CHAT_STREAM_STOP", "ON_CHAT_RESPONSE_CHUNK", "ON_CHAT_STREAM_END", "ON_CHAT_STREAM_ERROR", "CHAT_GET_MESSAGES", "GET_SLICE_DETAILS", "SET_INTENT", "ON_INTENT_RESULT", "NOTEBOOK_CREATE", "NOTEBOOK_GET_BY_ID", "NOTEBOOK_GET_ALL", "NOTEBOOK_UPDATE", "NOTEBOOK_DELETE", "NOTEBOOK_GET_CHUNKS", "CHAT_SESSION_CREATE_IN_NOTEBOOK", "CHAT_SESSION_LIST_FOR_NOTEBOOK", "CHAT_SESSION_TRANSFER_TO_NOTEBOOK", "api", "PROFILE_GET", "filePath", "BOOKMARKS_IMPORT", "fileName", "data", "FILE_SAVE_TEMP", "callback", "BOOKMARKS_PROGRESS", "listener", "_event", "event", "sessionId", "question", "CHAT_STREAM_START", "CHAT_STREAM_STOP", "chunk", "ON_CHAT_RESPONSE_CHUNK", "result", "ON_CHAT_STREAM_END", "errorMessage", "ON_CHAT_STREAM_ERROR", "limit", "beforeTimestamp", "CHAT_GET_MESSAGES", "chunkIds", "id", "GET_SLICE_DETAILS", "payload", "SET_INTENT", "ON_INTENT_RESULT", "params", "NOTEBOOK_CREATE", "NOTEBOOK_GET_BY_ID", "NOTEBOOK_GET_ALL", "NOTEBOOK_UPDATE", "NOTEBOOK_DELETE", "notebookId", "NOTEBOOK_GET_CHUNKS", "CHAT_SESSION_CREATE_IN_NOTEBOOK", "CHAT_SESSION_LIST_FOR_NOTEBOOK", "CHAT_SESSION_TRANSFER_TO_NOTEBOOK", "error"]
}
