{
  "version": 3,
  "sources": ["../../electron/preload.ts", "../../shared/ipcChannels.ts"],
  "sourcesContent": ["import { contextBridge, ipcRenderer } from 'electron';\nimport {\n  type IpcRendererEvent,\n} from 'electron';\n\n// Import channel constants and types from shared\nimport {\n    PROFILE_GET,\n    PROFILE_UPDATE,\n    ACTIVITY_LOG_ADD,\n    BOOKMARKS_IMPORT,\n    FILE_SAVE_TEMP,\n    BOOKMARKS_PROGRESS,\n    CHAT_STREAM_START,\n    CHAT_STREAM_STOP,\n    ON_CHAT_RESPONSE_CHUNK,\n    ON_CHAT_STREAM_END,\n    ON_CHAT_STREAM_ERROR,\n    CHAT_GET_MESSAGES,\n    GET_SLICE_DETAILS,\n    SET_INTENT,\n    ON_INTENT_RESULT,\n    // Notebook and Chat Session channels\n    NOTEBOOK_CREATE,\n    NOTEBOOK_GET_BY_ID,\n    NOTEBOOK_GET_ALL,\n    NOTEBOOK_UPDATE,\n    NOTEBOOK_DELETE,\n    NOTEBOOK_GET_CHUNKS,\n    CHAT_SESSION_CREATE_IN_NOTEBOOK,\n    CHAT_SESSION_LIST_FOR_NOTEBOOK,\n    CHAT_SESSION_TRANSFER_TO_NOTEBOOK,\n    // Store persistence channels\n    STORE_GET,\n    STORE_SET,\n    STORE_REMOVE,\n    // Add new channels for flushing\n    MAIN_REQUEST_RENDERER_FLUSH,\n    RENDERER_FLUSH_COMPLETE,\n    // Updated Classic Browser channel imports\n    CLASSIC_BROWSER_CREATE, // Renamed from CLASSIC_BROWSER_INIT_VIEW\n    CLASSIC_BROWSER_NAVIGATE,\n    CLASSIC_BROWSER_SET_BOUNDS, // New\n    CLASSIC_BROWSER_SET_VISIBILITY, // New\n    ON_CLASSIC_BROWSER_STATE, // Renamed from ON_CLASSIC_BROWSER_STATE_UPDATE\n    CLASSIC_BROWSER_DESTROY,\n    CLASSIC_BROWSER_LOAD_URL, // Added new channel\n    CLASSIC_BROWSER_VIEW_FOCUSED, // Import the new channel\n    CLASSIC_BROWSER_REQUEST_FOCUS, // Import the new channel\n    // To-Do channels\n    TODO_CREATE,\n    TODO_GET_ALL,\n    TODO_GET_BY_ID,\n    TODO_UPDATE,\n    TODO_DELETE,\n} from '../shared/ipcChannels';\n// Import IChatMessage along with other types\nimport {\n  IAppAPI,\n  BookmarksProgressEvent,\n  IChatMessage,\n  SliceDetail,\n  StructuredChatMessage,\n  ChatMessageSourceMetadata,\n  SetIntentPayload,\n  IntentResultPayload,\n  NotebookRecord,\n  ObjectChunk,\n  IChatSession,\n  ClassicBrowserPayload,\n  UserProfile,\n  UserProfileUpdatePayload,\n  ActivityLogPayload,\n  ToDoItem,\n  ToDoCreatePayload,\n  ToDoUpdatePayload,\n} from '../shared/types';\n\nconsole.log('[Preload Script] Loading...');\n\n// Define the API structure that will be exposed to the renderer\n// This should match the IAppAPI interface defined in shared/types.d.ts\nconst api = {\n  // Example function structure (uncomment and adapt when needed):\n  /*\n  exampleAction: (args: ExampleType): Promise<any> => {\n    console.log('[Preload Script] Calling exampleAction via IPC');\n    return ipcRenderer.invoke(CHANNEL_NAME_EXAMPLE, args);\n  },\n  */\n  // --- Add actual API functions here as features are implemented ---\n\n  // Simple example to confirm preload is working\n  getAppVersion: (): Promise<string> => {\n    console.log('[Preload Script] Requesting app version via IPC');\n    // We'll need to create a handler for this in main.ts later\n    return ipcRenderer.invoke('get-app-version'); // Note: This uses a string literal, should use GET_APP_VERSION constant\n  },\n\n  getProfile: (): Promise<UserProfile> => {\n    console.log('[Preload Script] Requesting profile via IPC');\n    return ipcRenderer.invoke(PROFILE_GET);\n  },\n\n  updateProfile: (payload: UserProfileUpdatePayload): Promise<UserProfile> => {\n    console.log('[Preload Script] Updating profile via IPC');\n    return ipcRenderer.invoke(PROFILE_UPDATE, payload);\n  },\n\n  logActivity: (payload: ActivityLogPayload): Promise<void> => {\n    console.log('[Preload Script] Logging activity via IPC');\n    return ipcRenderer.invoke(ACTIVITY_LOG_ADD, payload);\n  },\n\n  // Add importBookmarks function\n  importBookmarks: (filePath: string): Promise<number> => {\n    console.log('[Preload Script] Invoking bookmarks import via IPC');\n    return ipcRenderer.invoke(BOOKMARKS_IMPORT, filePath);\n  },\n\n  // Add saveTempFile function\n  saveTempFile: (fileName: string, data: Uint8Array): Promise<string> => {\n    console.log('[Preload Script] Invoking save temp file via IPC');\n    // Pass data directly; IPC handles serialization of Uint8Array/Buffer\n    return ipcRenderer.invoke(FILE_SAVE_TEMP, { fileName, data });\n  },\n\n  // Add listener for bookmark progress\n  onBookmarksProgress: (callback: (event: BookmarksProgressEvent) => void) => {\n    console.log('[Preload Script] Setting up listener for', BOOKMARKS_PROGRESS);\n    const listener = (_event: Electron.IpcRendererEvent, event: BookmarksProgressEvent) => {\n      // Basic validation of received data structure could be added here\n      // console.debug('[Preload Script] Received bookmark progress:', event);\n      callback(event);\n    };\n    ipcRenderer.on(BOOKMARKS_PROGRESS, listener);\n    // Return a function to remove this specific listener\n    return () => {\n      console.log('[Preload Script] Removing listener for', BOOKMARKS_PROGRESS);\n      ipcRenderer.removeListener(BOOKMARKS_PROGRESS, listener);\n    };\n  },\n\n  // --- Chat Streaming --- \n  startChatStream: (payload: { notebookId: string, sessionId: string, question: string }): void => {\n    const { notebookId, sessionId, question } = payload;\n    if (!notebookId || !sessionId || !question) {\n        console.error('[Preload Script] startChatStream called with invalid payload.', payload);\n        return;\n    }\n    console.log(`[Preload Script] Sending CHAT_STREAM_START for notebook: ${notebookId}, session: ${sessionId}, question: \"${question.substring(0,30)}...\"`);\n    ipcRenderer.send(CHAT_STREAM_START, payload); // Send the whole payload object\n  },\n\n  stopChatStream: (): void => {\n    console.log(`[Preload Script] Sending CHAT_STREAM_STOP`);\n    ipcRenderer.send(CHAT_STREAM_STOP);\n  },\n\n  // Listener for incoming chat chunks (Main -> Renderer)\n  onChatChunk: (callback: (chunk: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, chunk: string) => callback(chunk);\n    ipcRenderer.on(ON_CHAT_RESPONSE_CHUNK, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_RESPONSE_CHUNK, listener);\n  },\n\n  // Listener for stream end signal (Main -> Renderer)\n  onChatStreamEnd: (callback: (result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => callback(result);\n    ipcRenderer.on(ON_CHAT_STREAM_END, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_END, listener);\n  },\n\n  // Listener for stream error signal (Main -> Renderer)\n  onChatStreamError: (callback: (errorMessage: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, errorMessage: string) => callback(errorMessage);\n    ipcRenderer.on(ON_CHAT_STREAM_ERROR, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_ERROR, listener);\n  },\n\n  // --- End Chat Streaming ---\n\n  // --- Add Chat Message Retrieval ---\n  getMessages: (\n    sessionId: string,\n    limit?: number,\n    beforeTimestamp?: string\n  ): Promise<StructuredChatMessage[]> => {\n    console.log(`[Preload Script] Invoking getMessages for session: ${sessionId}, limit: ${limit}`);\n    return ipcRenderer.invoke(CHAT_GET_MESSAGES, { sessionId, limit, beforeTimestamp });\n  },\n\n  // --- Add Slice Detail Retrieval ---\n  getSliceDetails: (chunkIds: number[]): Promise<SliceDetail[]> => {\n      console.log(`[Preload Script] Invoking getSliceDetails for ${chunkIds.length} IDs: [${chunkIds.slice(0, 5).join(', ')}]...`);\n      // Basic input validation\n      if (!Array.isArray(chunkIds) || chunkIds.some(id => typeof id !== 'number')) {\n          console.error('[Preload Script] getSliceDetails called with invalid input (must be array of numbers).');\n          // Return a rejected promise for invalid input\n          return Promise.reject(new Error('Invalid input: chunkIds must be an array of numbers.'));\n      }\n      return ipcRenderer.invoke(GET_SLICE_DETAILS, chunkIds);\n  },\n\n  // --- Intent Handling ---\n  setIntent: (payload: SetIntentPayload): Promise<void> => {\n    console.log('[Preload Script] Sending SET_INTENT with payload:', payload.intentText.substring(0, 50) + \"...\");\n    // Assuming setIntent is an invoke call for potential acknowledgement, though void promise suggests send might also be fine.\n    // Sticking to invoke as per plan (Promise<void> can be an ack from handler)\n    return ipcRenderer.invoke(SET_INTENT, payload);\n  },\n\n  onIntentResult: (callback: (result: IntentResultPayload) => void): (() => void) => {\n    console.log('[Preload Script] Setting up listener for ON_INTENT_RESULT');\n    const listener = (_event: Electron.IpcRendererEvent, result: IntentResultPayload) => {\n      // console.debug('[Preload Script] Received intent result:', result);\n      callback(result);\n    };\n    ipcRenderer.on(ON_INTENT_RESULT, listener);\n    return () => {\n      console.log('[Preload Script] Removing listener for ON_INTENT_RESULT');\n      ipcRenderer.removeListener(ON_INTENT_RESULT, listener);\n    };\n  },\n\n  // --- Notebook Functions ---\n  createNotebook: (params: { title: string, description?: string | null }): Promise<NotebookRecord> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_CREATE}`);\n    return ipcRenderer.invoke(NOTEBOOK_CREATE, params);\n  },\n  getNotebookById: (id: string): Promise<NotebookRecord | null> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_BY_ID} for ID: ${id}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_BY_ID, id);\n  },\n  getAllNotebooks: (): Promise<NotebookRecord[]> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_ALL}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_ALL);\n  },\n  updateNotebook: (params: { id: string, data: { title?: string, description?: string | null } }): Promise<NotebookRecord | null> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_UPDATE} for ID: ${params.id}`);\n    return ipcRenderer.invoke(NOTEBOOK_UPDATE, params);\n  },\n  deleteNotebook: (id: string): Promise<boolean> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_DELETE} for ID: ${id}`);\n    return ipcRenderer.invoke(NOTEBOOK_DELETE, id);\n  },\n  getChunksForNotebook: (notebookId: string): Promise<ObjectChunk[]> => {\n    console.log(`[Preload Script] Invoking ${NOTEBOOK_GET_CHUNKS} for notebook ID: ${notebookId}`);\n    return ipcRenderer.invoke(NOTEBOOK_GET_CHUNKS, notebookId);\n  },\n\n  // --- Chat Session Functions (within Notebooks) ---\n  createChatInNotebook: (params: { notebookId: string, chatTitle?: string | null }): Promise<IChatSession> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_CREATE_IN_NOTEBOOK} for notebook ID: ${params.notebookId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_CREATE_IN_NOTEBOOK, params);\n  },\n  listChatsForNotebook: (notebookId: string): Promise<IChatSession[]> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_LIST_FOR_NOTEBOOK} for notebook ID: ${notebookId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_LIST_FOR_NOTEBOOK, notebookId);\n  },\n  transferChatToNotebook: (params: { sessionId: string, newNotebookId: string }): Promise<boolean> => {\n    console.log(`[Preload Script] Invoking ${CHAT_SESSION_TRANSFER_TO_NOTEBOOK} for session ID: ${params.sessionId}`);\n    return ipcRenderer.invoke(CHAT_SESSION_TRANSFER_TO_NOTEBOOK, params);\n  },\n\n  // --- Zustand Store Persistence --- \n  storeGet: (key: string): Promise<string | null> => {\n    console.log(`[Preload Script] Invoking ${STORE_GET} for key: ${key}`);\n    return ipcRenderer.invoke(STORE_GET, key);\n  },\n  storeSet: (key: string, value: string): Promise<void> => {\n    console.log(`[Preload Script] Invoking ${STORE_SET} for key: ${key}`);\n    return ipcRenderer.invoke(STORE_SET, { key, value });\n  },\n  storeRemove: (key: string): Promise<void> => {\n    console.log(`[Preload Script] Invoking ${STORE_REMOVE} for key: ${key}`);\n    return ipcRenderer.invoke(STORE_REMOVE, key);\n  },\n\n  // Listen for a flush request from the main process\n  onMainRequestFlush: (callback: () => Promise<void>): void => {\n    const listener = async (_event: IpcRendererEvent) => {\n      console.log('[Preload Script] Received MAIN_REQUEST_RENDERER_FLUSH');\n      try {\n        await callback();\n        console.log('[Preload Script] Renderer flush callback completed. Sending RENDERER_FLUSH_COMPLETE.');\n        ipcRenderer.send(RENDERER_FLUSH_COMPLETE);\n      } catch (error) {\n        console.error('[Preload Script] Error during renderer flush callback:', error);\n        // Still send complete, or an error signal? For now, send complete to prevent main from hanging.\n        // Consider adding a RENDERER_FLUSH_ERROR if main needs to know.\n        ipcRenderer.send(RENDERER_FLUSH_COMPLETE); \n      }\n    };\n    ipcRenderer.on(MAIN_REQUEST_RENDERER_FLUSH, listener);\n    // Note: This type of listener typically doesn't return a cleanup function in IAppAPI \n    // because it's a global handler for app lifecycle. If multiple registrations \n    // were possible and needed cleanup, the API would need to change to return () => void.\n  },\n\n  // --- Classic Browser API --- \n  classicBrowserCreate: (windowId: string, bounds: Electron.Rectangle, initialUrl: string): Promise<{ success: boolean } | undefined> =>\n    ipcRenderer.invoke(CLASSIC_BROWSER_CREATE, windowId, bounds, initialUrl),\n\n  classicBrowserLoadUrl: (windowId: string, url: string): Promise<void> =>\n    ipcRenderer.invoke(CLASSIC_BROWSER_LOAD_URL, windowId, url),\n\n  classicBrowserNavigate: (windowId: string, action: 'back' | 'forward' | 'reload' | 'stop'): Promise<void> =>\n    ipcRenderer.invoke(CLASSIC_BROWSER_NAVIGATE, windowId, action),\n\n  classicBrowserSetBounds: (windowId: string, bounds: Electron.Rectangle): void => {\n    ipcRenderer.send(CLASSIC_BROWSER_SET_BOUNDS, windowId, bounds);\n  },\n\n  classicBrowserSetVisibility: (windowId: string, shouldBeDrawn: boolean, isFocused: boolean): void => {\n    ipcRenderer.send(CLASSIC_BROWSER_SET_VISIBILITY, windowId, shouldBeDrawn, isFocused);\n  },\n\n  classicBrowserDestroy: (windowId: string): Promise<void> =>\n    ipcRenderer.invoke(CLASSIC_BROWSER_DESTROY, windowId),\n\n  onClassicBrowserState: (callback: (update: { windowId: string; state: Partial<ClassicBrowserPayload> }) => void): (() => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, update: { windowId: string; state: Partial<ClassicBrowserPayload> }) => callback(update);\n    ipcRenderer.on(ON_CLASSIC_BROWSER_STATE, listener);\n    return () => {\n      ipcRenderer.removeListener(ON_CLASSIC_BROWSER_STATE, listener);\n    };\n  },\n\n  // New method to subscribe to WebContentsView focus events\n  onClassicBrowserViewFocused: (callback: (data: { windowId: string }) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, data: { windowId: string }) => callback(data);\n    ipcRenderer.on(CLASSIC_BROWSER_VIEW_FOCUSED, listener);\n    return () => ipcRenderer.removeListener(CLASSIC_BROWSER_VIEW_FOCUSED, listener);\n  },\n\n  classicBrowserRequestFocus: (windowId: string): void => {\n    console.log(`[Preload Script] Sending ${CLASSIC_BROWSER_REQUEST_FOCUS} for windowId: ${windowId}`);\n    ipcRenderer.send(CLASSIC_BROWSER_REQUEST_FOCUS, windowId);\n  },\n\n  // --- To-Do Operations ---\n  createToDo: (payload: ToDoCreatePayload): Promise<ToDoItem> => {\n    console.log('[Preload Script] Creating todo via IPC');\n    return ipcRenderer.invoke(TODO_CREATE, payload);\n  },\n\n  getToDos: (userId?: string): Promise<ToDoItem[]> => {\n    console.log('[Preload Script] Getting todos via IPC');\n    return ipcRenderer.invoke(TODO_GET_ALL, userId);\n  },\n\n  getToDoById: (id: string): Promise<ToDoItem | null> => {\n    console.log('[Preload Script] Getting todo by ID via IPC');\n    return ipcRenderer.invoke(TODO_GET_BY_ID, id);\n  },\n\n  updateToDo: (id: string, payload: ToDoUpdatePayload): Promise<ToDoItem | null> => {\n    console.log('[Preload Script] Updating todo via IPC');\n    return ipcRenderer.invoke(TODO_UPDATE, { id, payload });\n  },\n\n  deleteToDo: (id: string): Promise<boolean> => {\n    console.log('[Preload Script] Deleting todo via IPC');\n    return ipcRenderer.invoke(TODO_DELETE, id);\n  },\n\n  // --- Debug Functions (Development Only) ---\n  ...(process.env.NODE_ENV !== 'production' ? {\n    getFullProfile: (userId: string = 'default_user'): Promise<any> => {\n      console.log('[Preload Script] Getting full profile via IPC (debug)');\n      return ipcRenderer.invoke('debug:getFullProfile', userId);\n    },\n\n    getRecentActivities: (hoursAgo: number = 24): Promise<any[]> => {\n      console.log('[Preload Script] Getting recent activities via IPC (debug)');\n      return ipcRenderer.invoke('debug:getRecentActivities', hoursAgo);\n    },\n\n    forceSynthesis: (synthesisType: 'activities' | 'content' | 'both' = 'both'): Promise<{ success: boolean; message: string }> => {\n      console.log('[Preload Script] Forcing synthesis via IPC (debug)');\n      return ipcRenderer.invoke('debug:forceSynthesis', synthesisType);\n    },\n\n    getSynthesisState: (): Promise<any> => {\n      console.log('[Preload Script] Getting synthesis state via IPC (debug)');\n      return ipcRenderer.invoke('debug:getSynthesisState');\n    },\n\n    clearProfile: (): Promise<{ success: boolean; message: string }> => {\n      console.log('[Preload Script] Clearing profile via IPC (debug)');\n      return ipcRenderer.invoke('debug:clearProfile');\n    },\n  } : {}),\n};\n\n// Securely expose the defined API to the renderer process\ntry {\n  // Use 'satisfies' to check the api object against the interface\n  contextBridge.exposeInMainWorld('api', api satisfies IAppAPI);\n  console.log('[Preload Script] API exposed successfully.');\n} catch (error) {\n  console.error('[Preload Script] Failed to expose API:', error);\n}\n\n// Debug API exposed on window.electron (not window.api)\nif (process.env.NODE_ENV !== 'production') {\n  const electronDebugApi = {\n    getProfile: api.getProfile,\n    getFullProfile: (api as any).getFullProfile,\n    getRecentActivities: (api as any).getRecentActivities,\n    forceSynthesis: (api as any).forceSynthesis,\n    getSynthesisState: (api as any).getSynthesisState,\n    clearProfile: (api as any).clearProfile,\n  };\n\n  try {\n    contextBridge.exposeInMainWorld('electron', electronDebugApi);\n    console.log('[Preload Script] Debug API exposed on window.electron');\n  } catch (error) {\n    console.error('[Preload Script] Failed to expose debug API:', error);\n  }\n}\n", "// This file defines the string constants used for IPC channel names.\n// Follow naming conventions (e.g., NOUN_VERB or feature:action).\n// Example: export const NOTEBOOK_SAVE = 'notebook:save';\n\n/** Simple channel for renderer to check main process version. */\nexport const GET_APP_VERSION = 'get-app-version';\n\n// Profile channels\n/** Get the current user profile information. */\nexport const PROFILE_GET = 'profile:get';\n/** Update the user profile information. */\nexport const PROFILE_UPDATE = 'profile:update';\n\n// Activity logging channels\n/** Log a user activity. */\nexport const ACTIVITY_LOG_ADD = 'activity:log:add';\n\n/** Start the import process for a bookmarks file (HTML/JSON). Expects temp file path. */\nexport const BOOKMARKS_IMPORT = 'bookmarks:import';\n\n// File operations\n/** Save uploaded file data to a temporary location. Expects { fileName, data }. Returns absolute path. */\nexport const FILE_SAVE_TEMP = 'file:saveTemp';\n\n// Bookmark ingestion progress event\n/** Event channel for broadcasting bookmark import progress updates. */\nexport const BOOKMARKS_PROGRESS = 'bookmarks:progress';\n\n// --- Chat Streaming Channels ---\n/** Renderer -> Main: Start a chat stream request with a question. */\nexport const CHAT_STREAM_START = 'chat:stream:start';\n\n/** Renderer -> Main: Request to stop an ongoing chat stream. */\nexport const CHAT_STREAM_STOP = 'chat:stream:stop';\n\n/** Main -> Renderer: Send a chunk of the streaming response. */\nexport const ON_CHAT_RESPONSE_CHUNK = 'chat:onResponseChunk';\n\n/** Main -> Renderer: Signal that the chat stream has ended successfully. */\nexport const ON_CHAT_STREAM_END = 'chat:onStreamEnd';\n\n/** Main -> Renderer: Signal that an error occurred during the chat stream. */\nexport const ON_CHAT_STREAM_ERROR = 'chat:onStreamError';\n\n// --- Add new channel ---\n/** Renderer -> Main: Request to retrieve messages for a specific chat session. */\nexport const CHAT_GET_MESSAGES = 'chat:getMessages';\n\n// --- Add new channel for fetching slice details ---\n/** Renderer -> Main: Request detailed information for specific chunk IDs (returns SliceDetail[]). */\nexport const GET_SLICE_DETAILS = 'slices:getDetails';\n\n// --- Intent Handling Channels ---\n/** Renderer -> Main: Send user's intent from Welcome Page or Command Bar. */\nexport const SET_INTENT = 'intent:set';\n\n/** Main -> Renderer: Send the result/outcome of processing an intent. */\nexport const ON_INTENT_RESULT = 'intent:on-result';\n\n// --- Notebook Operations ---\n/** Renderer -> Main: Create a new notebook. */\nexport const NOTEBOOK_CREATE = 'notebook:create';\n/** Renderer -> Main: Get a notebook by its ID. */\nexport const NOTEBOOK_GET_BY_ID = 'notebook:getById';\n/** Renderer -> Main: Get all notebooks. */\nexport const NOTEBOOK_GET_ALL = 'notebook:getAll';\n/** Renderer -> Main: Update a notebook. */\nexport const NOTEBOOK_UPDATE = 'notebook:update';\n/** Renderer -> Main: Delete a notebook. */\nexport const NOTEBOOK_DELETE = 'notebook:delete';\n/** Renderer -> Main: Get all chunks for a notebook. */\nexport const NOTEBOOK_GET_CHUNKS = 'notebook:getChunks';\n\n// --- Chat Session Operations within Notebooks ---\n/** Renderer -> Main: Create a new chat session in a notebook. */\nexport const CHAT_SESSION_CREATE_IN_NOTEBOOK = 'chatSession:createInNotebook';\n/** Renderer -> Main: List all chat sessions for a notebook. */\nexport const CHAT_SESSION_LIST_FOR_NOTEBOOK = 'chatSession:listForNotebook';\n/** Renderer -> Main: Transfer a chat session to a different notebook. */\nexport const CHAT_SESSION_TRANSFER_TO_NOTEBOOK = 'chatSession:transferToNotebook';\n\n// --- Zustand Store Persistence Channels ---\n/** Renderer -> Main: Get a value from the persistent store. Expects key, returns string or null. */\nexport const STORE_GET = 'store:get';\n/** Renderer -> Main: Set a value in the persistent store. Expects key and string value. */\nexport const STORE_SET = 'store:set';\n/** Renderer -> Main: Remove a value from the persistent store. Expects key. */\nexport const STORE_REMOVE = 'store:remove';\n\n// Add these for flushing stores on quit\nexport const MAIN_REQUEST_RENDERER_FLUSH = 'main:request-renderer-flush';\nexport const RENDERER_FLUSH_COMPLETE = 'renderer:flush-complete';\n\n// --- To-Do Operations ---\n/** Renderer -> Main: Create a new to-do item. */\nexport const TODO_CREATE = 'todo:create';\n/** Renderer -> Main: Get all to-dos for a user. */\nexport const TODO_GET_ALL = 'todo:getAll';\n/** Renderer -> Main: Get a specific to-do by ID. */\nexport const TODO_GET_BY_ID = 'todo:getById';\n/** Renderer -> Main: Update a to-do item. */\nexport const TODO_UPDATE = 'todo:update';\n/** Renderer -> Main: Delete a to-do item. */\nexport const TODO_DELETE = 'todo:delete';\n\n// --- Classic Browser Channels ---\n/** Renderer -> Main: create and attach a BrowserView */\nexport const CLASSIC_BROWSER_CREATE = 'browser:create';\n/** Renderer -> Main: Request navigation action (back, forward, reload, stop, url) in a classic browser window. */\nexport const CLASSIC_BROWSER_NAVIGATE = 'browser:navigate';\n/** Renderer -> Main: Request to load a specific URL in a classic browser window. */\nexport const CLASSIC_BROWSER_LOAD_URL = 'browser:loadUrl';\n/** Renderer -> Main: Set BrowserView bounds */\nexport const CLASSIC_BROWSER_SET_BOUNDS = 'classic-browser:set-bounds';\n/** Renderer -> Main: Set BrowserView visibility */\nexport const CLASSIC_BROWSER_SET_VISIBILITY = 'classic-browser:set-visibility';\n/** Main -> Renderer: Send state updates for a classic browser window (e.g., URL change, loading status). */\nexport const ON_CLASSIC_BROWSER_STATE = 'on-classic-browser-state';\n/** Renderer -> Main: destroy a BrowserView */\nexport const CLASSIC_BROWSER_DESTROY = 'browser:destroy';\n\n// Added for WebContentsView focus events\nexport const CLASSIC_BROWSER_VIEW_FOCUSED = 'classic-browser-view-focused';\n\n// Added for Renderer to request main process to focus a view\nexport const CLASSIC_BROWSER_REQUEST_FOCUS = 'classic-browser-request-focus';\n\n// --- Electron Store Persistence Channels ---\n/** Renderer -> Main: Get a value from the persistent store. Expects key, returns string or null. */\n/** Renderer -> Main: Set a value in the persistent store. Expects key and string value. */\n/** Renderer -> Main: Remove a value from the persistent store. Expects key. */\n\nexport const ON_AGENT_STATE_UPDATE = 'agent:on-state-update';\n\n// Unique ID for the WebLayer's BrowserView instance\nexport const WEB_LAYER_WINDOW_ID = '__WEBLAYER_SINGLETON__';\n\n// Slice / Chunk related (consider if these need more specific prefixes or are ok)\n"],
  "mappings": "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",
  "names": ["import_electron", "PROFILE_GET", "PROFILE_UPDATE", "ACTIVITY_LOG_ADD", "BOOKMARKS_IMPORT", "FILE_SAVE_TEMP", "BOOKMARKS_PROGRESS", "CHAT_STREAM_START", "CHAT_STREAM_STOP", "ON_CHAT_RESPONSE_CHUNK", "ON_CHAT_STREAM_END", "ON_CHAT_STREAM_ERROR", "CHAT_GET_MESSAGES", "GET_SLICE_DETAILS", "SET_INTENT", "ON_INTENT_RESULT", "NOTEBOOK_CREATE", "NOTEBOOK_GET_BY_ID", "NOTEBOOK_GET_ALL", "NOTEBOOK_UPDATE", "NOTEBOOK_DELETE", "NOTEBOOK_GET_CHUNKS", "CHAT_SESSION_CREATE_IN_NOTEBOOK", "CHAT_SESSION_LIST_FOR_NOTEBOOK", "CHAT_SESSION_TRANSFER_TO_NOTEBOOK", "STORE_GET", "STORE_SET", "STORE_REMOVE", "MAIN_REQUEST_RENDERER_FLUSH", "RENDERER_FLUSH_COMPLETE", "TODO_CREATE", "TODO_GET_ALL", "TODO_GET_BY_ID", "TODO_UPDATE", "TODO_DELETE", "CLASSIC_BROWSER_CREATE", "CLASSIC_BROWSER_NAVIGATE", "CLASSIC_BROWSER_LOAD_URL", "CLASSIC_BROWSER_SET_BOUNDS", "CLASSIC_BROWSER_SET_VISIBILITY", "ON_CLASSIC_BROWSER_STATE", "CLASSIC_BROWSER_DESTROY", "CLASSIC_BROWSER_VIEW_FOCUSED", "CLASSIC_BROWSER_REQUEST_FOCUS", "api", "PROFILE_GET", "payload", "PROFILE_UPDATE", "ACTIVITY_LOG_ADD", "filePath", "BOOKMARKS_IMPORT", "fileName", "data", "FILE_SAVE_TEMP", "callback", "BOOKMARKS_PROGRESS", "listener", "_event", "event", "notebookId", "sessionId", "question", "CHAT_STREAM_START", "CHAT_STREAM_STOP", "chunk", "ON_CHAT_RESPONSE_CHUNK", "result", "ON_CHAT_STREAM_END", "errorMessage", "ON_CHAT_STREAM_ERROR", "limit", "beforeTimestamp", "CHAT_GET_MESSAGES", "chunkIds", "id", "GET_SLICE_DETAILS", "SET_INTENT", "ON_INTENT_RESULT", "params", "NOTEBOOK_CREATE", "NOTEBOOK_GET_BY_ID", "NOTEBOOK_GET_ALL", "NOTEBOOK_UPDATE", "NOTEBOOK_DELETE", "NOTEBOOK_GET_CHUNKS", "CHAT_SESSION_CREATE_IN_NOTEBOOK", "CHAT_SESSION_LIST_FOR_NOTEBOOK", "CHAT_SESSION_TRANSFER_TO_NOTEBOOK", "key", "STORE_GET", "value", "STORE_SET", "STORE_REMOVE", "RENDERER_FLUSH_COMPLETE", "error", "MAIN_REQUEST_RENDERER_FLUSH", "windowId", "bounds", "initialUrl", "CLASSIC_BROWSER_CREATE", "url", "CLASSIC_BROWSER_LOAD_URL", "action", "CLASSIC_BROWSER_NAVIGATE", "CLASSIC_BROWSER_SET_BOUNDS", "shouldBeDrawn", "isFocused", "CLASSIC_BROWSER_SET_VISIBILITY", "CLASSIC_BROWSER_DESTROY", "update", "ON_CLASSIC_BROWSER_STATE", "CLASSIC_BROWSER_VIEW_FOCUSED", "CLASSIC_BROWSER_REQUEST_FOCUS", "TODO_CREATE", "userId", "TODO_GET_ALL", "TODO_GET_BY_ID", "TODO_UPDATE", "TODO_DELETE", "hoursAgo", "synthesisType", "electronDebugApi"]
}
