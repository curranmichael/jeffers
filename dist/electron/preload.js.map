{
  "version": 3,
  "sources": ["../../electron/preload.ts", "../../shared/ipcChannels.ts"],
  "sourcesContent": ["import { contextBridge, ipcRenderer } from 'electron';\nimport {\n  type IpcRendererEvent,\n} from 'electron';\n\n// Import channel constants and types from shared\nimport {\n    PROFILE_GET,\n    BOOKMARKS_IMPORT,\n    FILE_SAVE_TEMP,\n    BOOKMARKS_PROGRESS,\n    CHAT_STREAM_START,\n    CHAT_STREAM_STOP,\n    ON_CHAT_RESPONSE_CHUNK,\n    ON_CHAT_STREAM_END,\n    ON_CHAT_STREAM_ERROR,\n    CHAT_GET_MESSAGES,\n    GET_SLICE_DETAILS,\n    SET_INTENT,\n    ON_INTENT_RESULT,\n} from '../shared/ipcChannels';\n// Import IChatMessage along with other types\nimport {\n  IAppAPI,\n  BookmarksProgressEvent,\n  IChatMessage,\n  SliceDetail,\n  StructuredChatMessage,\n  ChatMessageSourceMetadata,\n  IntentPayload,\n  IntentResultPayload,\n} from '../shared/types';\n\nconsole.log('[Preload Script] Loading...');\n\n// Define the API structure that will be exposed to the renderer\n// This should match the IAppAPI interface defined in shared/types.d.ts\nconst api = {\n  // Example function structure (uncomment and adapt when needed):\n  /*\n  exampleAction: (args: ExampleType): Promise<any> => {\n    console.log('[Preload Script] Calling exampleAction via IPC');\n    return ipcRenderer.invoke(CHANNEL_NAME_EXAMPLE, args);\n  },\n  */\n  // --- Add actual API functions here as features are implemented ---\n\n  // Simple example to confirm preload is working\n  getAppVersion: (): Promise<string> => {\n    console.log('[Preload Script] Requesting app version via IPC');\n    // We'll need to create a handler for this in main.ts later\n    return ipcRenderer.invoke('get-app-version'); // Note: This uses a string literal, should use GET_APP_VERSION constant\n  },\n\n  getProfile: (): Promise<{ name?: string }> => {\n    console.log('[Preload Script] Requesting profile via IPC');\n    return ipcRenderer.invoke(PROFILE_GET);\n  },\n\n  // Add importBookmarks function\n  importBookmarks: (filePath: string): Promise<number> => {\n    console.log('[Preload Script] Invoking bookmarks import via IPC');\n    return ipcRenderer.invoke(BOOKMARKS_IMPORT, filePath);\n  },\n\n  // Add saveTempFile function\n  saveTempFile: (fileName: string, data: Uint8Array): Promise<string> => {\n    console.log('[Preload Script] Invoking save temp file via IPC');\n    // Pass data directly; IPC handles serialization of Uint8Array/Buffer\n    return ipcRenderer.invoke(FILE_SAVE_TEMP, { fileName, data });\n  },\n\n  // Add listener for bookmark progress\n  onBookmarksProgress: (callback: (event: BookmarksProgressEvent) => void) => {\n    console.log('[Preload Script] Setting up listener for', BOOKMARKS_PROGRESS);\n    const listener = (_event: Electron.IpcRendererEvent, event: BookmarksProgressEvent) => {\n      // Basic validation of received data structure could be added here\n      // console.debug('[Preload Script] Received bookmark progress:', event);\n      callback(event);\n    };\n    ipcRenderer.on(BOOKMARKS_PROGRESS, listener);\n    // Return a function to remove this specific listener\n    return () => {\n      console.log('[Preload Script] Removing listener for', BOOKMARKS_PROGRESS);\n      ipcRenderer.removeListener(BOOKMARKS_PROGRESS, listener);\n    };\n  },\n\n  // --- Chat Streaming --- \n  startChatStream: (sessionId: string, question: string): void => {\n    if (!sessionId || !question) {\n        console.error('[Preload Script] startChatStream called with invalid sessionId or question.');\n        return;\n    }\n    console.log(`[Preload Script] Sending CHAT_STREAM_START for session: ${sessionId}, question: \"${question.substring(0,30)}...\"`);\n    ipcRenderer.send(CHAT_STREAM_START, { sessionId, question });\n  },\n\n  stopChatStream: (): void => {\n    console.log(`[Preload Script] Sending CHAT_STREAM_STOP`);\n    ipcRenderer.send(CHAT_STREAM_STOP);\n  },\n\n  // Listener for incoming chat chunks (Main -> Renderer)\n  onChatChunk: (callback: (chunk: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, chunk: string) => callback(chunk);\n    ipcRenderer.on(ON_CHAT_RESPONSE_CHUNK, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_RESPONSE_CHUNK, listener);\n  },\n\n  // Listener for stream end signal (Main -> Renderer)\n  onChatStreamEnd: (callback: (result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, result: { messageId: string; metadata: ChatMessageSourceMetadata | null }) => callback(result);\n    ipcRenderer.on(ON_CHAT_STREAM_END, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_END, listener);\n  },\n\n  // Listener for stream error signal (Main -> Renderer)\n  onChatStreamError: (callback: (errorMessage: string) => void) => {\n    const listener = (_event: Electron.IpcRendererEvent, errorMessage: string) => callback(errorMessage);\n    ipcRenderer.on(ON_CHAT_STREAM_ERROR, listener);\n    return () => ipcRenderer.removeListener(ON_CHAT_STREAM_ERROR, listener);\n  },\n\n  // --- End Chat Streaming ---\n\n  // --- Add Chat Message Retrieval ---\n  getMessages: (\n    sessionId: string,\n    limit?: number,\n    beforeTimestamp?: string\n  ): Promise<StructuredChatMessage[]> => {\n    console.log(`[Preload Script] Invoking getMessages for session: ${sessionId}, limit: ${limit}`);\n    return ipcRenderer.invoke(CHAT_GET_MESSAGES, { sessionId, limit, beforeTimestamp });\n  },\n\n  // --- Add Slice Detail Retrieval ---\n  getSliceDetails: (chunkIds: number[]): Promise<SliceDetail[]> => {\n      console.log(`[Preload Script] Invoking getSliceDetails for ${chunkIds.length} IDs: [${chunkIds.slice(0, 5).join(', ')}]...`);\n      // Basic input validation\n      if (!Array.isArray(chunkIds) || chunkIds.some(id => typeof id !== 'number')) {\n          console.error('[Preload Script] getSliceDetails called with invalid input (must be array of numbers).');\n          // Return a rejected promise for invalid input\n          return Promise.reject(new Error('Invalid input: chunkIds must be an array of numbers.'));\n      }\n      return ipcRenderer.invoke(GET_SLICE_DETAILS, chunkIds);\n  },\n\n  // --- Intent Handling ---\n  setIntent: (payload: IntentPayload): Promise<void> => {\n    console.log('[Preload Script] Sending SET_INTENT with payload:', payload.intentText.substring(0, 50) + \"...\");\n    // Assuming setIntent is an invoke call for potential acknowledgement, though void promise suggests send might also be fine.\n    // Sticking to invoke as per plan (Promise<void> can be an ack from handler)\n    return ipcRenderer.invoke(SET_INTENT, payload);\n  },\n\n  onIntentResult: (callback: (result: IntentResultPayload) => void): (() => void) => {\n    console.log('[Preload Script] Setting up listener for ON_INTENT_RESULT');\n    const listener = (_event: Electron.IpcRendererEvent, result: IntentResultPayload) => {\n      // console.debug('[Preload Script] Received intent result:', result);\n      callback(result);\n    };\n    ipcRenderer.on(ON_INTENT_RESULT, listener);\n    return () => {\n      console.log('[Preload Script] Removing listener for ON_INTENT_RESULT');\n      ipcRenderer.removeListener(ON_INTENT_RESULT, listener);\n    };\n  },\n};\n\n// Securely expose the defined API to the renderer process\ntry {\n  // Use 'satisfies' to check the api object against the interface\n  contextBridge.exposeInMainWorld('api', api satisfies IAppAPI);\n  console.log('[Preload Script] API exposed successfully.');\n} catch (error) {\n  console.error('[Preload Script] Failed to expose API:', error);\n}\n\n// Type definition for the API (to be placed in shared/types.d.ts)\n/*\ndeclare global {\n  interface Window {\n    api: IAppAPI;\n  }\n}\n\nexport interface IAppAPI {\n  // Signatures for the methods exposed above\n  getAppVersion: () => Promise<string>;\n  // exampleAction: (args: ExampleType) => Promise<any>;\n  // ... other method signatures\n}\n*/\n", "// This file defines the string constants used for IPC channel names.\n// Follow naming conventions (e.g., NOUN_VERB or feature:action).\n// Example: export const NOTEBOOK_SAVE = 'notebook:save';\n\n/** Simple channel for renderer to check main process version. */\nexport const GET_APP_VERSION = 'get-app-version';\n\n// Profile channels\n/** Get the current user profile information. */\nexport const PROFILE_GET = 'profile:get';\n\n/** Start the import process for a bookmarks file (HTML/JSON). Expects temp file path. */\nexport const BOOKMARKS_IMPORT = 'bookmarks:import';\n\n// File operations\n/** Save uploaded file data to a temporary location. Expects { fileName, data }. Returns absolute path. */\nexport const FILE_SAVE_TEMP = 'file:saveTemp';\n\n// Bookmark ingestion progress event\n/** Event channel for broadcasting bookmark import progress updates. */\nexport const BOOKMARKS_PROGRESS = 'bookmarks:progress';\n\n// --- Chat Streaming Channels ---\n/** Renderer -> Main: Start a chat stream request with a question. */\nexport const CHAT_STREAM_START = 'chat:stream:start';\n\n/** Renderer -> Main: Request to stop an ongoing chat stream. */\nexport const CHAT_STREAM_STOP = 'chat:stream:stop';\n\n/** Main -> Renderer: Send a chunk of the streaming response. */\nexport const ON_CHAT_RESPONSE_CHUNK = 'chat:onResponseChunk';\n\n/** Main -> Renderer: Signal that the chat stream has ended successfully. */\nexport const ON_CHAT_STREAM_END = 'chat:onStreamEnd';\n\n/** Main -> Renderer: Signal that an error occurred during the chat stream. */\nexport const ON_CHAT_STREAM_ERROR = 'chat:onStreamError';\n\n// --- Add new channel ---\n/** Renderer -> Main: Request to retrieve messages for a specific chat session. */\nexport const CHAT_GET_MESSAGES = 'chat:getMessages';\n\n// --- Add new channel for fetching slice details ---\n/** Renderer -> Main: Request detailed information for specific chunk IDs (returns SliceDetail[]). */\nexport const GET_SLICE_DETAILS = 'slices:getDetails';\n\n// --- Intent Handling Channels ---\n/** Renderer -> Main: Send user's intent from Welcome Page or Command Bar. */\nexport const SET_INTENT = 'intent:set';\n\n/** Main -> Renderer: Send the result/outcome of processing an intent. */\nexport const ON_INTENT_RESULT = 'intent:on-result';\n"],
  "mappings": "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",
  "names": []
}
