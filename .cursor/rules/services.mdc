---
description: 
globs: 
alwaysApply: true
---
# Cursor Rules: Service Layer (`services/`)

This file defines the rules and guidelines for implementing the business logic layer within the `services/` directory. Services act as orchestrators, coordinating tasks between the **Backend API layer (`electron/server/controllers/`)**, data persistence (`models/`), and AI capabilities (`agents/`).

Adhering to these rules ensures that business logic is centralized, testable, and decoupled from both the UI (`Eliot`) and low-level data access details.

---

## 1. No Direct Data Persistence or File Access

-   **Rule:** Service modules **must never** directly interact with databases (e.g., execute SQL) or the file system (e.g., read/write files). All such operations **must** be delegated to functions within the `models/` layer.
-   **Rationale:** Enforces separation of concerns, centralizes data access logic in `models/`, makes services easier to test (by mocking models), and allows changing the persistence mechanism without affecting business logic.
-   **Example:**
    ```typescript
    // services/NotebookService.ts
    import { notebookModel } from '../models/NotebookModel'; // Correct: Import from models
    import { NotebookData, NotebookSaveResult } from '../shared/types';

    class NotebookService {
      async save(data: NotebookData): Promise<NotebookSaveResult> {
        // Validate business rules here if needed...
        console.log('Saving notebook via service...');

        // Delegate persistence to the model layer
        const result = await notebookModel.saveNotebook(data); // Correct: Call model function

        // Perform other service-level actions (e.g., logging, notifications)...
        return result;
      }

      // Anti-pattern: Direct DB/File access in service
      /*
      async save_BAD(data: NotebookData): Promise<void> {
        // WRONG: Service should not do this!
        const db = connectToDatabase();
        await db.query('INSERT INTO notebooks ...', data);
        // OR
        fs.writeFileSync('/path/to/data/notebook.json', JSON.stringify(data));
      }
      */
    }

    export const notebookService = new NotebookService(); // Example instantiation
    ```

## 2. Task Orchestration and Coordination

-   **Rule:** Services are the designated layer for implementing multi-step workflows and coordinating interactions between different system parts (`models/`, `agents/` modules, other `services/`). This includes `IntentService` routing initial user intents and `AgentService` orchestrating complex AI tasks.
-   **Rationale:** Centralizes complex business processes, making application flow understandable and maintainable. Allows for transactional logic or error handling across multiple steps.
-   **Guidance:** Services **MAY** import and use simple, stateless transformation functions from `ingestion/` or helper functions from `utils/`. However, the service retains responsibility for the overall stateful workflow.
-   **Example:**
    ```typescript
    // services/ImportService.ts
    import { fileModel } from '../models/FileModel';
    import { vectorModel } from '../models/VectorModel';
    import { embeddingAgent } from '../agents/EmbeddingAgent';
    // import { cleanHtml } from '../ingestion/cleaning/cleanHtml'; // Example: Using a stateless helper
    import { RawDocument, ImportResult } from '../shared/types';

    class ImportService {
      async importDocument(doc: RawDocument): Promise<ImportResult> {
        console.log(`Importing document: ${doc.name}`);

        // Optional: Use stateless helper
        // const cleanedContent = cleanHtml(doc.content);

        // Step 1: Persist the raw file via FileModel
        const savedFileInfo = await fileModel.saveRawFile(doc.content, doc.name);

        // Step 2: Generate embeddings via EmbeddingAgent
        const embeddings = await embeddingAgent.generateEmbeddings(savedFileInfo.content); // Pass content to agent

        // Step 3: Store embeddings via VectorModel
        const vectorId = await vectorModel.saveEmbeddings(savedFileInfo.id, embeddings, { source: doc.name });

        console.log(`Document ${doc.name} imported successfully. Vector ID: ${vectorId}`);
        return { success: true, fileId: savedFileInfo.id, vectorId: vectorId };
      }
    }

    export const importService = new ImportService();
    ```

## 3. Statelessness and State Management

-   **Rule:** Aim for service *methods* to be stateless where possible, operating primarily on inputs. However, service *instances* **MAY** manage transient state relevant to their orchestrated task (e.g., `ChatService` managing active stream buffers, configuration). Long-term persistent state belongs in `models/`.
-   **Rule (AgentService State):** The `AgentService`, as an orchestrator of complex AI tasks, **must** manage its execution state explicitly, typically using LangGraph's state object. Refer to `agents.mdc` for more details on agent state management.
-   **Rule (Chat History):** Persistent chat history for specific Notebook sessions is managed by `ChatModel` and accessed by services or agents as needed. Refer to `agents.mdc` and `models.mdc`.
-   **Rationale:** Distinguishes between method-level purity and instance-level state management required for complex workflows. Improves predictability and testability where possible.
-   **Guidance:** Manage instance state carefully. Use established patterns for caching or queues. Inject configuration during service instantiation.

## 4. No UI, Electron, or Preload Dependencies

-   **Rule:** Services **must remain** independent of the presentation layer (`src/`) and the Electron environment (`electron/`). They **must not** import or use `ipcMain`, `ipcRenderer`, `BrowserWindow`, `contextBridge`, `window`, or any UI-specific code (React, HTML, CSS).
-   **Rationale:** Ensures services contain pure business logic, making them portable, reusable (e.g., in `tools/` or tests), and maintainable independently of the UI or Electron shell.
-   **Guidance:** If a service needs environment-specific information (like the path to the `data/` directory), this should be provided via configuration or dependency injection during initialization in `electron/main.ts`, not pulled directly by the service.

## 5. Clear API Surface and Documentation

-   **Rule:** Each service module (or class) should expose a clear, well-defined API (public functions/methods). Use intuitive naming (`verbNoun` style) and leverage TypeScript for strong typing of inputs and outputs. Use JSDoc or comments to explain non-obvious behavior, parameters, or return values.
-   **Rationale:** Makes services easy and safe to consume by **API Controllers**, other services, agents, or tools. Improves code clarity and AI-assistability.
-   **Guidance:** For complex inputs/outputs, define interfaces or types in `shared/types.ts` or within the service file if highly specific. Avoid overly long parameter lists; consider using options objects.

## 6. High-Level Logging

-   **Rule:** The service layer is an appropriate place for logging significant business events or workflow steps (e.g., "User started import," "Notebook saved successfully," "Agent call failed"). Use a consistent logging approach (e.g., a shared logger utility).
-   **Rationale:** Provides visibility into application behavior at a meaningful level of abstraction, aiding debugging and monitoring.
-   **Guidance:** Avoid excessive or low-level logging (like logging every database row read) that belongs closer to the `models/` layer (if needed at all, often behind a debug flag). Keep production logs focused on key events and errors.

## 7. Initialization and Instantiation

-   **Rule:** Service instances or modules **should** be initialized appropriately before they are needed (e.g., by **API Controllers** or other services). This initialization might involve dependency injection (like providing model instances, other service instances, or configuration) and typically occurs centrally during the **API process startup (`electron/api_process.ts`) or main process startup (`electron/main.ts`)**.
-   **Rationale:** Ensures services are ready to handle requests and their dependencies are correctly configured.
-   **Guidance:** The API process entry point (`api_process.ts` or called modules) is responsible for orchestrating service setup and dependency injection.

## 8. LangChain Usage

-   **Rule:** Services **must** use modern LangChain Expression Language (LCEL) chains (e.g., `createRetrievalChain`, `RunnableSequence`) for RAG and other LLM workflows. Avoid legacy classes like `ConversationalRetrievalQAChain`.
-   **Rationale:** Ensures usage of current, more flexible, and observable LangChain APIs. Aligns with library direction and simplifies debugging/callbacks.
-   **Rule:** When providing source documents for RAG responses (e.g., via API/SSE), services **must** explicitly capture the *exact* documents passed to the LLM context (e.g., via LCEL callbacks like `onRetrieverEnd` or inspecting chain state) to ensure accurate attribution. Do not rely solely on potentially inaccurate flags like `returnSourceDocuments`.
-   **Rationale:** Guarantees the sources shown to the user accurately reflect the information used by the LLM, preventing misleading citations.
-   **Rule:** Services **must** ensure that when hydrating retrieved documents (e.g., from vector search results) with full data from `models`, the final list returned to the controller or caller preserves the original relevance ranking/order provided by the `Retriever`.
-   **Rationale:** Maintains the integrity of the search results and presents the most relevant information first.

---

## NEW SECTION: Intent Handling Flow

-   **Welcome Page / Command Bar:** The primary user entry point for free-form intent (e.g., "Help me plan a trip to Berlin", "Show my Saturn research") is the application's Welcome Page or a global Command Bar.
-   **IPC Mechanism:** User intent from the Welcome Page/Command Bar **must** be sent to the backend via a dedicated IPC channel: `set_intent`.
-   **`IntentService.ts`:** This service (located in `services/IntentService.ts`) is responsible for receiving the intent from the `set_intent` IPC channel. Its primary role is to perform initial routing:
    *   It may directly interact with `NotebookService` for simple actions like opening a known Notebook.
    *   For complex queries, planning, or generative tasks, it **must** delegate to `AgentService`.
-   **`AgentService.ts`:** (Located in `services/AgentService.ts`) Receives complex intents from `IntentService` and uses LangGraph to orchestrate the necessary steps, including tool usage (retrieval, web search, notebook actions) and LLM calls.
-   **Data Flow Overview:** `UI (Welcome/CmdBar) -> IPC (set_intent) -> IntentService -> [AgentService | NotebookService] -> AgentService -> [Tools -> Models/APIs] -> AgentService -> IntentService -> IPC (INTENT_RESULT) -> UI`.
-   **Result to UI:** The `IntentService` (or `AgentService` via `IntentService`) sends a structured result back to the UI via an `INTENT_RESULT` IPC channel, indicating the outcome (e.g., notebook opened, chat reply, plan generated).

By adhering to these Service Layer rules, we ensure that Jeffers' core business logic is well-organized, testable, and effectively coordinates the application's underlying data and AI capabilities within the backend API architecture.