---
description: 
globs: 
alwaysApply: true
---
# Cursor Rules: Data Models Layer (`models/`)

This file outlines the rules for implementing the data persistence layer within the `models/` directory. Modules here are responsible for all direct interactions with storage (SQLite via `better-sqlite3`).

These rules ensure data access is encapsulated, consistent, and separated from business logic.

---

## Core Data Entities

### Object (`JeffersObject`)
-   **Definition:** (As per General Custom Instructions) A top-level entity ingested into the system. Represents original source content. Corresponds to an `objects` table (or `source_content`).
-   **Managed by:** `ObjectModel.ts` (or similar).

### Chunk
-   **Definition:** (As per General Custom Instructions) A semantically coherent slice of an `OBJECT`. Stored in the `chunks` table.
-   **Managed by:** `ChunkSqlModel.ts` (or similar).
-   **Relationship to Notebooks:** The `chunks` table **must** have a `notebook_id` column (TEXT, NULLABLE, FOREIGN KEY to `notebooks.id ON DELETE SET NULL`). This ensures that if a notebook is deleted, its associated chunks are not deleted but merely disassociated (their `notebook_id` becomes NULL). This allows chunks to potentially be re-assigned or exist independently.

### Notebook
-   **Definition:** A user-facing workspace.
-   **Dual Nature:**
    1.  **As a User Container (`NotebookRecord`):** Manages title, description, user organization. Persisted in `notebooks` table by `NotebookModel.ts`.
    2.  **As System Content (`JeffersObject`):** The notebook's essence (title, description) is also stored as a `JeffersObject` (e.g., `objectType: 'notebook'`) by `ObjectModel.ts`. This makes the notebook itself discoverable and part of the RAG context.
-   **Relationships:**
    *   Groups related `CHAT_SESSIONS`.
    *   Conceptually groups `CHUNKS` (either directly via `chunks.notebook_id` or indirectly if a notebook is a collection of `JeffersObject`s which then have chunks).

### Chat Session (`IChatSession`)
-   **Definition:** A single conversation thread.
-   **Persistence:** Stored in `chat_sessions` table by `ChatModel.ts`.
-   **Relationship to Notebooks:** Each chat session **must** belong to exactly one `Notebook`.
    *   `chat_sessions` table has `notebook_id` (TEXT, **NOT NULL**, FOREIGN KEY to `notebooks.id ON DELETE CASCADE`). This ensures if a notebook is deleted, all its chat sessions (and their messages) are also deleted.
-   **Relationship to Messages:** Each chat session contains multiple `IChatMessage`s.

### Chat Message (`IChatMessage`)
-   **Definition:** A single message within a `ChatSession`.
-   **Persistence:** Stored in `chat_messages` table by `ChatModel.ts`.
-   **Relationship to Chat Session:** Each message **must** belong to exactly one `ChatSession`.
    *   `chat_messages` table has `session_id` (TEXT, **NOT NULL**, FOREIGN KEY to `chat_sessions.session_id ON DELETE CASCADE`).

---
## 1. Single Responsibility: Raw Data Access

-   **Rule:** Each module in `models/` focuses on a specific data entity or storage type. Provides low-level CRUD and query operations.
-   **Rationale:** Organization, reusability, isolation of storage dependencies.

## 2. Return Plain Data Structures

-   **Rule:** Model functions **must** return simple, plain data structures (matching interfaces in `shared/types.ts`), not complex class instances or DB-specific objects.
-   **Rationale:** Decouples layers, ensures serializability for IPC.

## 3. No Cross-Model Dependencies

-   **Rule:** A model module **must not** directly import or call functions from another model module. Coordination happens in `services/`.
-   **Rationale:** Prevents tangled dependencies, keeps models focused.

## 4. Use User Data Directory for All Persistent Storage

-   **Rule:**
    *   SQLite database files (e.g., `jeffers_default.db`) **must** be stored within the user data directory (e.g., obtained via `app.getPath('userData')` in Electron, then placed in a subdirectory like `data/`).
    *   Vector store data (e.g., ChromaDB) **should** be managed by its server process (e.g., within `data/chroma_data` in user data path, or per its own configuration).
    *   **Application state files** (like persisted window layouts for notebooks) **must** also be stored in the user data directory (e.g., `app.getPath('userData')/layouts/notebook-layout-[notebookId].json`). These are managed by main process file utilities, not directly by `models/`.
    *   User-uploaded files or temporary files generated during ingestion should also use appropriate subdirectories within the user data path or OS temp directories.
-   **Rationale:** Centralizes application data, separates from source code, simplifies backup.

## 5. No Business Logic or Decisions

-   **Rule:** Model functions **must not** contain application-specific business rules. Logic is limited to data retrieval, storage, and basic integrity constraints.
-   **Rationale:** Pure data access. Business logic belongs in `services/`.

## 6. Isolation, Reusability, and Side Effects

-   **Rule:** Model functions should be reusable and free of side effects beyond their data access task.
-   **Rule:** Implement batching (e.g., `WHERE id IN (...)`) for reads where appropriate to avoid N+1 queries.
-   **Rationale:** Predictability, performance.

## 7. ID Management, Schema Evolution & Data Handling

-   **Rule (ID Standardization):** Long-term goal: UUIDs for all primary keys.
-   **Rule (ID Consistency):** `chunk_id` is canonical. Chroma vector IDs/metadata use or link to canonical `chunk_id`.
-   **Rule (Schema - Additive Changes):** Additive, non-breaking schema changes **SHOULD** allow lazy backfill. Data access logic **MUST** handle missing fields gracefully.
-   **Rule (Schema - Complex Changes):** Destructive or complex schema changes require explicit migration scripts (`models/migrations/`).
-   **Rule (Schema - `notebooks` table):**
    *   `id` (TEXT PRIMARY KEY - UUID)
    *   `title` (TEXT NOT NULL)
    *   `description` (TEXT)
    *   `created_at` (INTEGER NOT NULL)
    *   `updated_at` (INTEGER NOT NULL)
-   **Rule (Schema - `chat_sessions` table):**
    *   `session_id` (TEXT PRIMARY KEY - UUID)
    *   `notebook_id` (TEXT **NOT NULL**, FOREIGN KEY to `notebooks.id ON DELETE CASCADE`)
    *   `title` (TEXT) - Optional title for the specific chat session.
    *   `created_at` (INTEGER NOT NULL)
    *   `updated_at` (INTEGER NOT NULL)
-   **Rule (Schema - `chat_messages` table):**
    *   `message_id` (TEXT PRIMARY KEY - UUID)
    *   `session_id` (TEXT **NOT NULL**, FOREIGN KEY to `chat_sessions.session_id ON DELETE CASCADE`)
    *   `role` (TEXT NOT NULL, e.g., 'user', 'assistant')
    *   `content` (TEXT NOT NULL)
    *   `timestamp` (TEXT NOT NULL, ISO8601 string)
    *   `metadata` (TEXT, JSON string - e.g., for `sourceChunkIds`)
-   **Rationale:** Smooth evolution, data integrity, clear schema for key entities.

## 8. ChromaDB Integration

-   **Rule:** ChromaDB **must** run in server mode. Applications interact via client library to server endpoint.
-   **Rationale:** Avoids file locking, ASAR issues, allows potential sharing.

## Naming Conventions

-   **Rule:** Model filenames: `PascalCaseModel.ts`.
-   **Rule:** Model classes: `PascalCase` matching filename.
-   **Rule:** Model methods: `camelCase` with CRUD-like prefixes.
-   **Rule:** DB table names: `snake_case`, plural (e.g., `notebooks`, `chat_sessions`).
-   **Rule:** DB column names: `snake_case` (e.g., `notebook_id`, `created_at`).
-   **Rationale:** Consistency between JS/TS and SQL conventions.
---

Following these Model Layer rules ensures data persistence is robust, maintainable, and separated from business logic.