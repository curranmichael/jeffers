---
description: 
globs: 
alwaysApply: true
---
# Cursor Rules: AI Agents (`agents/`)

This file defines the rules and guidelines for implementing AI agents within the `agents/` directory. Agents encapsulate specific AI-driven capabilities or autonomous behaviors (e.g., web searching, text summarization, information retrieval) used by the application, primarily orchestrated by the `services/` layer.

These rules ensure that AI capabilities are modular, maintainable, and integrated cleanly into the overall architecture.

---

## 1. Encapsulation of Distinct AI Capabilities

-   **Rule:** Each module (e.g., file or subdirectory) within `agents/` **must** represent a distinct AI agent or capability (e.g., `WebAgent`, `RetrievalAgent`, `SummarizationAgent`).
-   **Rationale:** Promotes modularity and separation of concerns, making it easier to develop, test, update, or replace specific AI functionalities without impacting others.
-   **Guidance:** Agents should expose a clear, high-level public interface (e.g., a class with methods like `execute(task)` or specific functions like `searchWeb(query)`). The internal implementation details (specific models used, prompt engineering, complex logic) should be hidden behind this interface. Services interact with agents solely through this public API.

## 2. Interaction with Other Layers (Models, Services, Tools)

-   **Rule:** Agents can interact with other layers as needed to perform their tasks:
    *   They **may** call functions in `models/` to retrieve or (less commonly) store data directly related to their function (e.g., a `RetrievalAgent` querying a vector database via `VectorModel`).
    *   They **may** use utility functions from `shared/`.
    *   They **may** use helper functions or classes defined within `agents/` itself (e.g., a base agent class, common prompt formatters).
    *   They **should generally not** call `services/` directly to avoid circular dependencies, unless a clear pattern like using a foundational "LLMService" is established. Orchestration typically flows from Service -> Agent.
-   **Rationale:** Allows agents to leverage existing data access and utilities while maintaining focus on their core AI logic. Prevents agents from becoming overly coupled or duplicating functionality.
-   **Guidance:** Any interaction with external resources (APIs, web scraping) or complex tooling should be encapsulated within the agent or potentially delegated to specific helper modules (sometimes referred to as "tools" in an agent context, distinct from the developer `tools/` directory).

## 3. Isolation from UI and Primary Persistence Logic

-   **Rule:** Agents operate within the main process and **must not** have any awareness of or dependency on the UI (`src/`) or Electron-specific APIs (`ipcMain`, `BrowserWindow`, etc.).
-   **Rule:** Agents **should generally not** be responsible for primary data persistence. If an agent generates data (e.g., a summary, search results) that needs to be saved long-term, it **must** return this data to the calling service, which then uses the appropriate `models/` function to persist it.
-   **Rationale:** Maintains the layered architecture. Keeps agents focused on their AI task rather than application state management or UI presentation. Centralizes persistence logic within `models/` as orchestrated by `services/`.
-   **Exception:** Agents *may* manage their own internal cache or short-term memory if necessary for their operation, but this should be encapsulated and not interfere with the main application data flow managed by services and models.

## 4. Design for Orchestration (Statelessness & Simplicity)

-   **Rule:** Design agents with future multi-agent scenarios in mind. Aim for agents to be as stateless as possible between invocations. If state is necessary (e.g., conversation history), manage it explicitly and provide clear methods for accessing or resetting it.
-   **Rationale:** Stateless or clearly state-managed agents are easier to orchestrate, test, and potentially parallelize or distribute in the future.
-   **Guidance:** Keep the agent's primary interface simple (e.g., `async execute(params): Promise<Result>`). This simplifies integration into services and makes future refactoring (like moving an agent to a worker thread or separate process for performance) less disruptive to the calling code. Consider potential blocking operations (long API calls, heavy computation) and structure the agent's methods to be asynchronous (`async/await`).

## 5. Robust Error Handling

-   **Rule:** Agents **must** handle potential errors gracefully, especially when interacting with external APIs, processing complex data, or performing inherently uncertain AI operations. They should catch internal errors and either retry if appropriate or throw meaningful, structured exceptions (e.g., instances of `Error` or custom `AgentError` subclasses) back to the calling service.
-   **Rationale:** Prevents agent failures from crashing the application. Allows the orchestrating service to understand the nature of the failure and react accordingly (e.g., log the error, inform the user, try an alternative agent).
-   **Guidance:** Avoid silent failures. Ensure thrown errors provide sufficient context. Consider standardizing error types across different agents if complex error handling is required at the service level.

## 6. Modularity and Documentation

-   **Rule:** Follow consistent patterns when adding new agents. Each agent should be self-contained within its module. Document the agent's purpose, its public API, any configuration requirements (e.g., API keys needed in environment variables), and potential failure modes.
-   **Rationale:** Ensures the `agents/` directory remains organized and understandable as the number of agents grows. Facilitates reuse and maintenance.
-   **Guidance:** Avoid complex direct interactions *between* agents within their own code. If agents need to collaborate, this coordination logic belongs in a higher-level service or a dedicated orchestrator agent. Think of each agent as a specialized "tool" that a service can choose to use.

---

By following these AI Agent rules, we ensure that Jeffers' AI capabilities are developed in a modular, maintainable, and well-integrated manner, supporting both current needs and future evolution towards more complex multi-agent systems.