---
description: 
globs: 
alwaysApply: false
---
# Cursor Rules: 00 - Overview and Project Structure

This document provides a high-level overview of the Jeffers application architecture, focusing on project structure, core concepts, and primary data flows. It serves as a foundational guide to be read alongside layer-specific rules (e.g., `models.mdc`, `services.mdc`).

---

## 0. Vision & Goals (Reference from `custom_instructions`)

- Calm workspace – minimise cognitive load while working across chat, canvas, and embedded webviews.
- AI‑assisted workflows – first‑class chat, retrieval, and agent orchestration.
- Persistent context – long‑term knowledge retention via vector search and notebooks.
- Maintainable & scalable – conventional architecture, strict boundaries, continuous test coverage.

---

## 1. Folder Map (Adopted from `custom_instructions`)

Strict adherence to this structure is required. No other top-level folders in `src/` unless specified and approved.

```
rilke/ # (Assuming 'rilke' is the project root name based on example)
├── public/
├── src/
│   ├── components/
│   │   ├── ui/       # Auto-generated by shadcn/ui CLI
│   │   ├── layout/   # Components defining screen structure (e.g., MainLayout.tsx)
│   │   ├── chat/     # Components specific to the chat UI (e.g., ChatInput.tsx, MessageList.tsx)
│   │   └── canvas/   # Components for the canvas area (e.g., CanvasView.tsx)
│   ├── App.tsx       # Main application component, renders layout
│   └── main.tsx      # Application entry point (Renderer process)
├── electron/
│   ├── main.ts       # Electron main process entry point
│   ├── preload.ts    # Electron preload script
│   └── ipc/          # IPC Handlers (one file per channel/action)
├── services/
│   ├── IntentService.ts
│   ├── AgentService.ts
│   ├── NotebookService.ts
│   ├── ChatService.ts
│   ├── ChunkingService.ts
│   └── agents/       # Orchestrated agent logic or specific capability agents
│       └── tools/    # Tools for AgentService (LangGraph)
├── models/
│   ├── NotebookModel.ts
│   ├── ObjectModel.ts
│   ├── ChunkModel.ts
│   ├── ChatModel.ts
│   ├── ChromaVectorModel.ts
│   └── migrations/   # Database migration scripts
├── shared/
│   ├── types.d.ts    # Shared TypeScript type definitions
│   └── ipcChannels.ts # Centralized IPC channel constants
├── data/             # All persistent application data (SQLite DBs, vector stores, user files)
├── public/           # Static assets served directly by Next.js/Electron
├── tests/            # Unit and integration tests
├── .cursor/
│   └── rules/        # These rule files
├── index.html        # (If Vite is used for renderer)
├── package.json
├── tsconfig.json
└── ... (other project configuration files)
```

**General folder structure for future features (Reference from `custom_instructions`)**
- `api/`: API endpoints (If a separate backend API is introduced later)
- `public/`: Static assets
  - `assets/`: Videos, sounds, and other media
  - `fonts/`: Font files
  - `icons/`: UI icons organized by category
  - `patterns/`: Pattern files
- `src/`: Source code
  - `apps/`: Individual application modules (If the app grows into multiple distinct 'apps')
  - `components/`: Shared React components
    - `dialogs/`: Dialog components
    - `layout/`: Layout components
    - `shared/`: Shared components across applications
    - `ui/`: UI components (shadcn components)
  - `config/`: Configuration files
  - `contexts/`: React context providers
  - `hooks/`: Custom React hooks
  - `lib/` or `utils/`: Libraries and utility functions
  - `stores/`: State management
  - `styles/`: CSS and styling utilities
  - `types/`: Shared TypeScript type definitions (prefer `shared/types.d.ts`)

---

## 2. Core Application Concepts

### Notebook
-   **Definition:** A user-facing workspace focused on a specific, user-defined topic or task (e.g., "Berlin Trip," "Embedding Research"). Notebooks may also contain multiple parts, like a trip-planning notebook (itinerary, notes, budget).
-   **Key Characteristics:**
    *   Primary unit of user organization and context.
    *   Persisted via `NotebookModel` in SQLite.
    *   Groups related `Chunks` (vectorized content).
    *   Associated with `ChatSessions`.
    *   Can be an `Object` itself, with its summary/description embedded for discoverability.
-   *(Refer to `models.mdc` for detailed persistence and relationship rules).*

### Object & Chunk
-   **Object:** A top-level entity ingested into the system (e.g., bookmark, document, note). Represents original source content.
-   **Chunk:** A semantically coherent slice of an `Object`, sized for LLM context and retrieval.
-   *(Refer to `models.mdc` and `ingestion.mdc` for details).*

---

## 3. Primary User Intent Flow

This describes the flow when a user provides a high-level intent, typically from the Welcome Page or a global Command Bar.

-   **A. Welcome Page / Command Bar (UI - `src/`):**
    *   **Function:** Serves as the primary entry point for the user to express their goal or task (e.g., "Help me plan a trip to Berlin," "Find my notes on Saturn," "What's new in AI research?").
    *   Captures free-form user input.

-   **B. IPC Communication (`set_intent`):**
    *   The renderer process sends the user's raw textual intent to the main process via a dedicated IPC channel: `set_intent`.
    *   *(Refer to `preload.mdc` for how this is exposed and `ipc.mdc` for handler rules).*

-   **C. `IntentService` (Backend - `services/IntentService.ts`):**
    *   Receives the intent from the `set_intent` IPC channel.
    *   **Responsibility:** Acts as a high-level router.
        *   Performs basic analysis/classification of the intent.
        *   If the intent can be resolved directly (e.g., "Open Notebook X"), it may call `NotebookService`.
        *   For most non-trivial intents requiring understanding, planning, retrieval, or generation, it **must** delegate to `AgentService`.
    *   *(Refer to `services.mdc` for detailed service rules).*

-   **D. `AgentService` (Backend - `services/AgentService.ts`):**
    *   Receives the intent and any relevant context from `IntentService`.
    *   **Responsibility:** Orchestrates complex AI-driven tasks using LangGraph.
        *   Manages a graph of operations (LLM calls, tool executions).
        *   Invokes tools (e.g., `RetrievalTool`, `WebSearchTool`, `NotebookTool` which interacts with `NotebookService`).
        *   Maintains the state of the ongoing task.
    *   *(Refer to `agents.mdc` for detailed agent and LangGraph rules).*

-   **E. Result to UI (`INTENT_RESULT`):**
    *   `IntentService` (usually after `AgentService` completes or provides an intermediate result) sends a structured JSON payload back to the renderer via the `INTENT_RESULT` IPC channel.
    *   This payload informs the UI on how to proceed (e.g., open a specific notebook, display a chat message, present a plan).

**Simplified Data Flow:**
`UI (Welcome/CmdBar) -> IPC (set_intent) -> IntentService -> [AgentService | NotebookService] -> AgentService -> [Tools -> Models/APIs] -> AgentService -> IntentService -> IPC (INTENT_RESULT) -> UI`

---

## 4. Runtime Boundaries (Reference from `custom_instructions`)

-   **UI Layer (`src/components/`, `src/app/`):** Rendering, user interaction. Minimal business logic. Fetch data/actions via hooks.
-   **Logic Layer (`src/hooks/`, `src/contexts/`, `src/store/`):** UI-side logic, state management, orchestrates calls to `window.api`.
-   **Backend Service/Utility Layer (`services/`, `models/`, `agents/`, `electron/`):** Handles core business logic, data persistence, AI operations, system-level tasks. UI-agnostic.

*(Refer to layer-specific rule files for detailed constraints.)*
