import { logger } from '../utils/logger';
import { IntentPayload, IntentResultPayload } from '../shared/types';
import { NotebookService } from './NotebookService';
import { ExaSearchTool } from './agents/tools/ExaSearchTool';
import { exaService } from './ExaService';
import { hybridSearchService } from './HybridSearchService';
import { HybridSearchResult } from './HybridSearchService';

// Define interfaces for OpenAI API request and response
interface OpenAIFunction {
  name: string;
  description: string;
  parameters: {
    type: "object";
    properties: Record<string, { type: string; description: string }>;
    required?: string[];
  };
}

interface OpenAIMessage {
  role: "system" | "user" | "assistant" | "tool";
  content: string | null;
  tool_calls?: {
    id: string;
    type: "function";
    function: {
      name: string;
      arguments: string; // JSON string
    };
  }[];
  tool_call_id?: string; // For tool role messages
}

interface OpenAIRequest {
  model: string;
  messages: OpenAIMessage[];
  tools?: { type: "function"; function: OpenAIFunction }[];
  tool_choice?: "auto" | "none" | { type: "function"; function: { name: string } };
  temperature: number;
}

interface OpenAIResponse {
  choices: {
    index: number;
    message: OpenAIMessage;
    finish_reason: "stop" | "length" | "tool_calls" | "content_filter" | "function_call"; // function_call is older, tool_calls is newer
  }[];
  error?: {
    message: string;
    type: string;
    param: string | null;
    code: string | null;
  };
}

export class AgentService {
    private readonly notebookService: NotebookService;
    private readonly openAIKey: string | undefined;
    private readonly conversationHistory: Map<number, OpenAIMessage[]> = new Map();
    private readonly MAX_HISTORY_LENGTH = 20; // Keep last 20 messages (10 exchanges)
    private readonly exaSearchTool: ExaSearchTool;
    private readonly hybridSearchService = hybridSearchService;
    private readonly exaService = exaService;

    constructor(notebookService: NotebookService) {
        this.notebookService = notebookService;
        this.openAIKey = process.env.OPENAI_API_KEY;
        if (!this.openAIKey) {
            logger.warn('[AgentService] OPENAI_API_KEY not found in environment variables. AgentService will not be able to process complex intents via OpenAI.');
        }
        
        // Initialize the ExaSearchTool
        this.exaSearchTool = new ExaSearchTool(exaService, hybridSearchService);
        
        logger.info('[AgentService] Initialized');
    }

    async processComplexIntent(payload: IntentPayload, senderId: number): Promise<IntentResultPayload> {
        logger.info(`[AgentService] Processing complex intent: "${payload.intentText}" from sender ${senderId}`);

        if (!this.openAIKey) {
            logger.error('[AgentService] Cannot process intent: OPENAI_API_KEY is missing.');
            return { type: 'error', message: 'Agent service is not configured (missing API key).' };
        }

        const systemPrompt = `You are a helpful, proactive assistant in a personal knowledge app called Jeffers. You have a deep understanding of the user's needs and goals, and you are able to anticipate their requests and provide helpful, relevant information. When in doubt, take action rather than asking for clarification. You also have a background in mindfulness and meditation practices, and studied attention deeply.

IMPORTANT: Be proactive and action-oriented. When users express a desire or intent, fulfill it rather than just describing how they could do it themselves. 

TONE: Be direct, helpful, and take ownership. Never use passive-aggressive language like "You might want to try..." or "Perhaps you could...". If something fails, acknowledge it and take action to help, don't push the problem back to the user.

KEY PATTERNS:
- When a user says "search [service] for [query]", they want you to OPEN that service with their search, not search about that service. Use open_url with the proper search URL.
- For news requests: Recognize keywords like "headlines", "news", "what's happening", "current events", "breaking news", "latest" as news-specific searches. Use searchType: 'headlines' or 'news' appropriately.

Follow this priority order:

1. If you can answer from your knowledge, do so directly
2. If you need current/specific information, use search_web to find and provide the answer:
   - For news/headlines: Use searchType: 'headlines' or 'news' with appropriate dateRange
   - For general information: Use searchType: 'general'
   - The search will combine web results with the user's personal knowledge base
3. Use open_url when:
   - The user wants to access a specific resource or website
   - The content is interactive and requires user interaction (streaming, shopping, banking, etc.)
   - Action verbs like "watch", "stream", "listen", "play", "shop", "buy", "order", "read", "check", "view" suggest interactive intent
   - The user would benefit from seeing the full source material
   - You've provided information and the user wants more detail
4. Default to action: If unsure whether to search or open a URL, lean towards taking the action that best fulfills the user's intent.

NEWS SEARCH GUIDANCE:
- "headlines" or "what's happening" → searchType: 'headlines' (fetches categorized top stories)
- "news about X" or "latest on X" → searchType: 'news' with specific query
- Recent events default to dateRange: 'today' or 'week'
- Historical news can use dateRange: 'month'

The user may ask to open or create notes (which are called "notebooks"), navigate to a specific website, or ask general questions.

For entertainment requests like "watch [show/movie]", "listen to [music/podcast]", "play [game/video]":
- These are requests to USE a service, not learn about it
- Open the appropriate streaming/entertainment service (Netflix, HBO Max, YouTube, Spotify, etc.)
- For YouTube: Use search URLs like "youtube.com/results?search_query=..." with URL-encoded queries (spaces as %20 or +)
- If you're not sure which service has the content, you can ask or open the most likely one
- Examples: 
  - "watch white lotus" → open HBO Max
  - "watch jony ive stripe video" → open youtube.com/results?search_query=jony+ive+stripe
  - "listen to taylor swift" → open Spotify
- Default to popular services if unsure: Netflix for TV/movies, YouTube for videos, Spotify for music

For search service requests like "search [service] for [query]":
- These are requests to USE a specific search service, not to search about that service
- Always use open_url with the proper search URL format:
  - "search google for X" → open_url: google.com/search?q=X
  - "search perplexity for X" → open_url: perplexity.ai/search?q=X  
  - "search duckduckgo for X" → open_url: duckduckgo.com/?q=X
  - "search bing for X" → open_url: bing.com/search?q=X
  - "search wikipedia for X" → open_url: en.wikipedia.org/w/index.php?search=X
- Replace spaces in queries with + or %20
- NEVER use search_web when the user explicitly names a search service

For news and headlines requests:
- "headlines from [source]" or "what are the headlines" → Use search_web to get fresh headlines
- IMPORTANT: If multiple sources are mentioned (e.g., "FT, WSJ, and NYT"), you MUST make MULTIPLE search_web calls - one for EACH source
  Example: User asks "headlines from FT, WSJ, and NYT" → Make 3 separate tool calls:
  1. search_web for "headlines from FT"
  2. search_web for "headlines from WSJ"  
  3. search_web for "headlines from NYT"
- The search implementation will detect and handle multiple sources automatically
- Focus on today's date unless a specific timeframe is mentioned
- Present headlines clearly without paywall content

For informational requests like "read me a daily reflection", "what's the weather", "tell me about X":
- Use search_web to fetch the information and provide it directly
- Don't just send them to a search engine - that's a failure to be helpful

If the user's request clearly sounds like an action to interact with a notebook (e.g., opening, creating, finding, showing a notebook), respond with a function call to open or create a notebook.

Available notebooks:
${(await this.notebookService.getAllNotebooks()).map(nb => `- "${nb.title}" (ID: ${nb.id})`).join('\\n') || 'No notebooks available yet.'}
Today's date is ${new Date().toLocaleDateString()}.
Keep responses concise and factual.`;

        const tools: { type: "function"; function: OpenAIFunction }[] = [
            {
                type: "function",
                function: {
                    name: "open_notebook",
                    description: "Opens an existing notebook. Use if the user explicitly asks to open, find, or show a specific notebook.",
                    parameters: {
                        type: "object",
                        properties: {
                            notebook_name: {
                                type: "string",
                                description: "The exact name or title of the notebook to open.",
                            },
                        },
                        required: ["notebook_name"],
                    },
                },
            },
            {
                type: "function",
                function: {
                    name: "create_notebook",
                    description: "Creates a new notebook. Use if the user explicitly asks to create or make a new notebook.",
                    parameters: {
                        type: "object",
                        properties: {
                            title: {
                                type: "string",
                                description: "The title for the new notebook.",
                            },
                        },
                        required: ["title"],
                    },
                },
            },
            {
                type: "function",
                function: {
                    name: "search_web",
                    description: "Search the web for information using Exa.ai's neural search and your local knowledge base. Use this to answer questions that require current information or specific facts. This provides hybrid search combining web results with your personal notes and documents. IMPORTANT: When users ask for multiple news sources, include ALL sources in a single query (e.g., 'headlines from FT, WSJ, and NYT') - the system will automatically search each source.",
                    parameters: {
                        type: "object",
                        properties: {
                            query: {
                                type: "string",
                                description: "The search query. For multiple news sources, include ALL sources in one query (e.g., 'headlines from FT, WSJ, and NYT today').",
                            },
                            searchType: {
                                type: "string",
                                description: "Type of search: 'general' for any content, 'news' for news articles, 'headlines' for latest news headlines",
                            },
                            dateRange: {
                                type: "string",
                                description: "For news searches: 'today' for today's news, 'week' for past week, 'month' for past month",
                            },
                        },
                        required: ["query"],
                    },
                },
            },
            {
                type: "function",
                function: {
                    name: "open_url",
                    description: "Opens a URL in the WebLayer browser overlay for the user to interact with. Use this when the user wants to browse a website or search a specific service. For 'search [service] for [query]' requests, construct the proper search URL (e.g., google.com/search?q=query, perplexity.ai/search?q=query). This is for interactive browsing, not for retrieving information.",
                    parameters: {
                        type: "object",
                        properties: {
                            url: {
                                type: "string",
                                description: "The URL to open in the browser. Protocol (https://) will be added automatically if missing. For search URLs, encode spaces as + or %20 (e.g., perplexity.ai/search?q=pope+leo).",
                            },
                        },
                        required: ["url"],
                    },
                },
            },
        ];

        // Get or initialize conversation history for this sender
        let messages = this.conversationHistory.get(senderId) || [];
        
        // Add system prompt if this is a new conversation
        if (messages.length === 0) {
            messages.push({ role: "system", content: systemPrompt });
        }
        
        // Add the current user message
        messages.push({ role: "user", content: payload.intentText });

        try {
            // Filter messages to ensure proper tool message context
            const filteredMessages = this.filterMessagesForValidToolContext(messages);
            
            const requestBody: OpenAIRequest = {
                model: "gpt-4o", // Using gpt-4o as discussed
                messages: filteredMessages,
                tools,
                tool_choice: "auto",
                temperature: 1.0,
            };
            
            logger.debug('[AgentService] OpenAI Request Body:', JSON.stringify(requestBody, null, 2));

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${this.openAIKey}`,
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const errorData = await response.json();
                logger.error(`[AgentService] OpenAI API error: ${response.status} ${response.statusText}`, errorData);
                return { type: 'error', message: `OpenAI API Error: ${errorData?.error?.message || response.statusText}` };
            }

            const responseData = await response.json() as OpenAIResponse;
            logger.debug('[AgentService] OpenAI Response Body:', JSON.stringify(responseData, null, 2));


            const assistantMessage = responseData.choices?.[0]?.message;
            
            // Store the assistant's response in conversation history
            if (assistantMessage) {
                messages.push(assistantMessage);
                
                // Trim history if it's getting too long
                if (messages.length > this.MAX_HISTORY_LENGTH) {
                    // Keep system message and trim old messages
                    messages = [messages[0], ...messages.slice(-this.MAX_HISTORY_LENGTH + 1)];
                }
                
                // Update the stored conversation history
                this.conversationHistory.set(senderId, messages);
            }

            if (assistantMessage?.tool_calls && assistantMessage.tool_calls.length > 0) {
                logger.info(`[AgentService] OpenAI responded with ${assistantMessage.tool_calls.length} tool call(s)`);
                
                // Process ALL tool calls, not just the first one
                const toolResponses: Array<{
                    toolCallId: string;
                    content: string;
                    immediateReturn?: any;
                }> = [];
                
                // Process ALL tool calls in parallel when possible
                const toolPromises = assistantMessage.tool_calls.map(toolCall => 
                    this.processToolCall(toolCall, senderId).then(result => ({
                        toolCallId: toolCall.id,
                        ...result
                    }))
                );
                
                const toolResults = await Promise.all(toolPromises);
                
                // Add all tool responses to conversation
                for (const result of toolResults) {
                    messages.push({
                        role: "tool",
                        content: result.content,
                        tool_call_id: result.toolCallId
                    });
                }
                
                // Update conversation history
                const cleanHistory = this.filterMessagesForValidToolContext(messages);
                this.conversationHistory.set(senderId, cleanHistory);
                
                // Check for immediate returns
                const immediateReturn = toolResults.find(r => r.immediateReturn);
                if (immediateReturn) {
                    return immediateReturn.immediateReturn;
                }
                
                // If we have search results, make a follow-up call
                const hasSearchResults = toolResults.some((result, index) => 
                    assistantMessage.tool_calls[index].function.name === 'search_web' && 
                    !result.content.startsWith('Error:')
                );
                
                if (hasSearchResults) {
                    const followUpRequest: OpenAIRequest = {
                        model: "gpt-4o",
                        messages: cleanHistory,
                        temperature: 1.0,
                    };
                    
                    try {
                        const followUpResponse = await fetch("https://api.openai.com/v1/chat/completions", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.openAIKey}`,
                            },
                            body: JSON.stringify(followUpRequest),
                        });
                        
                        if (followUpResponse.ok) {
                            const followUpData = await followUpResponse.json() as OpenAIResponse;
                            const followUpMessage = followUpData.choices?.[0]?.message;
                            
                            if (followUpMessage?.content) {
                                messages.push(followUpMessage);
                                const finalHistory = this.filterMessagesForValidToolContext(messages);
                                this.conversationHistory.set(senderId, finalHistory);
                                
                                return { type: 'chat_reply', message: followUpMessage.content };
                            }
                        }
                    } catch (error) {
                        logger.error(`[AgentService] Error in follow-up request:`, error);
                    }
                    
                    // Fallback
                    const searchContents = toolResults
                        .filter((result, index) => 
                            assistantMessage.tool_calls[index].function.name === 'search_web' && 
                            !result.content.startsWith('Error:')
                        )
                        .map(r => r.content)
                        .join('\n\n');
                    
                    return { 
                        type: 'chat_reply', 
                        message: `I found search results but couldn't summarize them properly. Here's what I found:\n\n${searchContents}` 
                    };
                }
                
            } else if (assistantMessage?.content) {
                logger.info(`[AgentService] OpenAI responded with text content.`);
                return { type: 'chat_reply', message: assistantMessage.content };
            } else {
                logger.warn('[AgentService] OpenAI response did not contain tool calls or content.', responseData);
                return { type: 'error', message: "Sorry, I received an unclear response from the AI. Please try again." };
            }

        } catch (error) {
            logger.error(`[AgentService] Error processing complex intent with OpenAI:`, error);
            return { type: 'error', message: `Sorry, I couldn't process that request: ${error instanceof Error ? error.message : 'Please try again'}` };
        }
    }
    
    /**
     * Clears the conversation history for a specific sender.
     * @param senderId The ID of the sender whose conversation to clear.
     */
    clearConversation(senderId: number): void {
        this.conversationHistory.delete(senderId);
        logger.info(`[AgentService] Cleared conversation history for sender ${senderId}`);
    }
    
    /**
     * Clears all conversation histories.
     */
    clearAllConversations(): void {
        this.conversationHistory.clear();
        logger.info(`[AgentService] Cleared all conversation histories`);
    }
    
    /**
     * Gets the conversation history size for monitoring purposes.
     * @returns The number of active conversations being tracked.
     */
    getActiveConversationCount(): number {
        return this.conversationHistory.size;
    }
    
    /**
     * Extracts news categories from a query.
     * @param query The search query
     * @returns Array of categories
     */
    private extractCategoriesFromQuery(query: string): string[] {
        const lowerQuery = query.toLowerCase();
        const allCategories = ['technology', 'business', 'politics', 'science', 'health', 'sports', 'entertainment'];
        
        // Check if specific categories are mentioned
        const mentionedCategories = allCategories.filter(cat => lowerQuery.includes(cat));
        
        if (mentionedCategories.length > 0) {
            return mentionedCategories;
        }
        
        // Default categories for general headlines
        return ['general', 'technology', 'business', 'politics'];
    }
    
    // ===== Atomic Formatting Functions =====
    // These small, focused functions handle individual formatting tasks
    
    /**
     * Formats a result title with optional index number.
     */
    private formatResultTitle(title: string, index?: number): string {
        if (index !== undefined) {
            return `**[${index + 1}] ${title}**`;
        }
        return `**${title}**`;
    }
    
    /**
     * Formats a date, either inline or on a separate line.
     */
    private formatResultDate(date?: string, format: 'inline' | 'separate' = 'separate'): string {
        if (!date) return '';
        
        const formattedDate = new Date(date).toLocaleDateString();
        
        if (format === 'inline') {
            return ` | ${formattedDate}`;
        }
        return `Published: ${formattedDate}`;
    }
    
    /**
     * Formats author information.
     */
    private formatResultAuthor(author?: string): string {
        if (!author) return '';
        return `By: ${author}`;
    }
    
    /**
     * Formats highlights as bullet points.
     */
    private formatResultHighlights(highlights?: string[], options?: {
        maxCount?: number;
        prefix?: string;
    }): string {
        if (!highlights || highlights.length === 0) return '';
        
        const { maxCount = highlights.length, prefix = 'Key points:' } = options || {};
        const itemsToShow = highlights.slice(0, maxCount);
        
        let formatted = prefix ? `${prefix}\n` : '';
        formatted += itemsToShow.map(h => `- ${h}`).join('\n');
        
        return formatted;
    }
    
    /**
     * Formats content snippet when no highlights are available.
     */
    private formatResultContentSnippet(content?: string, maxLength: number = 200): string {
        if (!content) return '';
        
        const snippet = content.substring(0, maxLength).trim();
        return snippet + (content.length > maxLength ? '...' : '');
    }
    
    /**
     * Formats a URL as a markdown link.
     */
    private formatResultLink(url?: string, text: string = 'Read more'): string {
        if (!url) return '';
        return `[${text}](${url})`;
    }
    
    /**
     * Formats metadata (score, source, etc.) in a consistent way.
     */
    private formatResultMetadata(result: HybridSearchResult, includeScore: boolean = false): string {
        const parts: string[] = [];
        
        if (result.source) {
            parts.push(`Source: ${result.source === 'exa' ? 'Web' : 'Local'}`);
        }
        
        if (includeScore) {
            parts.push(`Score: ${result.score.toFixed(3)}`);
        }
        
        if (result.publishedDate) {
            parts.push(new Date(result.publishedDate).toLocaleDateString());
        }
        
        if (result.author) {
            parts.push(`By ${result.author}`);
        }
        
        return parts.join(' | ');
    }
    
    /**
     * Formats a single search result with configurable options.
     */
    private formatSingleResult(result: HybridSearchResult, options?: {
        showIndex?: boolean;
        index?: number;
        showAuthor?: boolean;
        showHighlights?: boolean;
        maxHighlights?: number;
        showContentSnippet?: boolean;
        contentSnippetLength?: number;
        showMetadata?: boolean;
        showScore?: boolean;
        dateFormat?: 'inline' | 'separate';
        linkText?: string;
    }): string {
        const {
            showIndex = false,
            index,
            showAuthor = true,
            showHighlights = true,
            maxHighlights,
            showContentSnippet = true,
            contentSnippetLength = 200,
            showMetadata = false,
            showScore = false,
            dateFormat = 'separate',
            linkText = 'Read more'
        } = options || {};
        
        const lines: string[] = [];
        
        // Title
        lines.push(this.formatResultTitle(result.title, showIndex ? index : undefined));
        
        // Metadata line (if enabled)
        if (showMetadata) {
            const metadata = this.formatResultMetadata(result, showScore);
            if (metadata) lines.push(metadata);
        } else {
            // Traditional separate fields
            if (dateFormat === 'separate') {
                const date = this.formatResultDate(result.publishedDate);
                if (date) lines.push(date);
            }
            
            if (showAuthor) {
                const author = this.formatResultAuthor(result.author);
                if (author) lines.push(author);
            }
        }
        
        // Highlights or content snippet
        if (showHighlights && result.highlights && result.highlights.length > 0) {
            lines.push(this.formatResultHighlights(result.highlights, { maxCount: maxHighlights }));
        } else if (showContentSnippet && result.content) {
            lines.push(this.formatResultContentSnippet(result.content, contentSnippetLength));
        }
        
        // Link
        const link = this.formatResultLink(result.url, linkText);
        if (link) lines.push(link);
        
        return lines.join('\n');
    }
    
    /**
     * Groups results by a specified field.
     */
    private groupResultsByField(
        results: HybridSearchResult[], 
        groupBy: (result: HybridSearchResult) => string
    ): Record<string, HybridSearchResult[]> {
        const grouped: Record<string, HybridSearchResult[]> = {};
        
        for (const result of results) {
            const key = groupBy(result);
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(result);
        }
        
        return grouped;
    }
    
    // ===== High-level Formatting Methods =====
    // These methods use the atomic functions to create specific layouts
    
    /**
     * Formats headline results for presentation.
     * @param headlinesByCategory Headlines organized by category
     * @returns Formatted string
     */
    private formatHeadlineResults(headlinesByCategory: Record<string, HybridSearchResult[]>): string {
        let formatted = "# Today's Top Headlines\n\n";
        
        for (const [category, headlines] of Object.entries(headlinesByCategory)) {
            if (headlines.length === 0) continue;
            
            formatted += `## ${category.charAt(0).toUpperCase() + category.slice(1)} News\n\n`;
            
            headlines.forEach((headline, index) => {
                // Use atomic functions for consistent formatting
                formatted += `**${index + 1}. ${headline.title}**`;
                formatted += this.formatResultDate(headline.publishedDate, 'inline');
                formatted += '\n';
                
                // First highlight only for headlines
                if (headline.highlights && headline.highlights.length > 0) {
                    formatted += `   • ${headline.highlights[0]}\n`;
                }
                
                // Link
                if (headline.url) {
                    formatted += `   ${this.formatResultLink(headline.url)}\n`;
                }
                
                formatted += '\n';
            });
        }
        
        return formatted;
    }
    
    
    /**
     * Detects news sources mentioned in a query.
     * @param query The user's query
     * @returns Object with detected sources and cleaned query
     */
    private detectNewsSources(query: string): { sources: string[]; cleanedQuery: string } {
        const sourceMap: Record<string, string[]> = {
            'ft.com': ['ft', 'financial times', 'the financial times'],
            'wsj.com': ['wsj', 'wall street journal', 'the wall street journal'],
            'nytimes.com': ['nyt', 'ny times', 'new york times', 'the new york times'],
            'washingtonpost.com': ['wapo', 'washington post', 'the washington post'],
            'bbc.com': ['bbc', 'bbc news'],
            'cnn.com': ['cnn'],
            'reuters.com': ['reuters'],
            'bloomberg.com': ['bloomberg'],
            'theguardian.com': ['guardian', 'the guardian'],
            'economist.com': ['economist', 'the economist'],
        };
        
        const lowerQuery = query.toLowerCase();
        const detectedSources: string[] = [];
        let cleanedQuery = query;
        
        for (const [domain, aliases] of Object.entries(sourceMap)) {
            for (const alias of aliases) {
                if (lowerQuery.includes(alias)) {
                    if (!detectedSources.includes(domain)) {
                        detectedSources.push(domain);
                    }
                    // Remove the source name from the query
                    cleanedQuery = cleanedQuery.replace(new RegExp(alias, 'gi'), '').trim();
                }
            }
        }
        
        // Clean up any leftover connecting words and punctuation
        cleanedQuery = cleanedQuery
            .replace(/\b(and|from|in|the)\b/gi, ' ')
            .replace(/,/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        
        return { sources: detectedSources, cleanedQuery };
    }


    private formatMultiSourceResults(results: HybridSearchResult[], sources: string[]): string {
        if (results.length === 0) {
            return `No recent headlines found from ${sources.join(', ')}.`;
        }
        
        // Group results by source using our atomic function
        const resultsBySource = this.groupResultsByField(
            results, 
            result => result.url ? new URL(result.url).hostname : 'unknown'
        );
        
        // Format the results
        let formatted = `# Headlines from ${sources.join(', ')}\n\n`;
        
        for (const [source, sourceResults] of Object.entries(resultsBySource)) {
            const sourceName = this.getSourceDisplayName(source);
            formatted += `## ${sourceName}\n\n`;
            
            // Use formatSingleResult for each result
            sourceResults.forEach((result, index) => {
                formatted += this.formatSingleResult(result, {
                    showIndex: false,
                    showAuthor: false, // Multi-source view doesn't show author
                    showHighlights: true,
                    showContentSnippet: true,
                    dateFormat: 'separate',
                });
                formatted += '\n\n';
            });
        }
        
        return formatted.trim();
    }

    private formatNewsResults(results: HybridSearchResult[]): string {
        if (results.length === 0) {
            return 'No news results found.';
        }
        
        let formatted = '# News Search Results\n\n';
        
        // Use formatSingleResult for each result
        results.forEach((result, index) => {
            formatted += this.formatSingleResult(result, {
                showIndex: false,
                showAuthor: true, // News results show author
                showHighlights: true,
                showContentSnippet: true,
                dateFormat: 'separate',
            });
            formatted += '\n\n';
        });
        
        return formatted.trim();
    }
    
    private formatSearchResults(results: HybridSearchResult[]): string {
        if (results.length === 0) {
            return 'No search results found.';
        }
        
        let formatted = '# Search Results\n\n';
        
        // Group by source
        const bySource = this.groupResultsByField(results, r => r.source);
        
        for (const [source, sourceResults] of Object.entries(bySource)) {
            if (source === 'local') {
                formatted += '## From Your Notes\n\n';
            } else {
                formatted += '## From the Web\n\n';
            }
            
            sourceResults.forEach((result, index) => {
                formatted += this.formatSingleResult(result, {
                    showIndex: true,
                    showAuthor: false,
                    showHighlights: true,
                    showContentSnippet: true,
                    dateFormat: 'inline',
                });
                formatted += '\n\n';
            });
        }
        
        return formatted.trim();
    }

    private getSourceDisplayName(hostname: string): string {
        const displayNames: Record<string, string> = {
            'ft.com': 'Financial Times',
            'wsj.com': 'Wall Street Journal',
            'nytimes.com': 'New York Times',
            'washingtonpost.com': 'Washington Post',
            'bbc.com': 'BBC',
            'cnn.com': 'CNN',
            'reuters.com': 'Reuters',
            'bloomberg.com': 'Bloomberg',
            'theguardian.com': 'The Guardian',
            'economist.com': 'The Economist',
        };
        
        return displayNames[hostname] || hostname;
    }
    
    /**
     * Filters messages to ensure tool messages have proper context.
     * Tool messages must immediately follow an assistant message with tool_calls.
     * This method removes orphaned tool messages that don't have their corresponding tool_calls.
     * @param messages The messages to filter
     * @returns Filtered messages with valid tool context
     */
    private filterMessagesForValidToolContext(messages: OpenAIMessage[]): OpenAIMessage[] {
        const filtered: OpenAIMessage[] = [];
        
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            
            // If it's a tool message, check if the previous message is an assistant with tool_calls
            if (message.role === 'tool') {
                const prevMessage = i > 0 ? messages[i - 1] : null;
                
                // Only include tool message if previous message is assistant with tool_calls
                // and contains a matching tool_call_id
                if (prevMessage?.role === 'assistant' && prevMessage.tool_calls) {
                    const hasMatchingToolCall = prevMessage.tool_calls.some(
                        tc => tc.id === message.tool_call_id
                    );
                    
                    if (hasMatchingToolCall) {
                        filtered.push(message);
                    } else {
                        logger.debug(`[AgentService] Filtering out orphaned tool message with ID ${message.tool_call_id} - no matching tool_call`);
                    }
                } else {
                    logger.debug(`[AgentService] Filtering out orphaned tool message with ID ${message.tool_call_id} - no preceding assistant message with tool_calls`);
                }
            } else {
                // Include all non-tool messages
                filtered.push(message);
            }
        }
        
        return filtered;
    }
    
    /**
     * Process a single tool call and return the response
     */
    private async processToolCall(toolCall: any, senderId: number): Promise<{
        content: string;
        immediateReturn?: any;
    }> {
        const functionName = toolCall.function.name;
        let args: any;
        
        try {
            args = JSON.parse(toolCall.function.arguments);
        } catch (parseError) {
            logger.error(`[AgentService] Failed to parse JSON arguments for tool call ${functionName}:`, toolCall.function.arguments, parseError);
            return { content: `Error: Failed to parse arguments for ${functionName}` };
        }
        
        logger.info(`[AgentService] Processing tool call: ${functionName}`, args);
        
        switch (functionName) {
            case "open_notebook": {
                const notebookName = args.notebook_name;
                if (!notebookName || typeof notebookName !== 'string') {
                    return { content: "Error: Notebook name was unclear." };
                }
                
                const notebooks = await this.notebookService.getAllNotebooks();
                const foundNotebook = notebooks.find(nb => nb.title.toLowerCase() === notebookName.toLowerCase());
                
                if (foundNotebook) {
                    logger.info(`[AgentService] Found notebook "${notebookName}" (ID: ${foundNotebook.id})`);
                    return {
                        content: `Opened notebook: ${foundNotebook.title}`,
                        immediateReturn: {
                            type: 'open_notebook',
                            notebookId: foundNotebook.id,
                            title: foundNotebook.title,
                            message: `Right on, I'll open "${foundNotebook.title}" for you.`
                        }
                    };
                } else {
                    logger.warn(`[AgentService] Notebook "${notebookName}" not found`);
                    return { content: `Notebook "${notebookName}" not found.` };
                }
            }
            
            case "create_notebook": {
                const title = args.title;
                if (!title || typeof title !== 'string') {
                    return { content: "Error: Notebook title was unclear." };
                }
                
                try {
                    const newNotebook = await this.notebookService.createNotebook(title);
                    logger.info(`[AgentService] Created new notebook "${title}" (ID: ${newNotebook.id})`);
                    return {
                        content: `Created and opened notebook: ${newNotebook.title}`,
                        immediateReturn: {
                            type: 'open_notebook',
                            notebookId: newNotebook.id,
                            title: newNotebook.title,
                            message: `Right on, I've created "${newNotebook.title}" and I'll open it for you now.`
                        }
                    };
                } catch (createError) {
                    logger.error(`[AgentService] Error creating notebook:`, createError);
                    return { content: `Failed to create notebook: ${createError instanceof Error ? createError.message : 'Unknown error'}` };
                }
            }
            
            case "search_web": {
                const query = args.query;
                const searchType = args.searchType || 'general';
                
                if (!query || typeof query !== 'string') {
                    return { content: "Error: Search query was unclear." };
                }
                
                logger.info(`[AgentService] Searching web for: "${query}" (type: ${searchType})`);
                
                try {
                    let searchResults: string;
                    
                    if (searchType === 'headlines' || searchType === 'news') {
                        const { sources, cleanedQuery } = this.detectNewsSources(query);
                        
                        if (sources.length > 0) {
                            logger.info(`[AgentService] Detected news sources: ${sources.join(', ')}`);
                            
                            const { cleanNewsContent } = await import('./helpers/contentFilter');
                            
                            const searchPromises = sources.map(async (source) => {
                                try {
                                    const sourceQuery = cleanedQuery || 'headlines';
                                    const searchQuery = `site:${source} ${sourceQuery} today`;
                                    
                                    const exaResponse = await this.exaService.search(searchQuery, {
                                        type: 'neural',
                                        numResults: 3,
                                        includeDomains: [source],
                                        contents: {
                                            text: true,
                                            highlights: true,
                                            summary: true,
                                        },
                                    });
                                    
                                    const hybridResults = exaResponse.results.map(result => ({
                                        id: result.id,
                                        title: result.title,
                                        url: result.url,
                                        content: result.text ? cleanNewsContent(result.text) : result.summary || '',
                                        score: result.score,
                                        source: 'exa' as const,
                                        publishedDate: result.publishedDate,
                                        author: result.author,
                                        highlights: result.highlights,
                                    }));
                                    
                                    return { source, results: hybridResults, error: null };
                                } catch (error) {
                                    logger.error(`[AgentService] Failed to search ${source}:`, error);
                                    return { source, results: [], error };
                                }
                            });
                            
                            const sourceSearchResults = await Promise.all(searchPromises);
                            
                            const allResults: HybridSearchResult[] = [];
                            const failedSources: string[] = [];
                            
                            for (const { source, results, error } of sourceSearchResults) {
                                if (error) {
                                    failedSources.push(source);
                                }
                                allResults.push(...results);
                            }
                            
                            if (failedSources.length > 0) {
                                logger.warn(`[AgentService] Failed to search ${failedSources.length} sources: ${failedSources.join(', ')}`);
                            }
                            
                            searchResults = this.formatMultiSourceResults(allResults, sources);
                        } else {
                            const newsResults = await this.hybridSearchService.searchNews(query, {
                                numResults: 10,
                                useAI: this.exaService.isConfigured(),
                            });
                            searchResults = this.formatNewsResults(newsResults);
                        }
                    } else {
                        const results = await this.hybridSearchService.search(query, {
                            numResults: 10,
                            searchLocal: true,
                            searchWeb: true,
                            useAI: this.exaService.isConfigured(),
                        });
                        searchResults = this.formatSearchResults(results);
                    }
                    
                    return { content: searchResults };
                } catch (error) {
                    logger.error(`[AgentService] Error searching web:`, error);
                    return { content: `Search failed: ${error instanceof Error ? error.message : 'Unknown error'}` };
                }
            }
            
            case "open_url": {
                const url = args.url;
                if (!url || typeof url !== 'string') {
                    return { content: "Error: URL was unclear." };
                }
                
                let formattedUrl = url.trim();
                if (!formattedUrl.startsWith('http://') && !formattedUrl.startsWith('https://')) {
                    formattedUrl = 'https://' + formattedUrl;
                }
                
                logger.info(`[AgentService] Opening URL "${formattedUrl}" in WebLayer.`);
                return {
                    content: `Opened URL: ${formattedUrl}`,
                    immediateReturn: {
                        type: 'open_url',
                        url: formattedUrl,
                        message: `Right on, I'll open that for you.`
                    }
                };
            }
            
            default:
                logger.warn(`[AgentService] Unknown tool call: ${functionName}`);
                return { content: `Unknown tool: ${functionName}` };
        }
    }
    
} 